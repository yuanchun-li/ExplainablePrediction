{"rec_id": "16", "recitation_code": "return criteria", "input_code_id": 16, "input": "<s> from django . contrib . contenttypes . models import ContentType <EOL> from lfs . core . utils import import_symbol <EOL> class Criteria ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def is_valid ( self , request , product = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for criterion in self . get_criteria ( ) : <EOL> criterion . request = request <EOL> criterion . product = product <EOL> if not criterion . is_valid ( ) : <EOL> return False <EOL> return True <EOL> def get_criteria ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> content_type = ContentType . objects . get_for_model ( self ) <EOL> criteria = [ ] <EOL> from lfs . criteria . models import Criterion <EOL> for criterion in Criterion . objects . filter ( content_id = self . id , content_type = content_type ) : <EOL> criteria . append ( criterion . get_content_object ( ) ) <EOL>"}
{"rec_id": "16", "recitation_code": "return criteria", "input_code_id": 8497, "input": "<s> from braintree . credit_card_verification import CreditCardVerification <EOL> from braintree . credit_card_verification_search import CreditCardVerificationSearch <EOL> from braintree . exceptions . not_found_error import NotFoundError <EOL> from braintree . ids_search import IdsSearch <EOL> from braintree . resource_collection import ResourceCollection <EOL> from braintree . error_result import ErrorResult <EOL> from braintree . successful_result import SuccessfulResult <EOL> class CreditCardVerificationGateway ( object ) : <EOL> def __init__ ( self , gateway ) : <EOL> self . gateway = gateway <EOL> self . config = gateway . config <EOL> def find ( self , verification_id ) : <EOL> try : <EOL> if verification_id is None or verification_id . strip ( ) == \"<STR_LIT>\" : <EOL> raise NotFoundError ( ) <EOL> response = self . config . http ( ) . get ( self . config . base_merchant_path ( ) + \"<STR_LIT>\" + verification_id ) <EOL> return CreditCardVerification ( self . gateway , response [ \"<STR_LIT>\" ] ) <EOL> except NotFoundError : <EOL> raise NotFoundError ( \"<STR_LIT>\" + repr ( verification_id ) + \"<STR_LIT>\" ) <EOL> def __criteria ( self , query ) : <EOL> criteria = { } <EOL> for term in query : <EOL> if criteria . get ( term . name ) : <EOL> criteria [ term . name ] = dict ( list ( criteria [ term . name ] . items ( ) ) + list ( term . to_param ( ) . items ( ) ) ) <EOL>"}
{"rec_id": "49", "recitation_code": "super ( ReCaptchaField , self ) . init ( * args , * * kwargs )", "input_code_id": 49, "input": "<s> from django . conf import settings <EOL> from django import forms <EOL> from django . utils . encoding import smart_unicode <EOL> from django . utils . translation import ugettext_lazy as _ <EOL> from widgets import * <EOL> from recaptcha . client import captcha <EOL> class ReCaptchaField ( forms . CharField ) : <EOL> default_error_messages = { <EOL> '<STR_LIT>' : _ ( u'<STR_LIT>' ) <EOL> } <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL>"}
{"rec_id": "49", "recitation_code": "super ( ReCaptchaField , self ) . init ( * args , * * kwargs )", "input_code_id": 16621, "input": "<s> from django . conf import settings <EOL> from django import forms <EOL> from django . utils . encoding import smart_unicode <EOL> from django . utils . translation import ugettext_lazy as _ <EOL> from recaptcha . client import captcha <EOL> from recaptcha_comments . widgets import ReCaptcha <EOL> captcha . API_SERVER = \"<STR_LIT>\" <EOL> captcha . VERIFY_SERVER = \"<STR_LIT>\" <EOL> class ReCaptchaField ( forms . CharField ) : <EOL> default_error_messages = { <EOL> '<STR_LIT>' : _ ( u'<STR_LIT>' ) <EOL> } <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL>"}
{"rec_id": "64", "recitation_code": "test . writable ( ' ' , True )", "input_code_id": 64, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import TestGyp <EOL> test = TestGyp . TestGyp ( formats = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> test . run_gyp ( '<STR_LIT>' , '<STR_LIT>' , chdir = '<STR_LIT:src>' ) <EOL> if test . format == '<STR_LIT>' : <EOL> if test . uses_msbuild : <EOL> test . must_contain ( '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> else : <EOL> test . must_contain ( '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> test . relocate ( '<STR_LIT:src>' , '<STR_LIT>' ) <EOL> test . subdir ( '<STR_LIT>' ) <EOL> test . writable ( '<STR_LIT>' , False ) <EOL> test . writable ( '<STR_LIT>' , True ) <EOL>"}
{"rec_id": "64", "recitation_code": "test . writable ( ' ' , True )", "input_code_id": 63013, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import TestGyp <EOL> test = TestGyp . TestGyp ( formats = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> test . run_gyp ( '<STR_LIT>' , '<STR_LIT>' , chdir = '<STR_LIT:src>' ) <EOL> if test . format == '<STR_LIT>' : <EOL> if test . uses_msbuild : <EOL> test . must_contain ( '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> else : <EOL> test . must_contain ( '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> test . relocate ( '<STR_LIT:src>' , '<STR_LIT>' ) <EOL> test . subdir ( '<STR_LIT>' ) <EOL> test . writable ( '<STR_LIT>' , False ) <EOL> test . writable ( '<STR_LIT>' , True ) <EOL>"}
{"rec_id": "64", "recitation_code": "test . writable ( ' ' , True )", "input_code_id": 83449, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import TestGyp <EOL> test = TestGyp . TestGyp ( formats = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> test . run_gyp ( '<STR_LIT>' , '<STR_LIT>' , chdir = '<STR_LIT:src>' ) <EOL> if test . format == '<STR_LIT>' : <EOL> if test . uses_msbuild : <EOL> test . must_contain ( '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> else : <EOL> test . must_contain ( '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> test . relocate ( '<STR_LIT:src>' , '<STR_LIT>' ) <EOL> test . subdir ( '<STR_LIT>' ) <EOL> test . writable ( '<STR_LIT>' , False ) <EOL> test . writable ( '<STR_LIT>' , True ) <EOL>"}
{"rec_id": "134", "recitation_code": "return dr", "input_code_id": 134, "input": "<s> from migen . fhdl . module import Module <EOL> from migen . fhdl . specials import Instance <EOL> from migen . genlib . io import * <EOL> from migen . genlib . resetsync import AsyncResetSynchronizer <EOL> class LatticeAsyncResetSynchronizerImpl ( Module ) : <EOL> def __init__ ( self , cd , async_reset ) : <EOL> rst1 = Signal ( ) <EOL> self . specials += [ <EOL> Instance ( \"<STR_LIT>\" , i_D = <NUM_LIT:0> , i_PD = async_reset , <EOL> i_CK = cd . clk , o_Q = rst1 ) , <EOL> Instance ( \"<STR_LIT>\" , i_D = rst1 , i_PD = async_reset , <EOL> i_CK = cd . clk , o_Q = cd . rst ) <EOL> ] <EOL> class LatticeAsyncResetSynchronizer : <EOL> @ staticmethod <EOL> def lower ( dr ) : <EOL>"}
{"rec_id": "134", "recitation_code": "return dr", "input_code_id": 26183, "input": "<s> from datetime import datetime <EOL> from opentuner import tuningrunmain <EOL> class TuningRunManager ( tuningrunmain . TuningRunMain ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , measurement_interface , args , ** kwargs ) : <EOL> super ( TuningRunManager , self ) . __init__ ( measurement_interface , args , ** kwargs ) <EOL> self . init ( ) <EOL> self . tuning_run . state = '<STR_LIT>' <EOL> self . commit ( force = True ) <EOL> self . search_driver . external_main_begin ( ) <EOL> def get_next_desired_result ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> dr = self . measurement_driver . query_pending_desired_results ( ) . first ( ) <EOL> if dr is None : <EOL> self . search_driver . external_main_generation ( ) <EOL> dr = self . measurement_driver . query_pending_desired_results ( ) . first ( ) <EOL> if dr is None : <EOL> return None <EOL> self . measurement_driver . claim_desired_result ( dr ) <EOL> dr . limit = self . measurement_driver . run_time_limit ( dr ) <EOL>"}
{"rec_id": "247", "recitation_code": "def encode request ( name , data list ) :", "input_code_id": 247, "input": "<s> from hazelcast . serialization . bits import * <EOL> from hazelcast . protocol . client_message import ClientMessage <EOL> from hazelcast . protocol . custom_codec import * <EOL> from hazelcast . util import ImmutableLazyDataList <EOL> from hazelcast . protocol . codec . queue_message_type import * <EOL> REQUEST_TYPE = QUEUE_COMPAREANDRETAINALL <EOL> RESPONSE_TYPE = <NUM_LIT> <EOL> RETRYABLE = False <EOL> def calculate_size ( name , data_list ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> data_size = <NUM_LIT:0> <EOL> data_size += calculate_size_str ( name ) <EOL> data_size += INT_SIZE_IN_BYTES <EOL> for data_list_item in data_list : <EOL> data_size += calculate_size_data ( data_list_item ) <EOL> return data_size <EOL>"}
{"rec_id": "247", "recitation_code": "def encode request ( name , data list ) :", "input_code_id": 56402, "input": "<s> from hazelcast . serialization . bits import * <EOL> from hazelcast . protocol . client_message import ClientMessage <EOL> from hazelcast . protocol . custom_codec import * <EOL> from hazelcast . util import ImmutableLazyDataList <EOL> from hazelcast . protocol . codec . queue_message_type import * <EOL> REQUEST_TYPE = QUEUE_ADDALL <EOL> RESPONSE_TYPE = <NUM_LIT> <EOL> RETRYABLE = False <EOL> def calculate_size ( name , data_list ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> data_size = <NUM_LIT:0> <EOL> data_size += calculate_size_str ( name ) <EOL> data_size += INT_SIZE_IN_BYTES <EOL> for data_list_item in data_list : <EOL> data_size += calculate_size_data ( data_list_item ) <EOL> return data_size <EOL>"}
{"rec_id": "247", "recitation_code": "def encode request ( name , data list ) :", "input_code_id": 66625, "input": "<s> from hazelcast . serialization . bits import * <EOL> from hazelcast . protocol . client_message import ClientMessage <EOL> from hazelcast . protocol . custom_codec import * <EOL> from hazelcast . util import ImmutableLazyDataList <EOL> from hazelcast . protocol . codec . queue_message_type import * <EOL> REQUEST_TYPE = QUEUE_CONTAINSALL <EOL> RESPONSE_TYPE = <NUM_LIT> <EOL> RETRYABLE = False <EOL> def calculate_size ( name , data_list ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> data_size = <NUM_LIT:0> <EOL> data_size += calculate_size_str ( name ) <EOL> data_size += INT_SIZE_IN_BYTES <EOL> for data_list_item in data_list : <EOL> data_size += calculate_size_data ( data_list_item ) <EOL> return data_size <EOL>"}
{"rec_id": "297", "recitation_code": "return TableMainFeaturesExample ( )", "input_code_id": 297, "input": "<s> from muntjac . ui . table import Table <EOL> from muntjac . demo . sampler . features . table . TableMainFeaturesExample import TableMainFeaturesExample <EOL> from muntjac . demo . sampler . APIResource import APIResource <EOL> from muntjac . demo . sampler . Feature import Feature , Version <EOL> class TableColumnAlignment ( Feature ) : <EOL> def getSinceVersion ( self ) : <EOL> return Version . OLD <EOL> def getName ( self ) : <EOL> return '<STR_LIT>' <EOL> def getExample ( self ) : <EOL>"}
{"rec_id": "297", "recitation_code": "return TableMainFeaturesExample ( )", "input_code_id": 1711, "input": "<s> from muntjac . ui . table import Table <EOL> from muntjac . demo . sampler . features . table . TableMainFeaturesExample import TableMainFeaturesExample <EOL> from muntjac . demo . sampler . APIResource import APIResource <EOL> from muntjac . demo . sampler . Feature import Feature , Version <EOL> class TableColumnHeaders ( Feature ) : <EOL> def getSinceVersion ( self ) : <EOL> return Version . OLD <EOL> def getName ( self ) : <EOL> return '<STR_LIT>' <EOL> def getExample ( self ) : <EOL>"}
{"rec_id": "297", "recitation_code": "return TableMainFeaturesExample ( )", "input_code_id": 29201, "input": "<s> from muntjac . ui . table import Table <EOL> from muntjac . demo . sampler . features . table . TableMainFeaturesExample import TableMainFeaturesExample <EOL> from muntjac . demo . sampler . APIResource import APIResource <EOL> from muntjac . demo . sampler . Feature import Feature , Version <EOL> class TableActions ( Feature ) : <EOL> def getSinceVersion ( self ) : <EOL> return Version . OLD <EOL> def getName ( self ) : <EOL> return '<STR_LIT>' <EOL> def getExample ( self ) : <EOL>"}
{"rec_id": "297", "recitation_code": "return TableMainFeaturesExample ( )", "input_code_id": 39476, "input": "<s> from muntjac . ui . table import Table <EOL> from muntjac . demo . sampler . features . table . TableMainFeaturesExample import TableMainFeaturesExample <EOL> from muntjac . demo . sampler . APIResource import APIResource <EOL> from muntjac . demo . sampler . Feature import Feature , Version <EOL> class TableRowHeaders ( Feature ) : <EOL> def getSinceVersion ( self ) : <EOL> return Version . OLD <EOL> def getName ( self ) : <EOL> return '<STR_LIT>' <EOL> def getExample ( self ) : <EOL>"}
{"rec_id": "337", "recitation_code": "rng = np . random . RandomState ( seed )", "input_code_id": 337, "input": "<s> import numpy as np <EOL> from . dtype import img_as_float <EOL> __all__ = [ '<STR_LIT>' ] <EOL> def random_noise ( image , mode = '<STR_LIT>' , seed = None , clip = True , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> mode = mode . lower ( ) <EOL> if image . min ( ) < <NUM_LIT:0> : <EOL> low_clip = - <NUM_LIT:1.> <EOL> else : <EOL> low_clip = <NUM_LIT:0.> <EOL> image = img_as_float ( image ) <EOL> if seed is not None : <EOL> np . random . seed ( seed = seed ) <EOL> allowedtypes = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' } <EOL> kwdefaults = { <EOL> '<STR_LIT>' : <NUM_LIT:0.> , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT:0.5> , <EOL> '<STR_LIT>' : np . zeros_like ( image ) + <NUM_LIT> } <EOL> allowedkwargs = { <EOL> '<STR_LIT>' : [ '<STR_LIT>' , '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' , '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ ] } <EOL> for key in kwargs : <EOL> if key not in allowedkwargs [ allowedtypes [ mode ] ] : <EOL> raise ValueError ( '<STR_LIT>' % <EOL> ( key , allowedkwargs [ allowedtypes [ mode ] ] ) ) <EOL> for kw in allowedkwargs [ allowedtypes [ mode ] ] : <EOL> kwargs . setdefault ( kw , kwdefaults [ kw ] ) <EOL> if mode == '<STR_LIT>' : <EOL>"}
{"rec_id": "337", "recitation_code": "rng = np . random . RandomState ( seed )", "input_code_id": 87323, "input": "<s> import numpy as np <EOL> import theano . tensor as T <EOL> from neupy . core . properties import ProperFractionProperty <EOL> from . base import BaseLayer <EOL> __all__ = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> class Dropout ( BaseLayer ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> proba = ProperFractionProperty ( required = True ) <EOL> def __init__ ( self , proba , ** options ) : <EOL> options [ '<STR_LIT>' ] = proba <EOL> super ( Dropout , self ) . __init__ ( ** options ) <EOL> @ property <EOL> def size ( self ) : <EOL> return self . relate_to_layer . size <EOL> def output ( self , input_value ) : <EOL> max_possible_seed = <NUM_LIT> <EOL> seed = np . random . randint ( max_possible_seed ) <EOL>"}
{"rec_id": "404", "recitation_code": "match = cache [ pat ] . match", "input_code_id": 404, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import re <EOL> __all__ = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> _cache = { } <EOL> def fnmatch ( name , pat ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> name = os . path . normcase ( name ) <EOL> pat = os . path . normcase ( pat ) <EOL> return fnmatchcase ( name , pat ) <EOL> def filter ( names , pat ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> import os , posixpath <EOL> result = [ ] <EOL> pat = os . path . normcase ( pat ) <EOL> if not pat in _cache : <EOL> res = translate ( pat ) <EOL> _cache [ pat ] = re . compile ( res ) <EOL> match = _cache [ pat ] . match <EOL> if os . path is posixpath : <EOL> for name in names : <EOL> if match ( name ) : <EOL> result . append ( name ) <EOL> else : <EOL> for name in names : <EOL> if match ( os . path . normcase ( name ) ) : <EOL> result . append ( name ) <EOL> return result <EOL> def fnmatchcase ( name , pat ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not pat in _cache : <EOL> res = translate ( pat ) <EOL> _cache [ pat ] = re . compile ( res ) <EOL>"}
{"rec_id": "404", "recitation_code": "match = cache [ pat ] . match", "input_code_id": 36142, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import re <EOL> __all__ = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> _cache = { } <EOL> def fnmatch ( name , pat ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> name = os . path . normcase ( name ) <EOL> pat = os . path . normcase ( pat ) <EOL> return fnmatchcase ( name , pat ) <EOL> def filter ( names , pat ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> import os , posixpath <EOL> result = [ ] <EOL> pat = os . path . normcase ( pat ) <EOL> if not pat in _cache : <EOL> res = translate ( pat ) <EOL> _cache [ pat ] = re . compile ( res ) <EOL> match = _cache [ pat ] . match <EOL> if os . path is posixpath : <EOL> for name in names : <EOL> if match ( name ) : <EOL> result . append ( name ) <EOL> else : <EOL> for name in names : <EOL> if match ( os . path . normcase ( name ) ) : <EOL> result . append ( name ) <EOL> return result <EOL> def fnmatchcase ( name , pat ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not pat in _cache : <EOL> res = translate ( pat ) <EOL> _cache [ pat ] = re . compile ( res ) <EOL>"}
{"rec_id": "467", "recitation_code": "InvalidStepB ( TestWorkflow ( self . request ) )", "input_code_id": 467, "input": "<s> from django import forms <EOL> from django import http <EOL> import six <EOL> from horizon import exceptions <EOL> from horizon . test import helpers as test <EOL> from horizon import workflows <EOL> PROJECT_ID = \"<STR_LIT>\" <EOL> INSTANCE_ID = \"<STR_LIT>\" <EOL> def local_callback_func ( request , context ) : <EOL> return \"<STR_LIT>\" <EOL> def other_callback_func ( request , context ) : <EOL> return \"<STR_LIT>\" <EOL> def extra_callback_func ( request , context ) : <EOL> return \"<STR_LIT>\" <EOL> class TestActionOne ( workflows . Action ) : <EOL> project_id = forms . ChoiceField ( label = \"<STR_LIT>\" ) <EOL> user_id = forms . ChoiceField ( label = \"<STR_LIT>\" ) <EOL> class Meta ( object ) : <EOL> name = \"<STR_LIT>\" <EOL> slug = \"<STR_LIT>\" <EOL> def populate_project_id_choices ( self , request , context ) : <EOL> return [ ( PROJECT_ID , \"<STR_LIT>\" ) ] <EOL> def populate_user_id_choices ( self , request , context ) : <EOL> return [ ( request . user . id , request . user . username ) ] <EOL> def handle ( self , request , context ) : <EOL> return { \"<STR_LIT:foo>\" : \"<STR_LIT:bar>\" } <EOL> class TestActionTwo ( workflows . Action ) : <EOL> instance_id = forms . CharField ( label = \"<STR_LIT>\" ) <EOL> class Meta ( object ) : <EOL> name = \"<STR_LIT>\" <EOL> slug = \"<STR_LIT>\" <EOL> class TestActionThree ( workflows . Action ) : <EOL> extra = forms . CharField ( widget = forms . widgets . Textarea ) <EOL> class Meta ( object ) : <EOL> name = \"<STR_LIT>\" <EOL> slug = \"<STR_LIT>\" <EOL> class AdminAction ( workflows . Action ) : <EOL> admin_id = forms . CharField ( label = \"<STR_LIT>\" ) <EOL> class Meta ( object ) : <EOL> name = \"<STR_LIT>\" <EOL> slug = \"<STR_LIT>\" <EOL> permissions = ( \"<STR_LIT>\" , ) <EOL> class TestStepOne ( workflows . Step ) : <EOL> action_class = TestActionOne <EOL> contributes = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> class TestStepTwo ( workflows . Step ) : <EOL> action_class = TestActionTwo <EOL> depends_on = ( \"<STR_LIT>\" , ) <EOL> contributes = ( \"<STR_LIT>\" , ) <EOL> connections = { \"<STR_LIT>\" : <EOL> ( local_callback_func , <EOL> \"<STR_LIT>\" ) } <EOL> class TestExtraStep ( workflows . Step ) : <EOL> action_class = TestActionThree <EOL> depends_on = ( \"<STR_LIT>\" , ) <EOL> contributes = ( \"<STR_LIT>\" , ) <EOL> connections = { \"<STR_LIT>\" : ( extra_callback_func , ) } <EOL> after = TestStepOne <EOL> before = TestStepTwo <EOL> class AdminStep ( workflows . Step ) : <EOL> action_class = AdminAction <EOL> contributes = ( \"<STR_LIT>\" , ) <EOL> after = TestStepOne <EOL> before = TestStepTwo <EOL> class TestWorkflow ( workflows . Workflow ) : <EOL> slug = \"<STR_LIT>\" <EOL> default_steps = ( TestStepOne , TestStepTwo ) <EOL> class TestWorkflowView ( workflows . WorkflowView ) : <EOL> workflow_class = TestWorkflow <EOL> template_name = \"<STR_LIT>\" <EOL> class TestFullscreenWorkflow ( workflows . Workflow ) : <EOL> slug = '<STR_LIT>' <EOL> default_steps = ( TestStepOne , TestStepTwo ) <EOL> fullscreen = True <EOL> class TestFullscreenWorkflowView ( workflows . WorkflowView ) : <EOL> workflow_class = TestFullscreenWorkflow <EOL> template_name = \"<STR_LIT>\" <EOL> class WorkflowsTests ( test . TestCase ) : <EOL> def setUp ( self ) : <EOL> super ( WorkflowsTests , self ) . setUp ( ) <EOL> def tearDown ( self ) : <EOL> super ( WorkflowsTests , self ) . tearDown ( ) <EOL> self . _reset_workflow ( ) <EOL> def _reset_workflow ( self ) : <EOL> TestWorkflow . _cls_registry = set ( [ ] ) <EOL> def test_workflow_construction ( self ) : <EOL> TestWorkflow . register ( TestExtraStep ) <EOL> flow = TestWorkflow ( self . request ) <EOL> self . assertQuerysetEqual ( flow . steps , <EOL> [ '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ] ) <EOL> self . assertEqual ( set ( [ '<STR_LIT>' ] ) , flow . depends_on ) <EOL> def test_step_construction ( self ) : <EOL> step_one = TestStepOne ( TestWorkflow ( self . request ) ) <EOL> self . assertEqual ( TestActionOne . name , step_one . name ) <EOL> self . assertEqual ( TestActionOne . slug , step_one . slug ) <EOL> self . assertEqual ( step_one . _handlers , { } ) <EOL> step_two = TestStepTwo ( TestWorkflow ( self . request ) ) <EOL> self . assertEqual ( [ local_callback_func , other_callback_func ] , <EOL> step_two . _handlers [ \"<STR_LIT>\" ] ) <EOL> def test_step_invalid_connections_handlers_not_list_or_tuple ( self ) : <EOL> class InvalidStepA ( TestStepTwo ) : <EOL> connections = { '<STR_LIT>' : { } } <EOL> class InvalidStepB ( TestStepTwo ) : <EOL> connections = { '<STR_LIT>' : '<STR_LIT>' } <EOL> with self . assertRaises ( TypeError ) : <EOL> InvalidStepA ( TestWorkflow ( self . request ) ) <EOL> with self . assertRaises ( TypeError ) : <EOL>"}
{"rec_id": "467", "recitation_code": "InvalidStepB ( TestWorkflow ( self . request ) )", "input_code_id": 61765, "input": "<s> from django import forms <EOL> from django import http <EOL> from horizon import exceptions <EOL> from horizon . test import helpers as test <EOL> from horizon import workflows <EOL> PROJECT_ID = \"<STR_LIT>\" <EOL> INSTANCE_ID = \"<STR_LIT>\" <EOL> def local_callback_func ( request , context ) : <EOL> return \"<STR_LIT>\" <EOL> def other_callback_func ( request , context ) : <EOL> return \"<STR_LIT>\" <EOL> def extra_callback_func ( request , context ) : <EOL> return \"<STR_LIT>\" <EOL> class TestActionOne ( workflows . Action ) : <EOL> project_id = forms . ChoiceField ( label = \"<STR_LIT>\" ) <EOL> user_id = forms . ChoiceField ( label = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> name = \"<STR_LIT>\" <EOL> slug = \"<STR_LIT>\" <EOL> def populate_project_id_choices ( self , request , context ) : <EOL> return [ ( PROJECT_ID , \"<STR_LIT>\" ) ] <EOL> def populate_user_id_choices ( self , request , context ) : <EOL> return [ ( request . user . id , request . user . username ) ] <EOL> def handle ( self , request , context ) : <EOL> return { \"<STR_LIT:foo>\" : \"<STR_LIT:bar>\" } <EOL> class TestActionTwo ( workflows . Action ) : <EOL> instance_id = forms . CharField ( label = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> name = \"<STR_LIT>\" <EOL> slug = \"<STR_LIT>\" <EOL> class TestActionThree ( workflows . Action ) : <EOL> extra = forms . CharField ( widget = forms . widgets . Textarea ) <EOL> class Meta : <EOL> name = \"<STR_LIT>\" <EOL> slug = \"<STR_LIT>\" <EOL> class AdminAction ( workflows . Action ) : <EOL> admin_id = forms . CharField ( label = \"<STR_LIT>\" ) <EOL> class Meta : <EOL> name = \"<STR_LIT>\" <EOL> slug = \"<STR_LIT>\" <EOL> permissions = ( \"<STR_LIT>\" , ) <EOL> class TestStepOne ( workflows . Step ) : <EOL> action_class = TestActionOne <EOL> contributes = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> class TestStepTwo ( workflows . Step ) : <EOL> action_class = TestActionTwo <EOL> depends_on = ( \"<STR_LIT>\" , ) <EOL> contributes = ( \"<STR_LIT>\" , ) <EOL> connections = { \"<STR_LIT>\" : <EOL> ( local_callback_func , <EOL> \"<STR_LIT>\" ) } <EOL> class TestExtraStep ( workflows . Step ) : <EOL> action_class = TestActionThree <EOL> depends_on = ( \"<STR_LIT>\" , ) <EOL> contributes = ( \"<STR_LIT>\" , ) <EOL> connections = { \"<STR_LIT>\" : ( extra_callback_func , ) } <EOL> after = TestStepOne <EOL> before = TestStepTwo <EOL> class AdminStep ( workflows . Step ) : <EOL> action_class = AdminAction <EOL> contributes = ( \"<STR_LIT>\" , ) <EOL> after = TestStepOne <EOL> before = TestStepTwo <EOL> class TestWorkflow ( workflows . Workflow ) : <EOL> slug = \"<STR_LIT>\" <EOL> default_steps = ( TestStepOne , TestStepTwo ) <EOL> class TestWorkflowView ( workflows . WorkflowView ) : <EOL> workflow_class = TestWorkflow <EOL> template_name = \"<STR_LIT>\" <EOL> class TestFullscreenWorkflow ( workflows . Workflow ) : <EOL> slug = '<STR_LIT>' <EOL> default_steps = ( TestStepOne , TestStepTwo ) <EOL> fullscreen = True <EOL> class TestFullscreenWorkflowView ( workflows . WorkflowView ) : <EOL> workflow_class = TestFullscreenWorkflow <EOL> template_name = \"<STR_LIT>\" <EOL> class WorkflowsTests ( test . TestCase ) : <EOL> def setUp ( self ) : <EOL> super ( WorkflowsTests , self ) . setUp ( ) <EOL> def tearDown ( self ) : <EOL> super ( WorkflowsTests , self ) . tearDown ( ) <EOL> self . _reset_workflow ( ) <EOL> def _reset_workflow ( self ) : <EOL> TestWorkflow . _cls_registry = set ( [ ] ) <EOL> def test_workflow_construction ( self ) : <EOL> TestWorkflow . register ( TestExtraStep ) <EOL> flow = TestWorkflow ( self . request ) <EOL> self . assertQuerysetEqual ( flow . steps , <EOL> [ '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ] ) <EOL> self . assertEqual ( set ( [ '<STR_LIT>' ] ) , flow . depends_on ) <EOL> def test_step_construction ( self ) : <EOL> step_one = TestStepOne ( TestWorkflow ( self . request ) ) <EOL> self . assertEqual ( TestActionOne . name , step_one . name ) <EOL> self . assertEqual ( TestActionOne . slug , step_one . slug ) <EOL> self . assertEqual ( step_one . _handlers , { } ) <EOL> step_two = TestStepTwo ( TestWorkflow ( self . request ) ) <EOL> self . assertEqual ( [ local_callback_func , other_callback_func ] , <EOL> step_two . _handlers [ \"<STR_LIT>\" ] ) <EOL> def test_step_invalid_connections_handlers_not_list_or_tuple ( self ) : <EOL> class InvalidStepA ( TestStepTwo ) : <EOL> connections = { '<STR_LIT>' : { } } <EOL> class InvalidStepB ( TestStepTwo ) : <EOL> connections = { '<STR_LIT>' : '<STR_LIT>' } <EOL> with self . assertRaises ( TypeError ) : <EOL> InvalidStepA ( TestWorkflow ( self . request ) ) <EOL> with self . assertRaises ( TypeError ) : <EOL>"}
{"rec_id": "499", "recitation_code": "def delete ( self , using = None ) :", "input_code_id": 499, "input": "<s> import types <EOL> import sys <EOL> from itertools import izip <EOL> import django . db . models . manager <EOL> from django . core . exceptions import ObjectDoesNotExist , MultipleObjectsReturned , FieldError , ValidationError , NON_FIELD_ERRORS <EOL> from django . core import validators <EOL> from django . db . models . fields import AutoField , FieldDoesNotExist <EOL> from django . db . models . fields . related import ( OneToOneRel , ManyToOneRel , <EOL> OneToOneField , add_lazy_relation ) <EOL> from django . db . models . query import Q <EOL> from django . db . models . query_utils import DeferredAttribute <EOL> from django . db . models . deletion import Collector <EOL> from django . db . models . options import Options <EOL> from django . db import ( connections , router , transaction , DatabaseError , <EOL> DEFAULT_DB_ALIAS ) <EOL> from django . db . models import signals <EOL> from django . db . models . loading import register_models , get_model <EOL> from django . utils . translation import ugettext_lazy as _ <EOL> import django . utils . copycompat as copy <EOL> from django . utils . functional import curry , update_wrapper <EOL> from django . utils . encoding import smart_str , force_unicode <EOL> from django . utils . text import get_text_list , capfirst <EOL> from django . conf import settings <EOL> class ModelBase ( type ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __new__ ( cls , name , bases , attrs ) : <EOL> super_new = super ( ModelBase , cls ) . __new__ <EOL> parents = [ b for b in bases if isinstance ( b , ModelBase ) ] <EOL> if not parents : <EOL> return super_new ( cls , name , bases , attrs ) <EOL> module = attrs . pop ( '<STR_LIT>' ) <EOL> new_class = super_new ( cls , name , bases , { '<STR_LIT>' : module } ) <EOL> attr_meta = attrs . pop ( '<STR_LIT:Meta>' , None ) <EOL> abstract = getattr ( attr_meta , '<STR_LIT>' , False ) <EOL> if not attr_meta : <EOL> meta = getattr ( new_class , '<STR_LIT:Meta>' , None ) <EOL> else : <EOL> meta = attr_meta <EOL> base_meta = getattr ( new_class , '<STR_LIT>' , None ) <EOL> if getattr ( meta , '<STR_LIT>' , None ) is None : <EOL> model_module = sys . modules [ new_class . __module__ ] <EOL> kwargs = { \"<STR_LIT>\" : model_module . __name__ . split ( '<STR_LIT:.>' ) [ - <NUM_LIT:2> ] } <EOL> else : <EOL> kwargs = { } <EOL> new_class . add_to_class ( '<STR_LIT>' , Options ( meta , ** kwargs ) ) <EOL> if not abstract : <EOL> new_class . add_to_class ( '<STR_LIT>' , subclass_exception ( '<STR_LIT>' , <EOL> tuple ( x . DoesNotExist <EOL> for x in parents if hasattr ( x , '<STR_LIT>' ) and not x . _meta . abstract ) <EOL> or ( ObjectDoesNotExist , ) , module ) ) <EOL> new_class . add_to_class ( '<STR_LIT>' , subclass_exception ( '<STR_LIT>' , <EOL> tuple ( x . MultipleObjectsReturned <EOL> for x in parents if hasattr ( x , '<STR_LIT>' ) and not x . _meta . abstract ) <EOL> or ( MultipleObjectsReturned , ) , module ) ) <EOL> if base_meta and not base_meta . abstract : <EOL> if not hasattr ( meta , '<STR_LIT>' ) : <EOL> new_class . _meta . ordering = base_meta . ordering <EOL> if not hasattr ( meta , '<STR_LIT>' ) : <EOL> new_class . _meta . get_latest_by = base_meta . get_latest_by <EOL> is_proxy = new_class . _meta . proxy <EOL> if getattr ( new_class , '<STR_LIT>' , None ) : <EOL> if not is_proxy : <EOL> new_class . _default_manager = None <EOL> new_class . _base_manager = None <EOL> else : <EOL> new_class . _default_manager = new_class . _default_manager . _copy_to_model ( new_class ) <EOL> new_class . _base_manager = new_class . _base_manager . _copy_to_model ( new_class ) <EOL> m = get_model ( new_class . _meta . app_label , name , False ) <EOL> if m is not None : <EOL> return m <EOL> for obj_name , obj in attrs . items ( ) : <EOL> new_class . add_to_class ( obj_name , obj ) <EOL> new_fields = new_class . _meta . local_fields + new_class . _meta . local_many_to_many + new_class . _meta . virtual_fields <EOL> field_names = set ( [ f . name for f in new_fields ] ) <EOL> if is_proxy : <EOL> base = None <EOL> for parent in [ cls for cls in parents if hasattr ( cls , '<STR_LIT>' ) ] : <EOL> if parent . _meta . abstract : <EOL> if parent . _meta . fields : <EOL> raise TypeError ( \"<STR_LIT>\" % name ) <EOL> else : <EOL> continue <EOL> if base is not None : <EOL> raise TypeError ( \"<STR_LIT>\" % name ) <EOL> else : <EOL> base = parent <EOL> if base is None : <EOL> raise TypeError ( \"<STR_LIT>\" % name ) <EOL> if ( new_class . _meta . local_fields or <EOL> new_class . _meta . local_many_to_many ) : <EOL> raise FieldError ( \"<STR_LIT>\" % name ) <EOL> while base . _meta . proxy : <EOL> base = base . _meta . proxy_for_model <EOL> new_class . _meta . setup_proxy ( base ) <EOL> o2o_map = dict ( [ ( f . rel . to , f ) for f in new_class . _meta . local_fields <EOL> if isinstance ( f , OneToOneField ) ] ) <EOL> for base in parents : <EOL> original_base = base <EOL> if not hasattr ( base , '<STR_LIT>' ) : <EOL> continue <EOL> parent_fields = base . _meta . local_fields + base . _meta . local_many_to_many <EOL> for field in parent_fields : <EOL> if field . name in field_names : <EOL> raise FieldError ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' % <EOL> ( field . name , name , base . __name__ ) ) <EOL> if not base . _meta . abstract : <EOL> while base . _meta . proxy : <EOL> base = base . _meta . proxy_for_model <EOL> if base in o2o_map : <EOL> field = o2o_map [ base ] <EOL> elif not is_proxy : <EOL> attr_name = '<STR_LIT>' % base . _meta . module_name <EOL> field = OneToOneField ( base , name = attr_name , <EOL> auto_created = True , parent_link = True ) <EOL> new_class . add_to_class ( attr_name , field ) <EOL> else : <EOL> field = None <EOL> new_class . _meta . parents [ base ] = field <EOL> else : <EOL> for field in parent_fields : <EOL> new_class . add_to_class ( field . name , copy . deepcopy ( field ) ) <EOL> new_class . _meta . parents . update ( base . _meta . parents ) <EOL> new_class . copy_managers ( base . _meta . abstract_managers ) <EOL> if is_proxy : <EOL> new_class . copy_managers ( original_base . _meta . concrete_managers ) <EOL> for field in base . _meta . virtual_fields : <EOL> if base . _meta . abstract and field . name in field_names : <EOL> raise FieldError ( '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' % ( field . name , name , base . __name__ ) ) <EOL> new_class . add_to_class ( field . name , copy . deepcopy ( field ) ) <EOL> if abstract : <EOL> attr_meta . abstract = False <EOL> new_class . Meta = attr_meta <EOL> return new_class <EOL> new_class . _prepare ( ) <EOL> register_models ( new_class . _meta . app_label , new_class ) <EOL> return get_model ( new_class . _meta . app_label , name , False ) <EOL> def copy_managers ( cls , base_managers ) : <EOL> base_managers . sort ( ) <EOL> for _ , mgr_name , manager in base_managers : <EOL> val = getattr ( cls , mgr_name , None ) <EOL> if not val or val is manager : <EOL> new_manager = manager . _copy_to_model ( cls ) <EOL> cls . add_to_class ( mgr_name , new_manager ) <EOL> def add_to_class ( cls , name , value ) : <EOL> if hasattr ( value , '<STR_LIT>' ) : <EOL> value . contribute_to_class ( cls , name ) <EOL> else : <EOL> setattr ( cls , name , value ) <EOL> def _prepare ( cls ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> opts = cls . _meta <EOL> opts . _prepare ( cls ) <EOL> if opts . order_with_respect_to : <EOL> cls . get_next_in_order = curry ( cls . _get_next_or_previous_in_order , is_next = True ) <EOL> cls . get_previous_in_order = curry ( cls . _get_next_or_previous_in_order , is_next = False ) <EOL> def make_foreign_order_accessors ( field , model , cls ) : <EOL> setattr ( <EOL> field . rel . to , <EOL> '<STR_LIT>' % cls . __name__ . lower ( ) , <EOL> curry ( method_get_order , cls ) <EOL> ) <EOL> setattr ( <EOL> field . rel . to , <EOL> '<STR_LIT>' % cls . __name__ . lower ( ) , <EOL> curry ( method_set_order , cls ) <EOL> ) <EOL> add_lazy_relation ( <EOL> cls , <EOL> opts . order_with_respect_to , <EOL> opts . order_with_respect_to . rel . to , <EOL> make_foreign_order_accessors <EOL> ) <EOL> if cls . __doc__ is None : <EOL> cls . __doc__ = \"<STR_LIT>\" % ( cls . __name__ , \"<STR_LIT:U+002CU+0020>\" . join ( [ f . attname for f in opts . fields ] ) ) <EOL> if hasattr ( cls , '<STR_LIT>' ) : <EOL> cls . get_absolute_url = update_wrapper ( curry ( get_absolute_url , opts , cls . get_absolute_url ) , <EOL> cls . get_absolute_url ) <EOL> signals . class_prepared . send ( sender = cls ) <EOL> class ModelState ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , db = None ) : <EOL> self . db = db <EOL> self . adding = True <EOL> class Model ( object ) : <EOL> __metaclass__ = ModelBase <EOL> _deferred = False <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> signals . pre_init . send ( sender = self . __class__ , args = args , kwargs = kwargs ) <EOL> self . _state = ModelState ( ) <EOL> args_len = len ( args ) <EOL> if args_len > len ( self . _meta . fields ) : <EOL> raise IndexError ( \"<STR_LIT>\" ) <EOL> fields_iter = iter ( self . _meta . fields ) <EOL> if not kwargs : <EOL> for val , field in izip ( args , fields_iter ) : <EOL> setattr ( self , field . attname , val ) <EOL> else : <EOL> for val , field in izip ( args , fields_iter ) : <EOL> setattr ( self , field . attname , val ) <EOL> kwargs . pop ( field . name , None ) <EOL> if isinstance ( field . rel , ManyToOneRel ) : <EOL> kwargs . pop ( field . attname , None ) <EOL> for field in fields_iter : <EOL> is_related_object = False <EOL> if ( field . attname not in kwargs and <EOL> isinstance ( self . __class__ . __dict__ . get ( field . attname ) , DeferredAttribute ) ) : <EOL> continue <EOL> if kwargs : <EOL> if isinstance ( field . rel , ManyToOneRel ) : <EOL> try : <EOL> rel_obj = kwargs . pop ( field . name ) <EOL> is_related_object = True <EOL> except KeyError : <EOL> try : <EOL> val = kwargs . pop ( field . attname ) <EOL> except KeyError : <EOL> val = field . get_default ( ) <EOL> else : <EOL> if rel_obj is None and field . null : <EOL> val = None <EOL> else : <EOL> try : <EOL> val = kwargs . pop ( field . attname ) <EOL> except KeyError : <EOL> val = field . get_default ( ) <EOL> else : <EOL> val = field . get_default ( ) <EOL> if is_related_object : <EOL> setattr ( self , field . name , rel_obj ) <EOL> else : <EOL> setattr ( self , field . attname , val ) <EOL> if kwargs : <EOL> for prop in kwargs . keys ( ) : <EOL> try : <EOL> if isinstance ( getattr ( self . __class__ , prop ) , property ) : <EOL> setattr ( self , prop , kwargs . pop ( prop ) ) <EOL> except AttributeError : <EOL> pass <EOL> if kwargs : <EOL> raise TypeError ( \"<STR_LIT>\" % kwargs . keys ( ) [ <NUM_LIT:0> ] ) <EOL> super ( Model , self ) . __init__ ( ) <EOL> signals . post_init . send ( sender = self . __class__ , instance = self ) <EOL> def __repr__ ( self ) : <EOL> try : <EOL> u = unicode ( self ) <EOL> except ( UnicodeEncodeError , UnicodeDecodeError ) : <EOL> u = '<STR_LIT>' <EOL> return smart_str ( u'<STR_LIT>' % ( self . __class__ . __name__ , u ) ) <EOL> def __str__ ( self ) : <EOL> if hasattr ( self , '<STR_LIT>' ) : <EOL> return force_unicode ( self ) . encode ( '<STR_LIT:utf-8>' ) <EOL> return '<STR_LIT>' % self . __class__ . __name__ <EOL> def __eq__ ( self , other ) : <EOL> return isinstance ( other , self . __class__ ) and self . _get_pk_val ( ) == other . _get_pk_val ( ) <EOL> def __ne__ ( self , other ) : <EOL> return not self . __eq__ ( other ) <EOL> def __hash__ ( self ) : <EOL> return hash ( self . _get_pk_val ( ) ) <EOL> def __reduce__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> data = self . __dict__ <EOL> model = self . __class__ <EOL> defers = [ ] <EOL> pk_val = None <EOL> if self . _deferred : <EOL> from django . db . models . query_utils import deferred_class_factory <EOL> factory = deferred_class_factory <EOL> for field in self . _meta . fields : <EOL> if isinstance ( self . __class__ . __dict__ . get ( field . attname ) , <EOL> DeferredAttribute ) : <EOL> defers . append ( field . attname ) <EOL> if pk_val is None : <EOL> obj = self . __class__ . __dict__ [ field . attname ] <EOL> model = obj . model_ref ( ) <EOL> else : <EOL> factory = simple_class_factory <EOL> return ( model_unpickle , ( model , defers , factory ) , data ) <EOL> def _get_pk_val ( self , meta = None ) : <EOL> if not meta : <EOL> meta = self . _meta <EOL> return getattr ( self , meta . pk . attname ) <EOL> def _set_pk_val ( self , value ) : <EOL> return setattr ( self , self . _meta . pk . attname , value ) <EOL> pk = property ( _get_pk_val , _set_pk_val ) <EOL> def serializable_value ( self , field_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> field = self . _meta . get_field_by_name ( field_name ) [ <NUM_LIT:0> ] <EOL> except FieldDoesNotExist : <EOL> return getattr ( self , field_name ) <EOL> return getattr ( self , field . attname ) <EOL> def save ( self , force_insert = False , force_update = False , using = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if force_insert and force_update : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> self . save_base ( using = using , force_insert = force_insert , force_update = force_update ) <EOL> save . alters_data = True <EOL>"}
{"rec_id": "499", "recitation_code": "def delete ( self , using = None ) :", "input_code_id": 5007, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import <EOL> from django . db import IntegrityError , router , transaction <EOL> from django . db . models . expressions import ExpressionNode <EOL> from django . db . models . signals import post_save <EOL> from . utils import resolve_expression_node <EOL> __all__ = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def update ( self , using = None , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> assert self . pk , \"<STR_LIT>\" <EOL> using = using or router . db_for_write ( self . __class__ , instance = self ) <EOL> for field in self . _meta . fields : <EOL> if getattr ( field , '<STR_LIT>' , False ) and field . name not in kwargs : <EOL> kwargs [ field . name ] = field . pre_save ( self , False ) <EOL> affected = self . __class__ . _base_manager . using ( using ) . filter ( pk = self . pk ) . update ( ** kwargs ) <EOL> for k , v in kwargs . iteritems ( ) : <EOL> if isinstance ( v , ExpressionNode ) : <EOL> v = resolve_expression_node ( self , v ) <EOL> setattr ( self , k , v ) <EOL> if affected == <NUM_LIT:1> : <EOL> post_save . send ( sender = self . __class__ , instance = self , created = False ) <EOL> return affected <EOL> elif affected == <NUM_LIT:0> : <EOL> return affected <EOL> elif affected < <NUM_LIT:0> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL>"}
{"rec_id": "538", "recitation_code": "self . user . is staff = True", "input_code_id": 538, "input": "<s> from __future__ import absolute_import <EOL> import json <EOL> from contextlib import contextmanager <EOL> from django . test import TestCase <EOL> from django . contrib . auth . models import User , Permission <EOL> from django . contrib . contenttypes . models import ContentType <EOL> from . . models import Layout , RawTextWidget , Bucket <EOL> from . . widgy_config import widgy_site <EOL> class RootNodeTestCase ( TestCase ) : <EOL> def setUp ( self ) : <EOL> super ( RootNodeTestCase , self ) . setUp ( ) <EOL> self . root_node = Layout . add_root ( widgy_site ) . node <EOL> class HttpTestCase ( TestCase ) : <EOL> def setUp ( self ) : <EOL> super ( HttpTestCase , self ) . setUp ( ) <EOL> u = User . objects . create_superuser ( <EOL> username = '<STR_LIT>' , <EOL> email = '<STR_LIT>' , <EOL> password = '<STR_LIT>' , <EOL> ) <EOL> u . save ( ) <EOL> self . client . login ( username = u . username , password = '<STR_LIT>' ) <EOL> self . user = u <EOL> def json_request ( self , method , url , data = None , * args , ** kwargs ) : <EOL> method = getattr ( self . client , method ) <EOL> if method == self . client . get : <EOL> encode = lambda x : x <EOL> else : <EOL> encode = json . dumps <EOL> if data : <EOL> resp = method ( url , encode ( data ) , content_type = '<STR_LIT:application/json>' , * args , ** kwargs ) <EOL> else : <EOL> resp = method ( url , content_type = '<STR_LIT:application/json>' , * args , ** kwargs ) <EOL> self . assertEqual ( resp [ '<STR_LIT:Content-Type>' ] , '<STR_LIT:application/json>' ) <EOL> return resp <EOL> def __getattr__ ( self , attr ) : <EOL> if attr in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> return lambda * args , ** kwargs : self . json_request ( attr , * args , ** kwargs ) <EOL> else : <EOL> return getattr ( super ( HttpTestCase , self ) , attr ) <EOL> class SwitchUserTestCase ( TestCase ) : <EOL> username = '<STR_LIT:username>' <EOL> password = '<STR_LIT:password>' <EOL> def setUp ( self ) : <EOL> super ( SwitchUserTestCase , self ) . setUp ( ) <EOL> self . user = user = User . objects . create_user ( <EOL> username = self . username , <EOL> password = self . password , <EOL> ) <EOL> user . save ( ) <EOL> self . client . logout ( ) <EOL> @ contextmanager <EOL> def as_superuser ( self ) : <EOL> self . user . is_superuser = True <EOL> self . user . save ( ) <EOL> with self . as_staffuser ( ) as user : <EOL> yield user <EOL> self . user . is_superuser = False <EOL> self . user . save ( ) <EOL> @ contextmanager <EOL> def as_staffuser ( self ) : <EOL>"}
{"rec_id": "538", "recitation_code": "self . user . is staff = True", "input_code_id": 8258, "input": "<s> from django . core . urlresolvers import reverse <EOL> from raspberryio . project . tests . base import RaspberryIOBaseTestCase <EOL> class UserProfileFormTestCase ( RaspberryIOBaseTestCase ) : <EOL> url_name = \"<STR_LIT>\" <EOL> def setUp ( self ) : <EOL> self . user = self . create_user ( data = { '<STR_LIT:username>' : '<STR_LIT:test>' , '<STR_LIT:password>' : '<STR_LIT>' } ) <EOL>"}
{"rec_id": "611", "recitation_code": "rule elem . set ( ' ' , rule . get ( ' ' ) )", "input_code_id": 611, "input": "<s> from vt_manager . communication . sfa . rspecs . elements . element import Element <EOL> from vt_manager . communication . sfa . rspecs . elements . fw_rule import FWRule <EOL> class PLOSv1FWRule : <EOL> @ staticmethod <EOL> def add_rules ( xml , rules ) : <EOL> if not rules : <EOL> return <EOL> for rule in rules : <EOL> rule_elem = xml . add_element ( '<STR_LIT>' % xml . namespaces [ '<STR_LIT>' ] ) <EOL> rule_elem . set ( '<STR_LIT>' , rule . get ( '<STR_LIT>' ) ) <EOL> rule_elem . set ( '<STR_LIT>' , rule . get ( '<STR_LIT>' ) ) <EOL>"}
{"rec_id": "611", "recitation_code": "rule elem . set ( ' ' , rule . get ( ' ' ) )", "input_code_id": 45822, "input": "<s> from openflow . optin_manager . sfa . rspecs . elements . element import Element <EOL> from openflow . optin_manager . sfa . rspecs . elements . fw_rule import FWRule <EOL> class PLOSv1FWRule : <EOL> @ staticmethod <EOL> def add_rules ( xml , rules ) : <EOL> if not rules : <EOL> return <EOL> for rule in rules : <EOL> rule_elem = xml . add_element ( '<STR_LIT>' % xml . namespaces [ '<STR_LIT>' ] ) <EOL> rule_elem . set ( '<STR_LIT>' , rule . get ( '<STR_LIT>' ) ) <EOL> rule_elem . set ( '<STR_LIT>' , rule . get ( '<STR_LIT>' ) ) <EOL>"}
{"rec_id": "614", "recitation_code": "node addon . save ( )", "input_code_id": 614, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> import logging <EOL> from modularodm import Q <EOL> from website . app import init_app <EOL> from scripts import utils as script_utils <EOL> from framework . transactions . context import TokuTransaction <EOL> from website . addons . dataverse . model import AddonDataverseNodeSettings <EOL> logger = logging . getLogger ( __name__ ) <EOL> def do_migration ( records , dry = True ) : <EOL> for node_addon in records : <EOL> with TokuTransaction ( ) : <EOL> logger . info ( '<STR_LIT>' . format ( node_addon . study_hdl ) ) <EOL> logger . info ( '<STR_LIT>' . format ( node_addon . study_hdl ) ) <EOL> if not dry : <EOL> node_addon . dataset_doi = node_addon . study_hdl <EOL>"}
{"rec_id": "614", "recitation_code": "node addon . save ( )", "input_code_id": 31281, "input": "<s> from nose . tools import * <EOL> from scripts . box . connect_external_accounts import do_migration <EOL> from framework . auth import Auth <EOL> from tests . base import OsfTestCase <EOL> from tests . factories import ProjectFactory , UserFactory <EOL> from website . addons . box . model import BoxUserSettings <EOL> from website . addons . box . tests . factories import BoxAccountFactory <EOL> class TestBoxPostMergeMigration ( OsfTestCase ) : <EOL> def test_migration ( self ) : <EOL> BoxUserSettings . remove ( ) <EOL> user = UserFactory ( ) <EOL> node = ProjectFactory ( creator = user ) <EOL> account = BoxAccountFactory ( ) <EOL> user . external_accounts = [ account ] <EOL> user . add_addon ( '<STR_LIT>' , auth = Auth ( user ) ) <EOL> user_addon = user . get_addon ( '<STR_LIT>' ) <EOL> user_addon . save ( ) <EOL> node . add_addon ( '<STR_LIT>' , auth = Auth ( user ) ) <EOL> node_addon = node . get_addon ( '<STR_LIT>' ) <EOL> node_addon . foreign_user_settings = user_addon <EOL> node_addon . folder_id = '<STR_LIT>' <EOL> node_addon . folder_path = '<STR_LIT:/>' <EOL>"}
{"rec_id": "667", "recitation_code": "ver tuple = ( 1 , 4 , 0 , ' ' , 0 )", "input_code_id": 667, "input": "<s> import re <EOL> from django import get_version <EOL> from django . utils . unittest import TestCase <EOL> class VersionTests ( TestCase ) : <EOL> def test_development ( self ) : <EOL> ver_tuple = ( <NUM_LIT:1> , <NUM_LIT:4> , <NUM_LIT:0> , '<STR_LIT>' , <NUM_LIT:0> ) <EOL> ver_string = get_version ( ver_tuple ) <EOL> self . assertRegexpMatches ( ver_string , r'<STR_LIT>' ) <EOL> def test_releases ( self ) : <EOL>"}
{"rec_id": "667", "recitation_code": "ver tuple = ( 1 , 4 , 0 , ' ' , 0 )", "input_code_id": 23978, "input": "<s> import re <EOL> from django import get_version <EOL> from django . utils import six <EOL> from django . utils . unittest import TestCase <EOL> class VersionTests ( TestCase ) : <EOL> def test_development ( self ) : <EOL> ver_tuple = ( <NUM_LIT:1> , <NUM_LIT:4> , <NUM_LIT:0> , '<STR_LIT>' , <NUM_LIT:0> ) <EOL> ver_string = get_version ( ver_tuple ) <EOL> six . assertRegex ( self , ver_string , r'<STR_LIT>' ) <EOL> def test_releases ( self ) : <EOL>"}
{"rec_id": "667", "recitation_code": "ver tuple = ( 1 , 4 , 0 , ' ' , 0 )", "input_code_id": 34990, "input": "<s> from unittest import TestCase <EOL> from django import get_version <EOL> from django . utils import six <EOL> class VersionTests ( TestCase ) : <EOL> def test_development ( self ) : <EOL> ver_tuple = ( <NUM_LIT:1> , <NUM_LIT:4> , <NUM_LIT:0> , '<STR_LIT>' , <NUM_LIT:0> ) <EOL> ver_string = get_version ( ver_tuple ) <EOL> six . assertRegex ( self , ver_string , r'<STR_LIT>' ) <EOL> def test_releases ( self ) : <EOL>"}
{"rec_id": "669", "recitation_code": "class Team ( models . Model ) :", "input_code_id": 669, "input": "<s> from django . contrib . contenttypes import generic <EOL> from django . contrib . contenttypes . models import ContentType <EOL> from django . db import models <EOL> from django . utils . encoding import python_2_unicode_compatible <EOL> from django . db . models . deletion import ProtectedError <EOL> __all__ = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> @ python_2_unicode_compatible <EOL> class Link ( models . Model ) : <EOL> content_type = models . ForeignKey ( ContentType ) <EOL> object_id = models . PositiveIntegerField ( ) <EOL> content_object = generic . GenericForeignKey ( ) <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" % ( self . content_type , self . object_id ) <EOL> @ python_2_unicode_compatible <EOL> class Place ( models . Model ) : <EOL> name = models . CharField ( max_length = <NUM_LIT:100> ) <EOL> links = generic . GenericRelation ( Link ) <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" % self . name <EOL> @ python_2_unicode_compatible <EOL> class Restaurant ( Place ) : <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" % self . name <EOL> @ python_2_unicode_compatible <EOL> class Address ( models . Model ) : <EOL> street = models . CharField ( max_length = <NUM_LIT> ) <EOL> city = models . CharField ( max_length = <NUM_LIT:50> ) <EOL> state = models . CharField ( max_length = <NUM_LIT:2> ) <EOL> zipcode = models . CharField ( max_length = <NUM_LIT:5> ) <EOL> content_type = models . ForeignKey ( ContentType ) <EOL> object_id = models . PositiveIntegerField ( ) <EOL> content_object = generic . GenericForeignKey ( ) <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % ( self . street , self . city , self . state , self . zipcode ) <EOL> @ python_2_unicode_compatible <EOL> class Person ( models . Model ) : <EOL> account = models . IntegerField ( primary_key = True ) <EOL> name = models . CharField ( max_length = <NUM_LIT> ) <EOL> addresses = generic . GenericRelation ( Address ) <EOL> def __str__ ( self ) : <EOL> return self . name <EOL> class CharLink ( models . Model ) : <EOL> content_type = models . ForeignKey ( ContentType ) <EOL> object_id = models . CharField ( max_length = <NUM_LIT:100> ) <EOL> content_object = generic . GenericForeignKey ( ) <EOL> class TextLink ( models . Model ) : <EOL> content_type = models . ForeignKey ( ContentType ) <EOL> object_id = models . TextField ( ) <EOL> content_object = generic . GenericForeignKey ( ) <EOL> class OddRelation1 ( models . Model ) : <EOL> name = models . CharField ( max_length = <NUM_LIT:100> ) <EOL> clinks = generic . GenericRelation ( CharLink ) <EOL> class OddRelation2 ( models . Model ) : <EOL> name = models . CharField ( max_length = <NUM_LIT:100> ) <EOL> tlinks = generic . GenericRelation ( TextLink ) <EOL> class Note ( models . Model ) : <EOL> content_type = models . ForeignKey ( ContentType ) <EOL> object_id = models . PositiveIntegerField ( ) <EOL> content_object = generic . GenericForeignKey ( ) <EOL> note = models . TextField ( ) <EOL> class Contact ( models . Model ) : <EOL> notes = generic . GenericRelation ( Note ) <EOL> class Organization ( models . Model ) : <EOL> name = models . CharField ( max_length = <NUM_LIT:255> ) <EOL> contacts = models . ManyToManyField ( Contact , related_name = '<STR_LIT>' ) <EOL> @ python_2_unicode_compatible <EOL>"}
{"rec_id": "669", "recitation_code": "class Team ( models . Model ) :", "input_code_id": 46982, "input": "<s> from __future__ import division <EOL> import operator <EOL> from django . db import models <EOL> from django . db . models import Avg <EOL> class Season ( models . Model ) : <EOL> name = models . CharField ( max_length = <NUM_LIT> ) <EOL> start_date = models . DateField ( '<STR_LIT>' ) <EOL> end_date = models . DateField ( '<STR_LIT>' ) <EOL> season_round = models . IntegerField ( ) <EOL> class Meta : <EOL> ordering = [ '<STR_LIT>' , ] <EOL> def __str__ ( self ) : <EOL> return unicode ( self . start_date . year ) + '<STR_LIT>' + unicode ( self . season_round ) <EOL> def get_stats ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> player_count = <NUM_LIT:0> <EOL> results_count = <NUM_LIT:0> <EOL> total_games_count = <NUM_LIT:0.0> <EOL> for ladder in self . ladder_set . all ( ) : <EOL> player_count += ladder . league_set . count ( ) <EOL> results_count += ladder . result_set . count ( ) / <NUM_LIT:2> <EOL> total_games_count += ( ladder . league_set . count ( ) * ( ladder . league_set . count ( ) - <NUM_LIT:1> ) ) / <NUM_LIT:2> <EOL> percentage_played = ( results_count / total_games_count ) * <NUM_LIT:100> <EOL> return { <EOL> '<STR_LIT>' : self . ladder_set . count ( ) , <EOL> '<STR_LIT>' : \"<STR_LIT>\" . format ( percentage_played ) , <EOL> '<STR_LIT>' : total_games_count , <EOL> '<STR_LIT>' : results_count , <EOL> '<STR_LIT>' : player_count <EOL> } <EOL> def get_leader_stats ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> current_leaders = { } <EOL> for ladder in self . ladder_set . all ( ) : <EOL> current_leaders [ ladder . id ] = ladder . get_leader ( ) <EOL> return { <EOL> '<STR_LIT>' : current_leaders , <EOL> } <EOL> def get_progress ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> results = Result . objects . raw ( \"\"\"<STR_LIT>\"\"\" , [ self . id ] ) <EOL> leagues = League . objects . raw ( \"\"\"<STR_LIT>\"\"\" , [ self . id ] ) <EOL> played = [ ] <EOL> played_days = [ ] <EOL> played_cumulative = [ ] <EOL> played_cumulative_count = <NUM_LIT:0> <EOL> latest_result = False <EOL> for result in results : <EOL> played . append ( result . added_count ) <EOL> played_days . append ( ( result . date_added - self . start_date ) . days ) <EOL> played_cumulative_count += result . added_count / <NUM_LIT:2> <EOL> played_cumulative . append ( played_cumulative_count ) <EOL> latest_result = result . date_added <EOL> total_matches = <NUM_LIT:0> <EOL> for league in leagues : <EOL> total_matches += ( league . player_count - <NUM_LIT:1> ) * league . player_count / <NUM_LIT:2> <EOL> return { <EOL> \"<STR_LIT>\" : [ <NUM_LIT:0> , ( self . end_date - self . start_date ) . days ] , <EOL> \"<STR_LIT>\" : [ <NUM_LIT:0> , total_matches ] , <EOL> \"<STR_LIT>\" : played_days , <EOL> \"<STR_LIT>\" : played , <EOL> \"<STR_LIT>\" : played_cumulative , <EOL> \"<STR_LIT>\" : latest_result . strftime ( \"<STR_LIT>\" ) if latest_result else \"<STR_LIT:->\" <EOL> } <EOL> class Player ( models . Model ) : <EOL> first_name = models . CharField ( max_length = <NUM_LIT:100> ) <EOL> last_name = models . CharField ( max_length = <NUM_LIT:100> ) <EOL> def __str__ ( self ) : <EOL> string = self . first_name <EOL> if self . last_name : <EOL> last_names = self . last_name . split ( ) <EOL> last_names [ - <NUM_LIT:1> ] = last_names [ - <NUM_LIT:1> ] [ : <NUM_LIT:1> ] . capitalize ( ) + '<STR_LIT:.>' <EOL> string += '<STR_LIT:U+0020>' + '<STR_LIT:U+0020>' . join ( last_names ) <EOL> return string <EOL> def player_stats ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> played = self . result_player . count ( ) <EOL> won = float ( self . result_player . filter ( result = <NUM_LIT:9> ) . count ( ) ) <EOL> lost = played - won <EOL> if played != <NUM_LIT:0> : <EOL> win_rate = won / float ( played ) * <NUM_LIT> <EOL> additional_points = ( ( won * <NUM_LIT:2> ) + played ) / played <EOL> else : <EOL> return { <EOL> '<STR_LIT>' : \"<STR_LIT:->\" , <EOL> '<STR_LIT>' : \"<STR_LIT>\" , <EOL> '<STR_LIT>' : \"<STR_LIT:->\" <EOL> } <EOL> average = list ( self . result_player . aggregate ( Avg ( '<STR_LIT:result>' ) ) . values ( ) ) [ <NUM_LIT:0> ] <EOL> average_with_additional = average + additional_points <EOL> leagues = self . league_set . filter ( player = self ) <EOL> match_count = <NUM_LIT:0> <EOL> for league in leagues : <EOL> match_count += league . ladder . league_set . count ( ) - <NUM_LIT:1> <EOL> completion_rate = float ( played ) / float ( match_count ) * <NUM_LIT> <EOL> return { <EOL> '<STR_LIT>' : played , <EOL> '<STR_LIT>' : \"<STR_LIT>\" . format ( win_rate ) , <EOL> '<STR_LIT>' : \"<STR_LIT>\" . format ( completion_rate ) , <EOL> '<STR_LIT>' : \"<STR_LIT>\" . format ( average_with_additional ) <EOL> } <EOL>"}
{"rec_id": "712", "recitation_code": "super ( ColorAttr , self ) . serialize ( write , attrs )", "input_code_id": 712, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from twisted . conch . insults import helper , insults <EOL> class _Attribute ( object ) : <EOL> def __init__ ( self ) : <EOL> self . children = [ ] <EOL> def __getitem__ ( self , item ) : <EOL> assert isinstance ( item , ( list , tuple , _Attribute , str ) ) <EOL> if isinstance ( item , ( list , tuple ) ) : <EOL> self . children . extend ( item ) <EOL> else : <EOL> self . children . append ( item ) <EOL> return self <EOL> def serialize ( self , write , attrs = None ) : <EOL> if attrs is None : <EOL> attrs = helper . CharacterAttribute ( ) <EOL> for ch in self . children : <EOL> if isinstance ( ch , _Attribute ) : <EOL> ch . serialize ( write , attrs . copy ( ) ) <EOL> else : <EOL> write ( attrs . toVT102 ( ) ) <EOL> write ( ch ) <EOL> class _NormalAttr ( _Attribute ) : <EOL> def serialize ( self , write , attrs ) : <EOL> attrs . __init__ ( ) <EOL> super ( _NormalAttr , self ) . serialize ( write , attrs ) <EOL> class _OtherAttr ( _Attribute ) : <EOL> def __init__ ( self , attrname , attrvalue ) : <EOL> self . attrname = attrname <EOL> self . attrvalue = attrvalue <EOL> self . children = [ ] <EOL> def __neg__ ( self ) : <EOL> result = _OtherAttr ( self . attrname , not self . attrvalue ) <EOL> result . children . extend ( self . children ) <EOL> return result <EOL> def serialize ( self , write , attrs ) : <EOL> attrs = attrs . wantOne ( ** { self . attrname : self . attrvalue } ) <EOL> super ( _OtherAttr , self ) . serialize ( write , attrs ) <EOL> class _ColorAttr ( _Attribute ) : <EOL> def __init__ ( self , color , ground ) : <EOL> self . color = color <EOL> self . ground = ground <EOL> self . children = [ ] <EOL> def serialize ( self , write , attrs ) : <EOL> attrs = attrs . wantOne ( ** { self . ground : self . color } ) <EOL>"}
{"rec_id": "712", "recitation_code": "super ( ColorAttr , self ) . serialize ( write , attrs )", "input_code_id": 68414, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from twisted . conch . insults import helper , insults <EOL> class _Attribute ( object ) : <EOL> def __init__ ( self ) : <EOL> self . children = [ ] <EOL> def __getitem__ ( self , item ) : <EOL> assert isinstance ( item , ( list , tuple , _Attribute , str ) ) <EOL> if isinstance ( item , ( list , tuple ) ) : <EOL> self . children . extend ( item ) <EOL> else : <EOL> self . children . append ( item ) <EOL> return self <EOL> def serialize ( self , write , attrs = None ) : <EOL> if attrs is None : <EOL> attrs = helper . CharacterAttribute ( ) <EOL> for ch in self . children : <EOL> if isinstance ( ch , _Attribute ) : <EOL> ch . serialize ( write , attrs . copy ( ) ) <EOL> else : <EOL> write ( attrs . toVT102 ( ) ) <EOL> write ( ch ) <EOL> class _NormalAttr ( _Attribute ) : <EOL> def serialize ( self , write , attrs ) : <EOL> attrs . __init__ ( ) <EOL> super ( _NormalAttr , self ) . serialize ( write , attrs ) <EOL> class _OtherAttr ( _Attribute ) : <EOL> def __init__ ( self , attrname , attrvalue ) : <EOL> self . attrname = attrname <EOL> self . attrvalue = attrvalue <EOL> self . children = [ ] <EOL> def __neg__ ( self ) : <EOL> result = _OtherAttr ( self . attrname , not self . attrvalue ) <EOL> result . children . extend ( self . children ) <EOL> return result <EOL> def serialize ( self , write , attrs ) : <EOL> attrs = attrs . wantOne ( ** { self . attrname : self . attrvalue } ) <EOL> super ( _OtherAttr , self ) . serialize ( write , attrs ) <EOL> class _ColorAttr ( _Attribute ) : <EOL> def __init__ ( self , color , ground ) : <EOL> self . color = color <EOL> self . ground = ground <EOL> self . children = [ ] <EOL> def serialize ( self , write , attrs ) : <EOL> attrs = attrs . wantOne ( ** { self . ground : self . color } ) <EOL>"}
{"rec_id": "763", "recitation_code": "def Deserializer ( stream or string , * * options ) :", "input_code_id": 763, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import unicode_literals <EOL> from django . conf import settings <EOL> from django . core . serializers import base <EOL> from django . db import models , DEFAULT_DB_ALIAS <EOL> from django . utils . encoding import smart_text , is_protected_type <EOL> from django . utils import six <EOL> class Serializer ( base . Serializer ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> internal_use_only = True <EOL> def start_serialization ( self ) : <EOL> self . _current = None <EOL> self . objects = [ ] <EOL> def end_serialization ( self ) : <EOL> pass <EOL> def start_object ( self , obj ) : <EOL> self . _current = { } <EOL> def end_object ( self , obj ) : <EOL> self . objects . append ( self . get_dump_object ( obj ) ) <EOL> self . _current = None <EOL> def get_dump_object ( self , obj ) : <EOL> return { <EOL> \"<STR_LIT>\" : smart_text ( obj . _get_pk_val ( ) , strings_only = True ) , <EOL> \"<STR_LIT>\" : smart_text ( obj . _meta ) , <EOL> \"<STR_LIT>\" : self . _current <EOL> } <EOL> def handle_field ( self , obj , field ) : <EOL> value = field . _get_val_from_obj ( obj ) <EOL> if is_protected_type ( value ) : <EOL> self . _current [ field . name ] = value <EOL> else : <EOL> self . _current [ field . name ] = field . value_to_string ( obj ) <EOL> def handle_fk_field ( self , obj , field ) : <EOL> if self . use_natural_keys and hasattr ( field . rel . to , '<STR_LIT>' ) : <EOL> related = getattr ( obj , field . name ) <EOL> if related : <EOL> value = related . natural_key ( ) <EOL> else : <EOL> value = None <EOL> else : <EOL> value = getattr ( obj , field . get_attname ( ) ) <EOL> self . _current [ field . name ] = value <EOL> def handle_m2m_field ( self , obj , field ) : <EOL> if field . rel . through . _meta . auto_created : <EOL> if self . use_natural_keys and hasattr ( field . rel . to , '<STR_LIT>' ) : <EOL> m2m_value = lambda value : value . natural_key ( ) <EOL> else : <EOL> m2m_value = lambda value : smart_text ( value . _get_pk_val ( ) , strings_only = True ) <EOL> self . _current [ field . name ] = [ m2m_value ( related ) <EOL> for related in getattr ( obj , field . name ) . iterator ( ) ] <EOL> def getvalue ( self ) : <EOL> return self . objects <EOL>"}
{"rec_id": "763", "recitation_code": "def Deserializer ( stream or string , * * options ) :", "input_code_id": 10348, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from google . appengine . _internal . django . conf import settings <EOL> from google . appengine . _internal . django . core . serializers import base <EOL> from google . appengine . _internal . django . db import models , DEFAULT_DB_ALIAS <EOL> from google . appengine . _internal . django . utils . encoding import smart_unicode , is_protected_type <EOL> class Serializer ( base . Serializer ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> internal_use_only = True <EOL> def start_serialization ( self ) : <EOL> self . _current = None <EOL> self . objects = [ ] <EOL> def end_serialization ( self ) : <EOL> pass <EOL> def start_object ( self , obj ) : <EOL> self . _current = { } <EOL> def end_object ( self , obj ) : <EOL> self . objects . append ( { <EOL> \"<STR_LIT>\" : smart_unicode ( obj . _meta ) , <EOL> \"<STR_LIT>\" : smart_unicode ( obj . _get_pk_val ( ) , strings_only = True ) , <EOL> \"<STR_LIT>\" : self . _current <EOL> } ) <EOL> self . _current = None <EOL> def handle_field ( self , obj , field ) : <EOL> value = field . _get_val_from_obj ( obj ) <EOL> if is_protected_type ( value ) : <EOL> self . _current [ field . name ] = value <EOL> else : <EOL> self . _current [ field . name ] = field . value_to_string ( obj ) <EOL> def handle_fk_field ( self , obj , field ) : <EOL> related = getattr ( obj , field . name ) <EOL> if related is not None : <EOL> if self . use_natural_keys and hasattr ( related , '<STR_LIT>' ) : <EOL> related = related . natural_key ( ) <EOL> else : <EOL> if field . rel . field_name == related . _meta . pk . name : <EOL> related = related . _get_pk_val ( ) <EOL> else : <EOL> related = smart_unicode ( getattr ( related , field . rel . field_name ) , strings_only = True ) <EOL> self . _current [ field . name ] = related <EOL> def handle_m2m_field ( self , obj , field ) : <EOL> if field . rel . through . _meta . auto_created : <EOL> if self . use_natural_keys and hasattr ( field . rel . to , '<STR_LIT>' ) : <EOL> m2m_value = lambda value : value . natural_key ( ) <EOL> else : <EOL> m2m_value = lambda value : smart_unicode ( value . _get_pk_val ( ) , strings_only = True ) <EOL> self . _current [ field . name ] = [ m2m_value ( related ) <EOL> for related in getattr ( obj , field . name ) . iterator ( ) ] <EOL> def getvalue ( self ) : <EOL> return self . objects <EOL>"}
{"rec_id": "763", "recitation_code": "def Deserializer ( stream or string , * * options ) :", "input_code_id": 71668, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from django . conf import settings <EOL> from django . core . serializers import base <EOL> from django . db import models , DEFAULT_DB_ALIAS <EOL> from django . utils . encoding import smart_unicode , is_protected_type <EOL> class Serializer ( base . Serializer ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> internal_use_only = True <EOL> def start_serialization ( self ) : <EOL> self . _current = None <EOL> self . objects = [ ] <EOL> def end_serialization ( self ) : <EOL> pass <EOL> def start_object ( self , obj ) : <EOL> self . _current = { } <EOL> def end_object ( self , obj ) : <EOL> self . objects . append ( { <EOL> \"<STR_LIT>\" : smart_unicode ( obj . _meta ) , <EOL> \"<STR_LIT>\" : smart_unicode ( obj . _get_pk_val ( ) , strings_only = True ) , <EOL> \"<STR_LIT>\" : self . _current <EOL> } ) <EOL> self . _current = None <EOL> def handle_field ( self , obj , field ) : <EOL> value = field . _get_val_from_obj ( obj ) <EOL> if is_protected_type ( value ) : <EOL> self . _current [ field . name ] = value <EOL> else : <EOL> self . _current [ field . name ] = field . value_to_string ( obj ) <EOL> def handle_fk_field ( self , obj , field ) : <EOL> related = getattr ( obj , field . name ) <EOL> if related is not None : <EOL> if self . use_natural_keys and hasattr ( related , '<STR_LIT>' ) : <EOL> related = related . natural_key ( ) <EOL> else : <EOL> if field . rel . field_name == related . _meta . pk . name : <EOL> related = related . _get_pk_val ( ) <EOL> else : <EOL> related = smart_unicode ( getattr ( related , field . rel . field_name ) , strings_only = True ) <EOL> self . _current [ field . name ] = related <EOL> def handle_m2m_field ( self , obj , field ) : <EOL> if field . rel . through . _meta . auto_created : <EOL> if self . use_natural_keys and hasattr ( field . rel . to , '<STR_LIT>' ) : <EOL> m2m_value = lambda value : value . natural_key ( ) <EOL> else : <EOL> m2m_value = lambda value : smart_unicode ( value . _get_pk_val ( ) , strings_only = True ) <EOL> self . _current [ field . name ] = [ m2m_value ( related ) <EOL> for related in getattr ( obj , field . name ) . iterator ( ) ] <EOL> def getvalue ( self ) : <EOL> return self . objects <EOL>"}
{"rec_id": "795", "recitation_code": "self . set method ( self , ' GET ' )", "input_code_id": 795, "input": "<s> from aliyunsdkcore . request import RoaRequest <EOL> class GetImageRequest ( RoaRequest ) : <EOL> def __init__ ( self ) : <EOL> RoaRequest . __init__ ( self , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . set_uri_pattern ( self , '<STR_LIT>' ) <EOL>"}
{"rec_id": "795", "recitation_code": "self . set method ( self , ' GET ' )", "input_code_id": 1927, "input": "<s> from aliyunsdkcore . request import RoaRequest <EOL> class StartJobRequest ( RoaRequest ) : <EOL> def __init__ ( self ) : <EOL> RoaRequest . __init__ ( self , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . set_uri_pattern ( self , '<STR_LIT>' ) <EOL>"}
{"rec_id": "795", "recitation_code": "self . set method ( self , ' GET ' )", "input_code_id": 12210, "input": "<s> from aliyunsdkcore . request import RoaRequest <EOL> class GetJobDescriptionRequest ( RoaRequest ) : <EOL> def __init__ ( self ) : <EOL> RoaRequest . __init__ ( self , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . set_uri_pattern ( self , '<STR_LIT>' ) <EOL>"}
{"rec_id": "795", "recitation_code": "self . set method ( self , ' GET ' )", "input_code_id": 32736, "input": "<s> from aliyunsdkcore . request import RoaRequest <EOL> class GetJobDescriptionRequest ( RoaRequest ) : <EOL> def __init__ ( self ) : <EOL> RoaRequest . __init__ ( self , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . set_uri_pattern ( self , '<STR_LIT>' ) <EOL>"}
{"rec_id": "795", "recitation_code": "self . set method ( self , ' GET ' )", "input_code_id": 83615, "input": "<s> from aliyunsdkcore . request import RoaRequest <EOL> class GetJobRequest ( RoaRequest ) : <EOL> def __init__ ( self ) : <EOL> RoaRequest . __init__ ( self , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . set_uri_pattern ( self , '<STR_LIT>' ) <EOL>"}
{"rec_id": "851", "recitation_code": "def init ( cls ) :", "input_code_id": 851, "input": "<s> import dbus <EOL> import logging <EOL> import subprocess <EOL> from ajenti . api import * <EOL> from ajenti . util import cache_value <EOL> from api import Service , ServiceManager <EOL> class UpstartService ( Service ) : <EOL> source = '<STR_LIT>' <EOL> def __init__ ( self , name ) : <EOL> self . name = name <EOL> def refresh ( self ) : <EOL> self . running = '<STR_LIT>' in subprocess . check_output ( [ '<STR_LIT:status>' , self . name ] ) <EOL> def start ( self ) : <EOL> self . command ( '<STR_LIT:start>' ) <EOL> def stop ( self ) : <EOL> self . command ( '<STR_LIT>' ) <EOL> def restart ( self ) : <EOL> self . command ( '<STR_LIT>' ) <EOL> def command ( self , cmd ) : <EOL> subprocess . Popen ( [ '<STR_LIT>' , cmd , self . name ] , close_fds = True ) . wait ( ) <EOL> @ plugin <EOL> class UpstartServiceManager ( ServiceManager ) : <EOL> def init ( self ) : <EOL> self . bus = dbus . SystemBus ( ) <EOL> self . upstart = self . bus . get_object ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> @ classmethod <EOL>"}
{"rec_id": "851", "recitation_code": "def init ( cls ) :", "input_code_id": 84540, "input": "<s> from org . sikuli . basics import HotkeyListener <EOL> from org . sikuli . basics import HotkeyManager <EOL> from org . sikuli . script import Env as JEnv <EOL> class Env ( JEnv ) : <EOL> @ classmethod <EOL>"}
{"rec_id": "855", "recitation_code": "from pants test . subsystem . subsystem util import subsystem instance", "input_code_id": 855, "input": "<s> from __future__ import ( absolute_import , division , generators , nested_scopes , print_function , <EOL> unicode_literals , with_statement ) <EOL> from pants_test . projects . base_project_integration_test import ProjectIntegrationTest <EOL>"}
{"rec_id": "855", "recitation_code": "from pants test . subsystem . subsystem util import subsystem instance", "input_code_id": 69126, "input": "<s> from __future__ import ( absolute_import , division , generators , nested_scopes , print_function , <EOL> unicode_literals , with_statement ) <EOL> from pants . util . contextutil import temporary_dir <EOL> from pants_test . pants_run_integration_test import PantsRunIntegrationTest <EOL>"}
{"rec_id": "855", "recitation_code": "from pants test . subsystem . subsystem util import subsystem instance", "input_code_id": 79280, "input": "<s> from __future__ import ( absolute_import , division , generators , nested_scopes , print_function , <EOL> unicode_literals , with_statement ) <EOL> from pants_test . backend . jvm . tasks . jvm_compile . java . jvm_platform_integration_mixin import JvmPlatformIntegrationMixin <EOL> from pants_test . pants_run_integration_test import PantsRunIntegrationTest <EOL>"}
{"rec_id": "894", "recitation_code": "self . stderr buffer . truncate ( )", "input_code_id": 894, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> import traceback <EOL> import unittest <EOL> from StringIO import StringIO <EOL> from django . utils . unittest import util <EOL> from django . utils . unittest . compatibility import wraps <EOL> __unittest = True <EOL> def failfast ( method ) : <EOL> @ wraps ( method ) <EOL> def inner ( self , * args , ** kw ) : <EOL> if getattr ( self , '<STR_LIT>' , False ) : <EOL> self . stop ( ) <EOL> return method ( self , * args , ** kw ) <EOL> return inner <EOL> STDOUT_LINE = '<STR_LIT>' <EOL> STDERR_LINE = '<STR_LIT>' <EOL> class TestResult ( unittest . TestResult ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _previousTestClass = None <EOL> _moduleSetUpFailed = False <EOL> def __init__ ( self ) : <EOL> self . failfast = False <EOL> self . failures = [ ] <EOL> self . errors = [ ] <EOL> self . testsRun = <NUM_LIT:0> <EOL> self . skipped = [ ] <EOL> self . expectedFailures = [ ] <EOL> self . unexpectedSuccesses = [ ] <EOL> self . shouldStop = False <EOL> self . buffer = False <EOL> self . _stdout_buffer = None <EOL> self . _stderr_buffer = None <EOL> self . _original_stdout = sys . stdout <EOL> self . _original_stderr = sys . stderr <EOL> self . _mirrorOutput = False <EOL> def startTest ( self , test ) : <EOL> \"<STR_LIT>\" <EOL> self . testsRun += <NUM_LIT:1> <EOL> self . _mirrorOutput = False <EOL> if self . buffer : <EOL> if self . _stderr_buffer is None : <EOL> self . _stderr_buffer = StringIO ( ) <EOL> self . _stdout_buffer = StringIO ( ) <EOL> sys . stdout = self . _stdout_buffer <EOL> sys . stderr = self . _stderr_buffer <EOL> def startTestRun ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def stopTest ( self , test ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . buffer : <EOL> if self . _mirrorOutput : <EOL> output = sys . stdout . getvalue ( ) <EOL> error = sys . stderr . getvalue ( ) <EOL> if output : <EOL> if not output . endswith ( '<STR_LIT:\\n>' ) : <EOL> output += '<STR_LIT:\\n>' <EOL> self . _original_stdout . write ( STDOUT_LINE % output ) <EOL> if error : <EOL> if not error . endswith ( '<STR_LIT:\\n>' ) : <EOL> error += '<STR_LIT:\\n>' <EOL> self . _original_stderr . write ( STDERR_LINE % error ) <EOL> sys . stdout = self . _original_stdout <EOL> sys . stderr = self . _original_stderr <EOL> self . _stdout_buffer . seek ( <NUM_LIT:0> ) <EOL> self . _stdout_buffer . truncate ( ) <EOL> self . _stderr_buffer . seek ( <NUM_LIT:0> ) <EOL>"}
{"rec_id": "894", "recitation_code": "self . stderr buffer . truncate ( )", "input_code_id": 37066, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> import traceback <EOL> import unittest <EOL> from StringIO import StringIO <EOL> from airy . utils . unittest import util <EOL> from airy . utils . unittest . compatibility import wraps <EOL> __unittest = True <EOL> def failfast ( method ) : <EOL> @ wraps ( method ) <EOL> def inner ( self , * args , ** kw ) : <EOL> if getattr ( self , '<STR_LIT>' , False ) : <EOL> self . stop ( ) <EOL> return method ( self , * args , ** kw ) <EOL> return inner <EOL> STDOUT_LINE = '<STR_LIT>' <EOL> STDERR_LINE = '<STR_LIT>' <EOL> class TestResult ( unittest . TestResult ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _previousTestClass = None <EOL> _moduleSetUpFailed = False <EOL> def __init__ ( self ) : <EOL> self . failfast = False <EOL> self . failures = [ ] <EOL> self . errors = [ ] <EOL> self . testsRun = <NUM_LIT:0> <EOL> self . skipped = [ ] <EOL> self . expectedFailures = [ ] <EOL> self . unexpectedSuccesses = [ ] <EOL> self . shouldStop = False <EOL> self . buffer = False <EOL> self . _stdout_buffer = None <EOL> self . _stderr_buffer = None <EOL> self . _original_stdout = sys . stdout <EOL> self . _original_stderr = sys . stderr <EOL> self . _mirrorOutput = False <EOL> def startTest ( self , test ) : <EOL> \"<STR_LIT>\" <EOL> self . testsRun += <NUM_LIT:1> <EOL> self . _mirrorOutput = False <EOL> if self . buffer : <EOL> if self . _stderr_buffer is None : <EOL> self . _stderr_buffer = StringIO ( ) <EOL> self . _stdout_buffer = StringIO ( ) <EOL> sys . stdout = self . _stdout_buffer <EOL> sys . stderr = self . _stderr_buffer <EOL> def startTestRun ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def stopTest ( self , test ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . buffer : <EOL> if self . _mirrorOutput : <EOL> output = sys . stdout . getvalue ( ) <EOL> error = sys . stderr . getvalue ( ) <EOL> if output : <EOL> if not output . endswith ( '<STR_LIT:\\n>' ) : <EOL> output += '<STR_LIT:\\n>' <EOL> self . _original_stdout . write ( STDOUT_LINE % output ) <EOL> if error : <EOL> if not error . endswith ( '<STR_LIT:\\n>' ) : <EOL> error += '<STR_LIT:\\n>' <EOL> self . _original_stderr . write ( STDERR_LINE % error ) <EOL> sys . stdout = self . _original_stdout <EOL> sys . stderr = self . _original_stderr <EOL> self . _stdout_buffer . seek ( <NUM_LIT:0> ) <EOL> self . _stdout_buffer . truncate ( ) <EOL> self . _stderr_buffer . seek ( <NUM_LIT:0> ) <EOL>"}
{"rec_id": "895", "recitation_code": "result = ad group ad service . mutate ( operations )", "input_code_id": 895, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import suds <EOL> from googleads import adwords <EOL> AD_GROUP_ID = '<STR_LIT>' <EOL> def main ( client , ad_group_id ) : <EOL> client . validate_only = True <EOL> ad_group_ad_service = client . GetService ( '<STR_LIT>' , version = '<STR_LIT>' ) <EOL> operations = [ { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : ad_group_id , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> } <EOL> } ] <EOL>"}
{"rec_id": "895", "recitation_code": "result = ad group ad service . mutate ( operations )", "input_code_id": 56227, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import suds <EOL> from googleads import adwords <EOL> AD_GROUP_ID = '<STR_LIT>' <EOL> def main ( client , ad_group_id ) : <EOL> client . validate_only = True <EOL> ad_group_ad_service = client . GetService ( '<STR_LIT>' , version = '<STR_LIT>' ) <EOL> operations = [ { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : ad_group_id , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> } <EOL> } ] <EOL>"}
{"rec_id": "897", "recitation_code": "t NUMBER = r ' '", "input_code_id": 897, "input": "<s> import sys <EOL> if \"<STR_LIT:..>\" not in sys . path : sys . path . insert ( <NUM_LIT:0> , \"<STR_LIT:..>\" ) <EOL> import ply . lex as lex <EOL> tokens = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> ) <EOL> def make_calc ( ) : <EOL> t_PLUS = r'<STR_LIT>' <EOL> t_MINUS = r'<STR_LIT:->' <EOL> t_TIMES = r'<STR_LIT>' <EOL> t_DIVIDE = r'<STR_LIT:/>' <EOL> t_EQUALS = r'<STR_LIT:=>' <EOL> t_LPAREN = r'<STR_LIT>' <EOL> t_RPAREN = r'<STR_LIT>' <EOL> t_NAME = r'<STR_LIT>' <EOL>"}
{"rec_id": "897", "recitation_code": "t NUMBER = r ' '", "input_code_id": 34543, "input": "<s> import sys <EOL> if \"<STR_LIT:..>\" not in sys . path : sys . path . insert ( <NUM_LIT:0> , \"<STR_LIT:..>\" ) <EOL> import ply . lex as lex <EOL> tokens = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> states = ( ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> t_PLUS = r'<STR_LIT>' <EOL> t_MINUS = r'<STR_LIT:->' <EOL>"}
{"rec_id": "897", "recitation_code": "t NUMBER = r ' '", "input_code_id": 54751, "input": "<s> import sys <EOL> if \"<STR_LIT:..>\" not in sys . path : sys . path . insert ( <NUM_LIT:0> , \"<STR_LIT:..>\" ) <EOL> import ply . lex as lex <EOL> tokens = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> states = '<STR_LIT>' <EOL> t_PLUS = r'<STR_LIT>' <EOL> t_MINUS = r'<STR_LIT:->' <EOL>"}
{"rec_id": "897", "recitation_code": "t NUMBER = r ' '", "input_code_id": 64982, "input": "<s> import sys <EOL> if \"<STR_LIT:..>\" not in sys . path : sys . path . insert ( <NUM_LIT:0> , \"<STR_LIT:..>\" ) <EOL> import ply . lex as lex <EOL> class CalcLexer : <EOL> tokens = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> ) <EOL> t_PLUS = r'<STR_LIT>' <EOL> t_MINUS = r'<STR_LIT:->' <EOL> t_TIMES = r'<STR_LIT>' <EOL> t_DIVIDE = r'<STR_LIT:/>' <EOL> t_EQUALS = r'<STR_LIT:=>' <EOL> t_LPAREN = r'<STR_LIT>' <EOL> t_RPAREN = r'<STR_LIT>' <EOL> t_NAME = r'<STR_LIT>' <EOL>"}
{"rec_id": "942", "recitation_code": "return capi . get field width ( self . ptr )", "input_code_id": 942, "input": "<s> from ctypes import byref , c_int <EOL> from datetime import date , datetime , time <EOL> from django . contrib . gis . gdal . base import GDALBase <EOL> from django . contrib . gis . gdal . error import OGRException <EOL> from django . contrib . gis . gdal . prototypes import ds as capi <EOL> class Field ( GDALBase ) : <EOL> \"<STR_LIT>\" <EOL> def __init__ ( self , feat , index ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _feat = feat <EOL> self . _index = index <EOL> fld_ptr = capi . get_feat_field_defn ( feat , index ) <EOL> if not fld_ptr : <EOL> raise OGRException ( '<STR_LIT>' ) <EOL> self . ptr = fld_ptr <EOL> self . __class__ = OGRFieldTypes [ self . type ] <EOL> if isinstance ( self , OFTReal ) and self . precision == <NUM_LIT:0> : <EOL> self . __class__ = OFTInteger <EOL> def __str__ ( self ) : <EOL> \"<STR_LIT>\" <EOL> return str ( self . value ) . strip ( ) <EOL> def as_double ( self ) : <EOL> \"<STR_LIT>\" <EOL> return capi . get_field_as_double ( self . _feat , self . _index ) <EOL> def as_int ( self ) : <EOL> \"<STR_LIT>\" <EOL> return capi . get_field_as_integer ( self . _feat , self . _index ) <EOL> def as_string ( self ) : <EOL> \"<STR_LIT>\" <EOL> return capi . get_field_as_string ( self . _feat , self . _index ) <EOL> def as_datetime ( self ) : <EOL> \"<STR_LIT>\" <EOL> yy , mm , dd , hh , mn , ss , tz = [ c_int ( ) for i in range ( <NUM_LIT:7> ) ] <EOL> status = capi . get_field_as_datetime ( self . _feat , self . _index , byref ( yy ) , byref ( mm ) , byref ( dd ) , <EOL> byref ( hh ) , byref ( mn ) , byref ( ss ) , byref ( tz ) ) <EOL> if status : <EOL> return ( yy , mm , dd , hh , mn , ss , tz ) <EOL> else : <EOL> raise OGRException ( '<STR_LIT>' ) <EOL> @ property <EOL> def name ( self ) : <EOL> \"<STR_LIT>\" <EOL> return capi . get_field_name ( self . ptr ) <EOL> @ property <EOL> def precision ( self ) : <EOL> \"<STR_LIT>\" <EOL> return capi . get_field_precision ( self . ptr ) <EOL> @ property <EOL> def type ( self ) : <EOL> \"<STR_LIT>\" <EOL> return capi . get_field_type ( self . ptr ) <EOL> @ property <EOL> def type_name ( self ) : <EOL> \"<STR_LIT>\" <EOL> return capi . get_field_type_name ( self . type ) <EOL> @ property <EOL> def value ( self ) : <EOL> \"<STR_LIT>\" <EOL> return self . as_string ( ) <EOL> @ property <EOL> def width ( self ) : <EOL> \"<STR_LIT>\" <EOL>"}
{"rec_id": "942", "recitation_code": "return capi . get field width ( self . ptr )", "input_code_id": 20731, "input": "<s> from ctypes import byref , c_int <EOL> from datetime import date , datetime , time <EOL> from django . contrib . gis . gdal . base import GDALBase <EOL> from django . contrib . gis . gdal . error import OGRException <EOL> from django . contrib . gis . gdal . prototypes import ds as capi <EOL> from django . utils . encoding import force_text <EOL> class Field ( GDALBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , feat , index ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _feat = feat <EOL> self . _index = index <EOL> fld_ptr = capi . get_feat_field_defn ( feat . ptr , index ) <EOL> if not fld_ptr : <EOL> raise OGRException ( '<STR_LIT>' ) <EOL> self . ptr = fld_ptr <EOL> self . __class__ = OGRFieldTypes [ self . type ] <EOL> if isinstance ( self , OFTReal ) and self . precision == <NUM_LIT:0> : <EOL> self . __class__ = OFTInteger <EOL> self . _double = True <EOL> def __str__ ( self ) : <EOL> \"<STR_LIT>\" <EOL> return str ( self . value ) . strip ( ) <EOL> def as_double ( self ) : <EOL> \"<STR_LIT>\" <EOL> return capi . get_field_as_double ( self . _feat . ptr , self . _index ) <EOL> def as_int ( self ) : <EOL> \"<STR_LIT>\" <EOL> return capi . get_field_as_integer ( self . _feat . ptr , self . _index ) <EOL> def as_string ( self ) : <EOL> \"<STR_LIT>\" <EOL> string = capi . get_field_as_string ( self . _feat . ptr , self . _index ) <EOL> return force_text ( string , encoding = self . _feat . encoding , strings_only = True ) <EOL> def as_datetime ( self ) : <EOL> \"<STR_LIT>\" <EOL> yy , mm , dd , hh , mn , ss , tz = [ c_int ( ) for i in range ( <NUM_LIT:7> ) ] <EOL> status = capi . get_field_as_datetime ( <EOL> self . _feat . ptr , self . _index , byref ( yy ) , byref ( mm ) , byref ( dd ) , <EOL> byref ( hh ) , byref ( mn ) , byref ( ss ) , byref ( tz ) ) <EOL> if status : <EOL> return ( yy , mm , dd , hh , mn , ss , tz ) <EOL> else : <EOL> raise OGRException ( '<STR_LIT>' ) <EOL> @ property <EOL> def name ( self ) : <EOL> \"<STR_LIT>\" <EOL> name = capi . get_field_name ( self . ptr ) <EOL> return force_text ( name , encoding = self . _feat . encoding , strings_only = True ) <EOL> @ property <EOL> def precision ( self ) : <EOL> \"<STR_LIT>\" <EOL> return capi . get_field_precision ( self . ptr ) <EOL> @ property <EOL> def type ( self ) : <EOL> \"<STR_LIT>\" <EOL> return capi . get_field_type ( self . ptr ) <EOL> @ property <EOL> def type_name ( self ) : <EOL> \"<STR_LIT>\" <EOL> return capi . get_field_type_name ( self . type ) <EOL> @ property <EOL> def value ( self ) : <EOL> \"<STR_LIT>\" <EOL> return self . as_string ( ) <EOL> @ property <EOL> def width ( self ) : <EOL> \"<STR_LIT>\" <EOL>"}
{"rec_id": "977", "recitation_code": "label = self . labels [ name ]", "input_code_id": 977, "input": "<s> from Tkinter import * <EOL> class MultiStatusBar ( Frame ) : <EOL> def __init__ ( self , master = None , ** kw ) : <EOL> if master is None : <EOL> master = Tk ( ) <EOL> Frame . __init__ ( self , master , ** kw ) <EOL> self . labels = { } <EOL> def set_label ( self , name , text = '<STR_LIT>' , side = LEFT ) : <EOL> if not self . labels . has_key ( name ) : <EOL> label = Label ( self , bd = <NUM_LIT:1> , relief = SUNKEN , anchor = W ) <EOL> label . pack ( side = side ) <EOL> self . labels [ name ] = label <EOL> else : <EOL>"}
{"rec_id": "977", "recitation_code": "label = self . labels [ name ]", "input_code_id": 50157, "input": "<s> from Tkinter import * <EOL> class MultiStatusBar ( Frame ) : <EOL> def __init__ ( self , master = None , ** kw ) : <EOL> if master is None : <EOL> master = Tk ( ) <EOL> Frame . __init__ ( self , master , ** kw ) <EOL> self . labels = { } <EOL> def set_label ( self , name , text = '<STR_LIT>' , side = LEFT ) : <EOL> if not self . labels . has_key ( name ) : <EOL> label = Label ( self , bd = <NUM_LIT:1> , relief = SUNKEN , anchor = W ) <EOL> label . pack ( side = side ) <EOL> self . labels [ name ] = label <EOL> else : <EOL>"}
{"rec_id": "977", "recitation_code": "label = self . labels [ name ]", "input_code_id": 86009, "input": "<s> from Tkinter import * <EOL> class MultiStatusBar ( Frame ) : <EOL> def __init__ ( self , master = None , ** kw ) : <EOL> if master is None : <EOL> master = Tk ( ) <EOL> Frame . __init__ ( self , master , ** kw ) <EOL> self . labels = { } <EOL> def set_label ( self , name , text = '<STR_LIT>' , side = LEFT ) : <EOL> if name not in self . labels : <EOL> label = Label ( self , bd = <NUM_LIT:1> , relief = SUNKEN , anchor = W ) <EOL> label . pack ( side = side ) <EOL> self . labels [ name ] = label <EOL> else : <EOL>"}
{"rec_id": "1012", "recitation_code": "R . add edge ( * e )", "input_code_id": 1012, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import networkx as nx <EOL> from networkx . utils import is_string_like <EOL> __author__ = \"\"\"<STR_LIT:\\n>\"\"\" . join ( [ '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ] ) <EOL> __all__ = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ] <EOL> def union ( G , H , rename = ( None , None ) , name = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not G . is_multigraph ( ) == H . is_multigraph ( ) : <EOL> raise nx . NetworkXError ( '<STR_LIT>' ) <EOL> R = G . __class__ ( ) <EOL> if name is None : <EOL> name = \"<STR_LIT>\" % ( G . name , H . name ) <EOL> R . name = name <EOL> def add_prefix ( graph , prefix ) : <EOL> if prefix is None : <EOL> return graph <EOL> def label ( x ) : <EOL> if is_string_like ( x ) : <EOL> name = prefix + x <EOL> else : <EOL> name = prefix + repr ( x ) <EOL> return name <EOL> return nx . relabel_nodes ( graph , label ) <EOL> G = add_prefix ( G , rename [ <NUM_LIT:0> ] ) <EOL> H = add_prefix ( H , rename [ <NUM_LIT:1> ] ) <EOL> if set ( G ) & set ( H ) : <EOL> raise nx . NetworkXError ( '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> if G . is_multigraph ( ) : <EOL> G_edges = G . edges ( keys = True , data = True ) <EOL> else : <EOL> G_edges = G . edges ( data = True ) <EOL> if H . is_multigraph ( ) : <EOL> H_edges = H . edges ( keys = True , data = True ) <EOL> else : <EOL> H_edges = H . edges ( data = True ) <EOL> R . add_nodes_from ( G ) <EOL> R . add_edges_from ( G_edges ) <EOL> R . add_nodes_from ( H ) <EOL> R . add_edges_from ( H_edges ) <EOL> R . node . update ( G . node ) <EOL> R . node . update ( H . node ) <EOL> R . graph . update ( G . graph ) <EOL> R . graph . update ( H . graph ) <EOL> return R <EOL> def disjoint_union ( G , H ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> R1 = nx . convert_node_labels_to_integers ( G ) <EOL> R2 = nx . convert_node_labels_to_integers ( H , first_label = len ( R1 ) ) <EOL> R = union ( R1 , R2 ) <EOL> R . name = \"<STR_LIT>\" % ( G . name , H . name ) <EOL> R . graph . update ( G . graph ) <EOL> R . graph . update ( H . graph ) <EOL> return R <EOL> def intersection ( G , H ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> R = nx . create_empty_copy ( G ) <EOL> R . name = \"<STR_LIT>\" % ( G . name , H . name ) <EOL> if not G . is_multigraph ( ) == H . is_multigraph ( ) : <EOL> raise nx . NetworkXError ( '<STR_LIT>' ) <EOL> if set ( G ) != set ( H ) : <EOL> raise nx . NetworkXError ( \"<STR_LIT>\" ) <EOL> if G . number_of_edges ( ) <= H . number_of_edges ( ) : <EOL> if G . is_multigraph ( ) : <EOL> edges = G . edges ( keys = True ) <EOL> else : <EOL> edges = G . edges ( ) <EOL> for e in edges : <EOL> if H . has_edge ( * e ) : <EOL>"}
{"rec_id": "1012", "recitation_code": "R . add edge ( * e )", "input_code_id": 25572, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import networkx as nx <EOL> from networkx . utils import is_string_like <EOL> __author__ = \"\"\"<STR_LIT:\\n>\"\"\" . join ( [ '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ] ) <EOL> __all__ = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ] <EOL> def union ( G , H , rename = ( None , None ) , name = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> R = G . __class__ ( ) <EOL> if name is None : <EOL> name = \"<STR_LIT>\" % ( G . name , H . name ) <EOL> R . name = name <EOL> def add_prefix ( graph , prefix ) : <EOL> if prefix is None : <EOL> return graph <EOL> def label ( x ) : <EOL> if is_string_like ( x ) : <EOL> name = prefix + x <EOL> else : <EOL> name = prefix + repr ( x ) <EOL> return name <EOL> return nx . relabel_nodes ( graph , label ) <EOL> G = add_prefix ( G , rename [ <NUM_LIT:0> ] ) <EOL> H = add_prefix ( H , rename [ <NUM_LIT:1> ] ) <EOL> if set ( G ) & set ( H ) : <EOL> raise nx . NetworkXError ( '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> if G . is_multigraph ( ) : <EOL> G_edges = G . edges_iter ( keys = True , data = True ) <EOL> else : <EOL> G_edges = G . edges_iter ( data = True ) <EOL> if H . is_multigraph ( ) : <EOL> H_edges = H . edges_iter ( keys = True , data = True ) <EOL> else : <EOL> H_edges = H . edges_iter ( data = True ) <EOL> R . add_nodes_from ( G ) <EOL> R . add_edges_from ( G_edges ) <EOL> R . add_nodes_from ( H ) <EOL> R . add_edges_from ( H_edges ) <EOL> R . node . update ( G . node ) <EOL> R . node . update ( H . node ) <EOL> R . graph . update ( G . graph ) <EOL> R . graph . update ( H . graph ) <EOL> return R <EOL> def disjoint_union ( G , H ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> R1 = nx . convert_node_labels_to_integers ( G ) <EOL> R2 = nx . convert_node_labels_to_integers ( H , first_label = len ( R1 ) ) <EOL> R = union ( R1 , R2 ) <EOL> R . name = \"<STR_LIT>\" % ( G . name , H . name ) <EOL> R . graph . update ( G . graph ) <EOL> R . graph . update ( H . graph ) <EOL> return R <EOL> def intersection ( G , H ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> R = nx . create_empty_copy ( G ) <EOL> R . name = \"<STR_LIT>\" % ( G . name , H . name ) <EOL> if set ( G ) != set ( H ) : <EOL> raise nx . NetworkXError ( \"<STR_LIT>\" ) <EOL> if G . number_of_edges ( ) <= H . number_of_edges ( ) : <EOL> if G . is_multigraph ( ) : <EOL> edges = G . edges_iter ( keys = True ) <EOL> else : <EOL> edges = G . edges_iter ( ) <EOL> for e in edges : <EOL> if H . has_edge ( * e ) : <EOL>"}
{"rec_id": "1081", "recitation_code": "raise CommandError ( ' ' + ' ' )", "input_code_id": 1081, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import optparse <EOL> from django . core . management . base import BaseCommand , CommandError <EOL> from os import makedirs , remove <EOL> from os . path import abspath , dirname , join , exists <EOL> from sys import argv <EOL> import urllib2 <EOL> CACHE_DIR = \"<STR_LIT>\" <EOL> MANIFEST_FILENAME = \"<STR_LIT>\" <EOL> class Command ( BaseCommand ) : <EOL> option_list = BaseCommand . option_list + ( <EOL> optparse . make_option ( '<STR_LIT>' , <EOL> action = '<STR_LIT:store_true>' , dest = '<STR_LIT>' , default = False , <EOL> help = \"<STR_LIT>\" ) , <EOL> ) <EOL> help = '<STR_LIT>' <EOL> args = '<STR_LIT>' <EOL> can_import_settings = True <EOL> def handle ( self , * args , ** options ) : <EOL> from django . conf import settings <EOL> if not hasattr ( settings , '<STR_LIT>' ) or not hasattr ( settings , '<STR_LIT>' ) : <EOL> raise CommandError ( '<STR_LIT>' + '<STR_LIT>' ) <EOL> else : <EOL> self . AWS_ACCESS_KEY_ID = settings . AWS_ACCESS_KEY_ID <EOL> self . AWS_SECRET_ACCESS_KEY = settings . AWS_SECRET_ACCESS_KEY <EOL> if not hasattr ( settings , '<STR_LIT>' ) : <EOL>"}
{"rec_id": "1081", "recitation_code": "raise CommandError ( ' ' + ' ' )", "input_code_id": 11700, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import optparse <EOL> from django . core . management . base import BaseCommand , CommandError <EOL> from os import makedirs , remove <EOL> from os . path import abspath , dirname , join , exists <EOL> from sys import argv <EOL> import urllib2 <EOL> CACHE_DIR = \"<STR_LIT>\" <EOL> MANIFEST_FILENAME = \"<STR_LIT>\" <EOL> class Command ( BaseCommand ) : <EOL> option_list = BaseCommand . option_list + ( <EOL> optparse . make_option ( '<STR_LIT>' , <EOL> action = '<STR_LIT:store_true>' , dest = '<STR_LIT>' , default = False , <EOL> help = \"<STR_LIT>\" ) , <EOL> ) <EOL> help = '<STR_LIT>' <EOL> args = '<STR_LIT>' <EOL> can_import_settings = True <EOL> def handle ( self , * args , ** options ) : <EOL> from django . conf import settings <EOL> if not hasattr ( settings , '<STR_LIT>' ) or not hasattr ( settings , '<STR_LIT>' ) : <EOL> raise CommandError ( '<STR_LIT>' + '<STR_LIT>' ) <EOL> else : <EOL> self . AWS_ACCESS_KEY_ID = settings . AWS_ACCESS_KEY_ID <EOL> self . AWS_SECRET_ACCESS_KEY = settings . AWS_SECRET_ACCESS_KEY <EOL> if not hasattr ( settings , '<STR_LIT>' ) : <EOL>"}
{"rec_id": "1204", "recitation_code": "rospy . init node ( \" \" )", "input_code_id": 1204, "input": "<s> import rospy <EOL> from mysql_wrapper import MySQLdbWrapper <EOL> if __name__ == \"<STR_LIT:__main__>\" : <EOL>"}
{"rec_id": "1204", "recitation_code": "rospy . init node ( \" \" )", "input_code_id": 40685, "input": "<s> import robotproxy <EOL> import sys <EOL> import rospy <EOL> if __name__ == \"<STR_LIT:__main__>\" : <EOL>"}
{"rec_id": "1310", "recitation_code": "self . os id = os id", "input_code_id": 1310, "input": "<s> import os <EOL> from bareon import errors <EOL> class Image ( object ) : <EOL> SUPPORTED_CONTAINERS = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def __init__ ( self , uri , target_device , <EOL> format , container , size = None , md5 = None , os_id = None , <EOL> os_boot = False , image_name = '<STR_LIT>' , image_uuid = '<STR_LIT>' , <EOL> deployment_flags = { } ) : <EOL> self . uri = uri <EOL> self . target_device = target_device <EOL> self . format = format <EOL> if container not in self . SUPPORTED_CONTAINERS : <EOL> raise errors . WrongImageDataError ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> self . container = container <EOL> self . size = size <EOL> self . md5 = md5 <EOL> self . img_tmp_file = None <EOL>"}
{"rec_id": "1310", "recitation_code": "self . os id = os id", "input_code_id": 27920, "input": "<s> from bareon . objects import base <EOL> class FileSystem ( base . Serializable ) : <EOL> def __init__ ( self , device , mount = None , fs_type = None , fs_options = None , <EOL> fs_label = None , keep_data = False , fstab_enabled = True , <EOL> fstab_options = '<STR_LIT>' , os_id = [ ] ) : <EOL> self . keep_data = keep_data <EOL> self . device = device <EOL> self . mount = mount <EOL> self . type = fs_type if ( fs_type is not None ) else '<STR_LIT>' <EOL> self . options = fs_options or '<STR_LIT>' <EOL> self . fstab_options = fstab_options <EOL> self . label = fs_label or '<STR_LIT>' <EOL> self . fstab_enabled = fstab_enabled <EOL>"}
{"rec_id": "1330", "recitation_code": "search fields = ( ' title ' , )", "input_code_id": 1330, "input": "<s> from django . contrib import admin <EOL> from wysihtml5 . admin import AdminWysihtml5TextFieldMixin <EOL> from demo . articles . models import Article <EOL> class ArticleAdmin ( AdminWysihtml5TextFieldMixin , admin . ModelAdmin ) : <EOL> list_display = ( '<STR_LIT:title>' , '<STR_LIT>' ) <EOL> list_filter = ( '<STR_LIT>' , ) <EOL>"}
{"rec_id": "1330", "recitation_code": "search fields = ( ' title ' , )", "input_code_id": 24304, "input": "<s> from django . contrib import admin <EOL> from simple_threads . articles . models import Article <EOL> class ArticleAdmin ( admin . ModelAdmin ) : <EOL> list_display = ( '<STR_LIT:title>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> list_filter = ( '<STR_LIT>' , ) <EOL>"}
{"rec_id": "1330", "recitation_code": "search fields = ( ' title ' , )", "input_code_id": 65016, "input": "<s> from django . contrib import admin <EOL> from simple . articles . models import Article <EOL> class ArticleAdmin ( admin . ModelAdmin ) : <EOL> list_display = ( '<STR_LIT:title>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> list_filter = ( '<STR_LIT>' , ) <EOL>"}
{"rec_id": "1330", "recitation_code": "search fields = ( ' title ' , )", "input_code_id": 76986, "input": "<s> from django . contrib import admin <EOL> from . models import Client , RedirectionEndpoint , AuthorizationCode , Scope , Token <EOL> class AuthorizationCodeInlineAdmin ( admin . TabularInline ) : <EOL> model = AuthorizationCode <EOL> extra = <NUM_LIT:1> <EOL> class RedirectionEndpointAdmin ( admin . TabularInline ) : <EOL> model = RedirectionEndpoint <EOL> extra = <NUM_LIT:1> <EOL> class TokenInlineAdmin ( admin . TabularInline ) : <EOL> model = Token <EOL> extra = <NUM_LIT:1> <EOL> class ClientAdmin ( admin . ModelAdmin ) : <EOL> list_display = ( '<STR_LIT:title>' , ) <EOL> list_display_links = ( '<STR_LIT:title>' , ) <EOL> search_fields = ( '<STR_LIT:title>' , ) <EOL> inlines = ( RedirectionEndpointAdmin , AuthorizationCodeInlineAdmin , TokenInlineAdmin ) <EOL> class ScopeAdmin ( admin . ModelAdmin ) : <EOL> list_display = ( '<STR_LIT:title>' , '<STR_LIT>' , '<STR_LIT:status>' ) <EOL> list_display_links = ( '<STR_LIT:title>' , ) <EOL>"}
{"rec_id": "1333", "recitation_code": "df . Module . init ( self )", "input_code_id": 1333, "input": "<s> import DeepFried2 as df <EOL> from theano . tensor . nnet import relu <EOL> class ReLU ( df . Module ) : <EOL> def __init__ ( self , alpha = <NUM_LIT:0> ) : <EOL>"}
{"rec_id": "1333", "recitation_code": "df . Module . init ( self )", "input_code_id": 26919, "input": "<s> import DeepFried2 as df <EOL> class AddConstant ( df . Module ) : <EOL> def __init__ ( self , scalar ) : <EOL>"}
{"rec_id": "1333", "recitation_code": "df . Module . init ( self )", "input_code_id": 37201, "input": "<s> import DeepFried2 as df <EOL> class Bias ( df . Module ) : <EOL> def __init__ ( self , shape , init = df . init . const ( <NUM_LIT:0> ) , bcast = None ) : <EOL>"}
{"rec_id": "1333", "recitation_code": "df . Module . init ( self )", "input_code_id": 57424, "input": "<s> import DeepFried2 as df <EOL> class Permute ( df . Module ) : <EOL> def __init__ ( self , * new_dims ) : <EOL>"}
{"rec_id": "1333", "recitation_code": "df . Module . init ( self )", "input_code_id": 88085, "input": "<s> import DeepFried2 as df <EOL> class Reshape ( df . Module ) : <EOL> def __init__ ( self , * new_shape ) : <EOL>"}
{"rec_id": "1373", "recitation_code": "def test im func ( self ) :", "input_code_id": 1373, "input": "<s> from test import test_support <EOL> import types <EOL> import unittest <EOL> class FuncAttrsTest ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> class F : <EOL> def a ( self ) : <EOL> pass <EOL> def b ( ) : <EOL> return <NUM_LIT:3> <EOL> self . f = F <EOL> self . fi = F ( ) <EOL> self . b = b <EOL> def cannot_set_attr ( self , obj , name , value , exceptions ) : <EOL> try : <EOL> setattr ( obj , name , value ) <EOL> except exceptions : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" % ( name , value ) ) <EOL> try : <EOL> delattr ( obj , name ) <EOL> except exceptions : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" % name ) <EOL> class FunctionPropertiesTest ( FuncAttrsTest ) : <EOL> def test_module ( self ) : <EOL> self . assertEqual ( self . b . __module__ , __name__ ) <EOL> def test_dir_includes_correct_attrs ( self ) : <EOL> self . b . known_attr = <NUM_LIT:7> <EOL> self . assertIn ( '<STR_LIT>' , dir ( self . b ) , <EOL> \"<STR_LIT>\" ) <EOL> self . f . a . im_func . known_attr = <NUM_LIT:7> <EOL> self . assertIn ( '<STR_LIT>' , dir ( self . f . a ) , <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> self . assertIn ( '<STR_LIT>' , dir ( self . fi . a ) , <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> def test_duplicate_function_equality ( self ) : <EOL> def duplicate ( ) : <EOL> '<STR_LIT>' <EOL> return <NUM_LIT:3> <EOL> self . assertNotEqual ( self . b , duplicate ) <EOL> @ unittest . skipIf ( test_support . is_jython , \"<STR_LIT>\" ) <EOL> def test_copying_func_code ( self ) : <EOL> def test ( ) : pass <EOL> self . assertEqual ( test ( ) , None ) <EOL> test . func_code = self . b . func_code <EOL> self . assertEqual ( test ( ) , <NUM_LIT:3> ) <EOL> @ unittest . skipIf ( test_support . is_jython , \"<STR_LIT>\" ) <EOL> def test_func_globals ( self ) : <EOL> self . assertIs ( self . b . func_globals , globals ( ) ) <EOL> self . cannot_set_attr ( self . b , '<STR_LIT>' , <NUM_LIT:2> , TypeError ) <EOL> @ unittest . skipIf ( test_support . is_jython , \"<STR_LIT>\" ) <EOL> def test_func_closure ( self ) : <EOL> a = <NUM_LIT:12> <EOL> def f ( ) : print a <EOL> c = f . func_closure <EOL> self . assertIsInstance ( c , tuple ) <EOL> self . assertEqual ( len ( c ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( c [ <NUM_LIT:0> ] . __class__ . __name__ , \"<STR_LIT>\" ) <EOL> self . cannot_set_attr ( f , \"<STR_LIT>\" , c , TypeError ) <EOL> def test_empty_cell ( self ) : <EOL> def f ( ) : print a <EOL> try : <EOL> f . func_closure [ <NUM_LIT:0> ] . cell_contents <EOL> except ValueError : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" ) <EOL> a = <NUM_LIT:12> <EOL> @ unittest . skipIf ( test_support . is_jython , \"<STR_LIT>\" ) <EOL> def test_func_name ( self ) : <EOL> self . assertEqual ( self . b . __name__ , '<STR_LIT:b>' ) <EOL> self . assertEqual ( self . b . func_name , '<STR_LIT:b>' ) <EOL> self . b . __name__ = '<STR_LIT:c>' <EOL> self . assertEqual ( self . b . __name__ , '<STR_LIT:c>' ) <EOL> self . assertEqual ( self . b . func_name , '<STR_LIT:c>' ) <EOL> self . b . func_name = '<STR_LIT:d>' <EOL> self . assertEqual ( self . b . __name__ , '<STR_LIT:d>' ) <EOL> self . assertEqual ( self . b . func_name , '<STR_LIT:d>' ) <EOL> self . cannot_set_attr ( self . b , '<STR_LIT>' , <NUM_LIT:7> , TypeError ) <EOL> self . cannot_set_attr ( self . b , '<STR_LIT>' , <NUM_LIT:7> , TypeError ) <EOL> s = \"\"\"<STR_LIT>\"\"\" <EOL> exec s in { '<STR_LIT>' : { } } <EOL> self . assertEqual ( self . f . a . __name__ , '<STR_LIT:a>' ) <EOL> self . assertEqual ( self . fi . a . __name__ , '<STR_LIT:a>' ) <EOL> self . cannot_set_attr ( self . f . a , \"<STR_LIT>\" , '<STR_LIT:a>' , AttributeError ) <EOL> self . cannot_set_attr ( self . fi . a , \"<STR_LIT>\" , '<STR_LIT:a>' , AttributeError ) <EOL> @ unittest . skipIf ( test_support . is_jython , \"<STR_LIT>\" ) <EOL> def test_func_code ( self ) : <EOL> num_one , num_two = <NUM_LIT:7> , <NUM_LIT:8> <EOL> def a ( ) : pass <EOL> def b ( ) : return <NUM_LIT:12> <EOL> def c ( ) : return num_one <EOL> def d ( ) : return num_two <EOL> def e ( ) : return num_one , num_two <EOL> for func in [ a , b , c , d , e ] : <EOL> self . assertEqual ( type ( func . func_code ) , types . CodeType ) <EOL> self . assertEqual ( c ( ) , <NUM_LIT:7> ) <EOL> self . assertEqual ( d ( ) , <NUM_LIT:8> ) <EOL> d . func_code = c . func_code <EOL> self . assertEqual ( c . func_code , d . func_code ) <EOL> self . assertEqual ( c ( ) , <NUM_LIT:7> ) <EOL> try : <EOL> b . func_code = c . func_code <EOL> except ValueError : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> try : <EOL> e . func_code = d . func_code <EOL> except ValueError : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> def test_blank_func_defaults ( self ) : <EOL> self . assertEqual ( self . b . func_defaults , None ) <EOL> del self . b . func_defaults <EOL> self . assertEqual ( self . b . func_defaults , None ) <EOL> def test_func_default_args ( self ) : <EOL> def first_func ( a , b ) : <EOL> return a + b <EOL> def second_func ( a = <NUM_LIT:1> , b = <NUM_LIT:2> ) : <EOL> return a + b <EOL> self . assertEqual ( first_func . func_defaults , None ) <EOL> self . assertEqual ( second_func . func_defaults , ( <NUM_LIT:1> , <NUM_LIT:2> ) ) <EOL> first_func . func_defaults = ( <NUM_LIT:1> , <NUM_LIT:2> ) <EOL> self . assertEqual ( first_func . func_defaults , ( <NUM_LIT:1> , <NUM_LIT:2> ) ) <EOL> self . assertEqual ( first_func ( ) , <NUM_LIT:3> ) <EOL> self . assertEqual ( first_func ( <NUM_LIT:3> ) , <NUM_LIT:5> ) <EOL> self . assertEqual ( first_func ( <NUM_LIT:3> , <NUM_LIT:5> ) , <NUM_LIT:8> ) <EOL> del second_func . func_defaults <EOL> self . assertEqual ( second_func . func_defaults , None ) <EOL> try : <EOL> second_func ( ) <EOL> except TypeError : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> class InstancemethodAttrTest ( FuncAttrsTest ) : <EOL> def test_im_class ( self ) : <EOL> self . assertEqual ( self . f . a . im_class , self . f ) <EOL> self . assertEqual ( self . fi . a . im_class , self . f ) <EOL>"}
{"rec_id": "1373", "recitation_code": "def test im func ( self ) :", "input_code_id": 7681, "input": "<s> from test import test_support <EOL> import types <EOL> import unittest <EOL> class FuncAttrsTest ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> class F : <EOL> def a ( self ) : <EOL> pass <EOL> def b ( ) : <EOL> return <NUM_LIT:3> <EOL> self . f = F <EOL> self . fi = F ( ) <EOL> self . b = b <EOL> def cannot_set_attr ( self , obj , name , value , exceptions ) : <EOL> try : <EOL> setattr ( obj , name , value ) <EOL> except exceptions : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" % ( name , value ) ) <EOL> try : <EOL> delattr ( obj , name ) <EOL> except exceptions : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" % name ) <EOL> class FunctionPropertiesTest ( FuncAttrsTest ) : <EOL> def test_module ( self ) : <EOL> self . assertEqual ( self . b . __module__ , __name__ ) <EOL> def test_dir_includes_correct_attrs ( self ) : <EOL> self . b . known_attr = <NUM_LIT:7> <EOL> self . assertIn ( '<STR_LIT>' , dir ( self . b ) , <EOL> \"<STR_LIT>\" ) <EOL> self . f . a . im_func . known_attr = <NUM_LIT:7> <EOL> self . assertIn ( '<STR_LIT>' , dir ( self . f . a ) , <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> self . assertIn ( '<STR_LIT>' , dir ( self . fi . a ) , <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> def test_duplicate_function_equality ( self ) : <EOL> def duplicate ( ) : <EOL> '<STR_LIT>' <EOL> return <NUM_LIT:3> <EOL> self . assertNotEqual ( self . b , duplicate ) <EOL> def test_copying_func_code ( self ) : <EOL> def test ( ) : pass <EOL> self . assertEqual ( test ( ) , None ) <EOL> test . func_code = self . b . func_code <EOL> self . assertEqual ( test ( ) , <NUM_LIT:3> ) <EOL> def test_func_globals ( self ) : <EOL> self . assertIs ( self . b . func_globals , globals ( ) ) <EOL> self . cannot_set_attr ( self . b , '<STR_LIT>' , <NUM_LIT:2> , TypeError ) <EOL> def test_func_closure ( self ) : <EOL> a = <NUM_LIT:12> <EOL> def f ( ) : print a <EOL> c = f . func_closure <EOL> self . assertIsInstance ( c , tuple ) <EOL> self . assertEqual ( len ( c ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( c [ <NUM_LIT:0> ] . __class__ . __name__ , \"<STR_LIT>\" ) <EOL> self . cannot_set_attr ( f , \"<STR_LIT>\" , c , TypeError ) <EOL> def test_empty_cell ( self ) : <EOL> def f ( ) : print a <EOL> try : <EOL> f . func_closure [ <NUM_LIT:0> ] . cell_contents <EOL> except ValueError : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" ) <EOL> a = <NUM_LIT:12> <EOL> def test_func_name ( self ) : <EOL> self . assertEqual ( self . b . __name__ , '<STR_LIT:b>' ) <EOL> self . assertEqual ( self . b . func_name , '<STR_LIT:b>' ) <EOL> self . b . __name__ = '<STR_LIT:c>' <EOL> self . assertEqual ( self . b . __name__ , '<STR_LIT:c>' ) <EOL> self . assertEqual ( self . b . func_name , '<STR_LIT:c>' ) <EOL> self . b . func_name = '<STR_LIT:d>' <EOL> self . assertEqual ( self . b . __name__ , '<STR_LIT:d>' ) <EOL> self . assertEqual ( self . b . func_name , '<STR_LIT:d>' ) <EOL> self . cannot_set_attr ( self . b , '<STR_LIT>' , <NUM_LIT:7> , TypeError ) <EOL> self . cannot_set_attr ( self . b , '<STR_LIT>' , <NUM_LIT:7> , TypeError ) <EOL> s = \"\"\"<STR_LIT>\"\"\" <EOL> exec s in { '<STR_LIT>' : { } } <EOL> self . assertEqual ( self . f . a . __name__ , '<STR_LIT:a>' ) <EOL> self . assertEqual ( self . fi . a . __name__ , '<STR_LIT:a>' ) <EOL> self . cannot_set_attr ( self . f . a , \"<STR_LIT>\" , '<STR_LIT:a>' , AttributeError ) <EOL> self . cannot_set_attr ( self . fi . a , \"<STR_LIT>\" , '<STR_LIT:a>' , AttributeError ) <EOL> def test_func_code ( self ) : <EOL> num_one , num_two = <NUM_LIT:7> , <NUM_LIT:8> <EOL> def a ( ) : pass <EOL> def b ( ) : return <NUM_LIT:12> <EOL> def c ( ) : return num_one <EOL> def d ( ) : return num_two <EOL> def e ( ) : return num_one , num_two <EOL> for func in [ a , b , c , d , e ] : <EOL> self . assertEqual ( type ( func . func_code ) , types . CodeType ) <EOL> self . assertEqual ( c ( ) , <NUM_LIT:7> ) <EOL> self . assertEqual ( d ( ) , <NUM_LIT:8> ) <EOL> d . func_code = c . func_code <EOL> self . assertEqual ( c . func_code , d . func_code ) <EOL> self . assertEqual ( c ( ) , <NUM_LIT:7> ) <EOL> try : <EOL> b . func_code = c . func_code <EOL> except ValueError : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> try : <EOL> e . func_code = d . func_code <EOL> except ValueError : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> def test_blank_func_defaults ( self ) : <EOL> self . assertEqual ( self . b . func_defaults , None ) <EOL> del self . b . func_defaults <EOL> self . assertEqual ( self . b . func_defaults , None ) <EOL> def test_func_default_args ( self ) : <EOL> def first_func ( a , b ) : <EOL> return a + b <EOL> def second_func ( a = <NUM_LIT:1> , b = <NUM_LIT:2> ) : <EOL> return a + b <EOL> self . assertEqual ( first_func . func_defaults , None ) <EOL> self . assertEqual ( second_func . func_defaults , ( <NUM_LIT:1> , <NUM_LIT:2> ) ) <EOL> first_func . func_defaults = ( <NUM_LIT:1> , <NUM_LIT:2> ) <EOL> self . assertEqual ( first_func . func_defaults , ( <NUM_LIT:1> , <NUM_LIT:2> ) ) <EOL> self . assertEqual ( first_func ( ) , <NUM_LIT:3> ) <EOL> self . assertEqual ( first_func ( <NUM_LIT:3> ) , <NUM_LIT:5> ) <EOL> self . assertEqual ( first_func ( <NUM_LIT:3> , <NUM_LIT:5> ) , <NUM_LIT:8> ) <EOL> del second_func . func_defaults <EOL> self . assertEqual ( second_func . func_defaults , None ) <EOL> try : <EOL> second_func ( ) <EOL> except TypeError : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> class InstancemethodAttrTest ( FuncAttrsTest ) : <EOL> def test_im_class ( self ) : <EOL> self . assertEqual ( self . f . a . im_class , self . f ) <EOL> self . assertEqual ( self . fi . a . im_class , self . f ) <EOL> self . cannot_set_attr ( self . f . a , \"<STR_LIT>\" , self . f , TypeError ) <EOL> self . cannot_set_attr ( self . fi . a , \"<STR_LIT>\" , self . f , TypeError ) <EOL>"}
{"rec_id": "1373", "recitation_code": "def test im func ( self ) :", "input_code_id": 65598, "input": "<s> from test import test_support <EOL> import types <EOL> import unittest <EOL> class FuncAttrsTest ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> class F : <EOL> def a ( self ) : <EOL> pass <EOL> def b ( ) : <EOL> return <NUM_LIT:3> <EOL> self . f = F <EOL> self . fi = F ( ) <EOL> self . b = b <EOL> def cannot_set_attr ( self , obj , name , value , exceptions ) : <EOL> try : <EOL> setattr ( obj , name , value ) <EOL> except exceptions : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" % ( name , value ) ) <EOL> try : <EOL> delattr ( obj , name ) <EOL> except exceptions : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" % name ) <EOL> class FunctionPropertiesTest ( FuncAttrsTest ) : <EOL> def test_module ( self ) : <EOL> self . assertEqual ( self . b . __module__ , __name__ ) <EOL> def test_dir_includes_correct_attrs ( self ) : <EOL> self . b . known_attr = <NUM_LIT:7> <EOL> self . assertIn ( '<STR_LIT>' , dir ( self . b ) , <EOL> \"<STR_LIT>\" ) <EOL> self . f . a . im_func . known_attr = <NUM_LIT:7> <EOL> self . assertIn ( '<STR_LIT>' , dir ( self . f . a ) , <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> self . assertIn ( '<STR_LIT>' , dir ( self . fi . a ) , <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> def test_duplicate_function_equality ( self ) : <EOL> def duplicate ( ) : <EOL> '<STR_LIT>' <EOL> return <NUM_LIT:3> <EOL> self . assertNotEqual ( self . b , duplicate ) <EOL> def test_copying_func_code ( self ) : <EOL> def test ( ) : pass <EOL> self . assertEqual ( test ( ) , None ) <EOL> test . func_code = self . b . func_code <EOL> self . assertEqual ( test ( ) , <NUM_LIT:3> ) <EOL> def test_func_globals ( self ) : <EOL> self . assertIs ( self . b . func_globals , globals ( ) ) <EOL> self . cannot_set_attr ( self . b , '<STR_LIT>' , <NUM_LIT:2> , TypeError ) <EOL> def test_func_closure ( self ) : <EOL> a = <NUM_LIT:12> <EOL> def f ( ) : print a <EOL> c = f . func_closure <EOL> self . assertIsInstance ( c , tuple ) <EOL> self . assertEqual ( len ( c ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( c [ <NUM_LIT:0> ] . __class__ . __name__ , \"<STR_LIT>\" ) <EOL> self . cannot_set_attr ( f , \"<STR_LIT>\" , c , TypeError ) <EOL> def test_empty_cell ( self ) : <EOL> def f ( ) : print a <EOL> try : <EOL> f . func_closure [ <NUM_LIT:0> ] . cell_contents <EOL> except ValueError : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" ) <EOL> a = <NUM_LIT:12> <EOL> def test_func_name ( self ) : <EOL> self . assertEqual ( self . b . __name__ , '<STR_LIT:b>' ) <EOL> self . assertEqual ( self . b . func_name , '<STR_LIT:b>' ) <EOL> self . b . __name__ = '<STR_LIT:c>' <EOL> self . assertEqual ( self . b . __name__ , '<STR_LIT:c>' ) <EOL> self . assertEqual ( self . b . func_name , '<STR_LIT:c>' ) <EOL> self . b . func_name = '<STR_LIT:d>' <EOL> self . assertEqual ( self . b . __name__ , '<STR_LIT:d>' ) <EOL> self . assertEqual ( self . b . func_name , '<STR_LIT:d>' ) <EOL> self . cannot_set_attr ( self . b , '<STR_LIT>' , <NUM_LIT:7> , TypeError ) <EOL> self . cannot_set_attr ( self . b , '<STR_LIT>' , <NUM_LIT:7> , TypeError ) <EOL> s = \"\"\"<STR_LIT>\"\"\" <EOL> exec s in { '<STR_LIT>' : { } } <EOL> self . assertEqual ( self . f . a . __name__ , '<STR_LIT:a>' ) <EOL> self . assertEqual ( self . fi . a . __name__ , '<STR_LIT:a>' ) <EOL> self . cannot_set_attr ( self . f . a , \"<STR_LIT>\" , '<STR_LIT:a>' , AttributeError ) <EOL> self . cannot_set_attr ( self . fi . a , \"<STR_LIT>\" , '<STR_LIT:a>' , AttributeError ) <EOL> def test_func_code ( self ) : <EOL> num_one , num_two = <NUM_LIT:7> , <NUM_LIT:8> <EOL> def a ( ) : pass <EOL> def b ( ) : return <NUM_LIT:12> <EOL> def c ( ) : return num_one <EOL> def d ( ) : return num_two <EOL> def e ( ) : return num_one , num_two <EOL> for func in [ a , b , c , d , e ] : <EOL> self . assertEqual ( type ( func . func_code ) , types . CodeType ) <EOL> self . assertEqual ( c ( ) , <NUM_LIT:7> ) <EOL> self . assertEqual ( d ( ) , <NUM_LIT:8> ) <EOL> d . func_code = c . func_code <EOL> self . assertEqual ( c . func_code , d . func_code ) <EOL> self . assertEqual ( c ( ) , <NUM_LIT:7> ) <EOL> try : <EOL> b . func_code = c . func_code <EOL> except ValueError : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> try : <EOL> e . func_code = d . func_code <EOL> except ValueError : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> def test_blank_func_defaults ( self ) : <EOL> self . assertEqual ( self . b . func_defaults , None ) <EOL> del self . b . func_defaults <EOL> self . assertEqual ( self . b . func_defaults , None ) <EOL> def test_func_default_args ( self ) : <EOL> def first_func ( a , b ) : <EOL> return a + b <EOL> def second_func ( a = <NUM_LIT:1> , b = <NUM_LIT:2> ) : <EOL> return a + b <EOL> self . assertEqual ( first_func . func_defaults , None ) <EOL> self . assertEqual ( second_func . func_defaults , ( <NUM_LIT:1> , <NUM_LIT:2> ) ) <EOL> first_func . func_defaults = ( <NUM_LIT:1> , <NUM_LIT:2> ) <EOL> self . assertEqual ( first_func . func_defaults , ( <NUM_LIT:1> , <NUM_LIT:2> ) ) <EOL> self . assertEqual ( first_func ( ) , <NUM_LIT:3> ) <EOL> self . assertEqual ( first_func ( <NUM_LIT:3> ) , <NUM_LIT:5> ) <EOL> self . assertEqual ( first_func ( <NUM_LIT:3> , <NUM_LIT:5> ) , <NUM_LIT:8> ) <EOL> del second_func . func_defaults <EOL> self . assertEqual ( second_func . func_defaults , None ) <EOL> try : <EOL> second_func ( ) <EOL> except TypeError : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> class InstancemethodAttrTest ( FuncAttrsTest ) : <EOL> def test_im_class ( self ) : <EOL> self . assertEqual ( self . f . a . im_class , self . f ) <EOL> self . assertEqual ( self . fi . a . im_class , self . f ) <EOL> self . cannot_set_attr ( self . f . a , \"<STR_LIT>\" , self . f , TypeError ) <EOL> self . cannot_set_attr ( self . fi . a , \"<STR_LIT>\" , self . f , TypeError ) <EOL>"}
{"rec_id": "1460", "recitation_code": "VERSION INFO = ( VERSION MAJOR , VERSION MINOR , VERSION BUILD )", "input_code_id": 1460, "input": "<s> VERSION_MAJOR = <NUM_LIT:1> <EOL> VERSION_MINOR = <NUM_LIT:6> <EOL> VERSION_BUILD = <NUM_LIT:1> <EOL>"}
{"rec_id": "1460", "recitation_code": "VERSION INFO = ( VERSION MAJOR , VERSION MINOR , VERSION BUILD )", "input_code_id": 5243, "input": "<s> VERSION_MAJOR = <NUM_LIT:0> <EOL> VERSION_MINOR = <NUM_LIT:8> <EOL> VERSION_BUILD = <NUM_LIT:3> <EOL>"}
{"rec_id": "1460", "recitation_code": "VERSION INFO = ( VERSION MAJOR , VERSION MINOR , VERSION BUILD )", "input_code_id": 12110, "input": "<s> VERSION_MAJOR = <NUM_LIT:0> <EOL> VERSION_MINOR = <NUM_LIT:8> <EOL> VERSION_BUILD = <NUM_LIT:9> <EOL>"}
{"rec_id": "1460", "recitation_code": "VERSION INFO = ( VERSION MAJOR , VERSION MINOR , VERSION BUILD )", "input_code_id": 53763, "input": "<s> VERSION_MAJOR = <NUM_LIT:0> <EOL> VERSION_MINOR = <NUM_LIT:6> <EOL> VERSION_BUILD = <NUM_LIT:0> <EOL>"}
{"rec_id": "1552", "recitation_code": "def getElement ( self ) :", "input_code_id": 1552, "input": "<s> from pyjamas import DOM <EOL> from pyjamas import Factory <EOL> from pyjamas . ui . Widget import Widget <EOL> class Composite ( Widget ) : <EOL> def __init__ ( self , widget = None , ** kwargs ) : <EOL> self . widget = None <EOL> self . attached = None <EOL> if widget is not None : <EOL> self . initWidget ( widget ) <EOL> Widget . __init__ ( self , ** kwargs ) <EOL> def initWidget ( self , widget ) : <EOL> if self . widget is not None : <EOL> return <EOL> widget . removeFromParent ( ) <EOL> self . setElement ( widget . getElement ( ) ) <EOL> self . widget = widget <EOL>"}
{"rec_id": "1552", "recitation_code": "def getElement ( self ) :", "input_code_id": 73585, "input": "<s> from pyjamas import DOM <EOL> from pyjamas import Factory <EOL> from pyjamas import History <EOL> from pyjamas . ui . Widget import Widget <EOL> from pyjamas . ui import Event <EOL> from pyjamas . ui . ClickListener import ClickHandler <EOL> class Hyperlink ( Widget , ClickHandler ) : <EOL> def __init__ ( self , text = \"<STR_LIT>\" , asHTML = False , Element = None , ** kwargs ) : <EOL> if Element is None : <EOL> Element = DOM . createDiv ( ) <EOL> self . anchorElem = DOM . createAnchor ( ) <EOL> self . setElement ( Element ) <EOL> DOM . appendChild ( self . getElement ( ) , self . anchorElem ) <EOL> if not kwargs . has_key ( '<STR_LIT>' ) : kwargs [ '<STR_LIT>' ] = \"<STR_LIT>\" <EOL> if text : <EOL> if asHTML : <EOL> kwargs [ '<STR_LIT>' ] = text <EOL> else : <EOL> kwargs [ '<STR_LIT>' ] = text <EOL> if not kwargs . has_key ( '<STR_LIT>' ) : <EOL> kwargs [ '<STR_LIT>' ] = None <EOL> Widget . __init__ ( self , ** kwargs ) <EOL> ClickHandler . __init__ ( self ) <EOL>"}
{"rec_id": "1594", "recitation_code": "def featured ( self ) :", "input_code_id": 1594, "input": "<s> from django . db import models <EOL> from . import enums <EOL> class ProductQuerySet ( models . QuerySet ) : <EOL> def active ( self ) : <EOL> return self . filter ( active = True ) <EOL>"}
{"rec_id": "1594", "recitation_code": "def featured ( self ) :", "input_code_id": 69562, "input": "<s> from django . db . models . query import QuerySet <EOL> class SponsorQuerySet ( QuerySet ) : <EOL> def draft ( self ) : <EOL> return self . filter ( is_published = False ) <EOL>"}
{"rec_id": "1626", "recitation_code": "self . setObjectName ( \" \" )", "input_code_id": 1626, "input": "<s> import sys <EOL> try : <EOL> from PySide import QtGui <EOL> except ImportError : <EOL> from PyQt4 import QtGui <EOL> from add_group import Ui_Form <EOL> class Demo ( QtGui . QWidget , Ui_Form ) : <EOL> def __init__ ( self , parent = None ) : <EOL> super ( Demo , self ) . __init__ ( parent ) <EOL>"}
{"rec_id": "1626", "recitation_code": "self . setObjectName ( \" \" )", "input_code_id": 70306, "input": "<s> import sys <EOL> try : <EOL> from PySide import QtCore <EOL> from PySide import QtGui <EOL> except ImportError : <EOL> from PyQt4 import QtCore <EOL> from PyQt4 import QtGui <EOL> class Example ( QtGui . QWidget ) : <EOL> def __init__ ( self ) : <EOL> super ( Example , self ) . __init__ ( ) <EOL>"}
{"rec_id": "1687", "recitation_code": "def remove ( x ) :", "input_code_id": 1687, "input": "<s> import os <EOL> import time <EOL> from datetime import datetime <EOL> from celery import Celery <EOL> celery = Celery ( \"<STR_LIT>\" , broker = \"<STR_LIT>\" ) <EOL> celery . conf . CELERY_RESULT_BACKEND = os . environ . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> @ celery . task <EOL> def add ( x , y ) : <EOL> return int ( x ) + int ( y ) <EOL> @ celery . task <EOL>"}
{"rec_id": "1687", "recitation_code": "def remove ( x ) :", "input_code_id": 77521, "input": "<s> from mead import app <EOL> from mead . core . models . content import Page , db <EOL> def add ( x ) : <EOL> db . session . add ( x ) <EOL> db . session . commit ( ) <EOL> db . create_all ( ) <EOL>"}
{"rec_id": "1711", "recitation_code": "return TableMainFeaturesExample ( )", "input_code_id": 297, "input": "<s> from muntjac . ui . table import Table <EOL> from muntjac . demo . sampler . features . table . TableMainFeaturesExample import TableMainFeaturesExample <EOL> from muntjac . demo . sampler . APIResource import APIResource <EOL> from muntjac . demo . sampler . Feature import Feature , Version <EOL> class TableColumnAlignment ( Feature ) : <EOL> def getSinceVersion ( self ) : <EOL> return Version . OLD <EOL> def getName ( self ) : <EOL> return '<STR_LIT>' <EOL> def getExample ( self ) : <EOL>"}
{"rec_id": "1711", "recitation_code": "return TableMainFeaturesExample ( )", "input_code_id": 1711, "input": "<s> from muntjac . ui . table import Table <EOL> from muntjac . demo . sampler . features . table . TableMainFeaturesExample import TableMainFeaturesExample <EOL> from muntjac . demo . sampler . APIResource import APIResource <EOL> from muntjac . demo . sampler . Feature import Feature , Version <EOL> class TableColumnHeaders ( Feature ) : <EOL> def getSinceVersion ( self ) : <EOL> return Version . OLD <EOL> def getName ( self ) : <EOL> return '<STR_LIT>' <EOL> def getExample ( self ) : <EOL>"}
{"rec_id": "1711", "recitation_code": "return TableMainFeaturesExample ( )", "input_code_id": 29201, "input": "<s> from muntjac . ui . table import Table <EOL> from muntjac . demo . sampler . features . table . TableMainFeaturesExample import TableMainFeaturesExample <EOL> from muntjac . demo . sampler . APIResource import APIResource <EOL> from muntjac . demo . sampler . Feature import Feature , Version <EOL> class TableActions ( Feature ) : <EOL> def getSinceVersion ( self ) : <EOL> return Version . OLD <EOL> def getName ( self ) : <EOL> return '<STR_LIT>' <EOL> def getExample ( self ) : <EOL>"}
{"rec_id": "1711", "recitation_code": "return TableMainFeaturesExample ( )", "input_code_id": 39476, "input": "<s> from muntjac . ui . table import Table <EOL> from muntjac . demo . sampler . features . table . TableMainFeaturesExample import TableMainFeaturesExample <EOL> from muntjac . demo . sampler . APIResource import APIResource <EOL> from muntjac . demo . sampler . Feature import Feature , Version <EOL> class TableRowHeaders ( Feature ) : <EOL> def getSinceVersion ( self ) : <EOL> return Version . OLD <EOL> def getName ( self ) : <EOL> return '<STR_LIT>' <EOL> def getExample ( self ) : <EOL>"}
{"rec_id": "1755", "recitation_code": "def get by name ( cls , name ) :", "input_code_id": 1755, "input": "<s> import copy <EOL> from pecan import core <EOL> from wsme import types as wtypes <EOL> from solum . api . controllers . camp . v1_1 import uris <EOL> from solum . api . controllers . v1 . datamodel import types as api_types <EOL> class AttributeDefinition ( api_types . Base ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> documentation = wtypes . text <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> attribute_type = wtypes . text <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ classmethod <EOL>"}
{"rec_id": "1755", "recitation_code": "def get by name ( cls , name ) :", "input_code_id": 1512, "input": "<s> from st2common . persistence import base <EOL> from st2common . models . db . rbac import role_access <EOL> from st2common . models . db . rbac import user_role_assignment_access <EOL> from st2common . models . db . rbac import permission_grant_access <EOL> __all__ = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> class Role ( base . Access ) : <EOL> impl = role_access <EOL> @ classmethod <EOL>"}
{"rec_id": "1786", "recitation_code": "transport = transport ,", "input_code_id": 1786, "input": "<s> import collections <EOL> import threading <EOL> import kombu <EOL> from kombu import exceptions as kombu_exceptions <EOL> import six <EOL> from taskflow . engines . worker_based import dispatcher <EOL> from taskflow import logging <EOL> LOG = logging . getLogger ( __name__ ) <EOL> DRAIN_EVENTS_PERIOD = <NUM_LIT:1> <EOL> _ConnectionDetails = collections . namedtuple ( '<STR_LIT>' , <EOL> [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> _TransportDetails = collections . namedtuple ( '<STR_LIT>' , <EOL> [ '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> class Proxy ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> DEFAULT_RETRY_OPTIONS = { <EOL> '<STR_LIT>' : <NUM_LIT:1> , <EOL> '<STR_LIT>' : <NUM_LIT:1> , <EOL> '<STR_LIT>' : <NUM_LIT:1> , <EOL> '<STR_LIT>' : <NUM_LIT:3> , <EOL> } <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _RETRY_INT_OPTS = frozenset ( [ '<STR_LIT>' ] ) <EOL> def __init__ ( self , topic , exchange , <EOL> type_handlers = None , on_wait = None , url = None , <EOL> transport = None , transport_options = None , <EOL> retry_options = None ) : <EOL> self . _topic = topic <EOL> self . _exchange_name = exchange <EOL> self . _on_wait = on_wait <EOL> self . _running = threading . Event ( ) <EOL> self . _dispatcher = dispatcher . TypeDispatcher ( <EOL> requeue_filters = [ lambda data , message : not self . is_running ] , <EOL> type_handlers = type_handlers ) <EOL> ensure_options = self . DEFAULT_RETRY_OPTIONS . copy ( ) <EOL> if retry_options is not None : <EOL> for k in set ( six . iterkeys ( ensure_options ) ) : <EOL> if k in retry_options : <EOL> val = retry_options [ k ] <EOL> if k in self . _RETRY_INT_OPTS : <EOL> tmp_val = int ( val ) <EOL> else : <EOL> tmp_val = float ( val ) <EOL> if tmp_val < <NUM_LIT:0> : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % ( k , val ) ) <EOL> ensure_options [ k ] = tmp_val <EOL> self . _ensure_options = ensure_options <EOL> self . _drain_events_timeout = DRAIN_EVENTS_PERIOD <EOL> if transport == '<STR_LIT>' and transport_options : <EOL> polling_interval = transport_options . get ( '<STR_LIT>' ) <EOL> if polling_interval is not None : <EOL> self . _drain_events_timeout = polling_interval <EOL> self . _conn = kombu . Connection ( url , transport = transport , <EOL> transport_options = transport_options ) <EOL> self . _exchange = kombu . Exchange ( name = self . _exchange_name , <EOL> durable = False , auto_delete = True ) <EOL> @ property <EOL> def dispatcher ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _dispatcher <EOL> @ property <EOL> def connection_details ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> driver_version = self . _conn . transport . driver_version ( ) <EOL> if driver_version and driver_version . lower ( ) == '<STR_LIT>' : <EOL> driver_version = None <EOL> if self . _conn . transport_options : <EOL> transport_options = self . _conn . transport_options . copy ( ) <EOL> else : <EOL> transport_options = { } <EOL> transport = _TransportDetails ( <EOL> options = transport_options , <EOL> driver_type = self . _conn . transport . driver_type , <EOL> driver_name = self . _conn . transport . driver_name , <EOL> driver_version = driver_version ) <EOL> return _ConnectionDetails ( <EOL>"}
{"rec_id": "1786", "recitation_code": "transport = transport ,", "input_code_id": 55950, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import logging <EOL> import random <EOL> import time <EOL> import ganeti . rpc . client as cl <EOL> import ganeti . rpc . stub . wconfd as stub <EOL> from ganeti . rpc . transport import Transport <EOL> from ganeti . rpc import errors <EOL> class Client ( cl . AbstractStubClient , stub . ClientRpcStub ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , timeouts = None , transport = Transport , allow_non_master = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> cl . AbstractStubClient . __init__ ( self , <EOL> timeouts = timeouts , <EOL>"}
{"rec_id": "1809", "recitation_code": "class PollableWritePipe ( PollableResource ) :", "input_code_id": 1809, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from zope . interface import implementer <EOL> from twisted . internet . interfaces import IConsumer , IPushProducer <EOL> MIN_TIMEOUT = <NUM_LIT> <EOL> MAX_TIMEOUT = <NUM_LIT:0.1> <EOL> class _PollableResource : <EOL> active = True <EOL> def activate ( self ) : <EOL> self . active = True <EOL> def deactivate ( self ) : <EOL> self . active = False <EOL> class _PollingTimer : <EOL> def __init__ ( self , reactor ) : <EOL> self . reactor = reactor <EOL> self . _resources = [ ] <EOL> self . _pollTimer = None <EOL> self . _currentTimeout = MAX_TIMEOUT <EOL> self . _paused = False <EOL> def _addPollableResource ( self , res ) : <EOL> self . _resources . append ( res ) <EOL> self . _checkPollingState ( ) <EOL> def _checkPollingState ( self ) : <EOL> for resource in self . _resources : <EOL> if resource . active : <EOL> self . _startPolling ( ) <EOL> break <EOL> else : <EOL> self . _stopPolling ( ) <EOL> def _startPolling ( self ) : <EOL> if self . _pollTimer is None : <EOL> self . _pollTimer = self . _reschedule ( ) <EOL> def _stopPolling ( self ) : <EOL> if self . _pollTimer is not None : <EOL> self . _pollTimer . cancel ( ) <EOL> self . _pollTimer = None <EOL> def _pause ( self ) : <EOL> self . _paused = True <EOL> def _unpause ( self ) : <EOL> self . _paused = False <EOL> self . _checkPollingState ( ) <EOL> def _reschedule ( self ) : <EOL> if not self . _paused : <EOL> return self . reactor . callLater ( self . _currentTimeout , self . _pollEvent ) <EOL> def _pollEvent ( self ) : <EOL> workUnits = <NUM_LIT:0.> <EOL> anyActive = [ ] <EOL> for resource in self . _resources : <EOL> if resource . active : <EOL> workUnits += resource . checkWork ( ) <EOL> if resource . active : <EOL> anyActive . append ( resource ) <EOL> newTimeout = self . _currentTimeout <EOL> if workUnits : <EOL> newTimeout = self . _currentTimeout / ( workUnits + <NUM_LIT:1.> ) <EOL> if newTimeout < MIN_TIMEOUT : <EOL> newTimeout = MIN_TIMEOUT <EOL> else : <EOL> newTimeout = self . _currentTimeout * <NUM_LIT> <EOL> if newTimeout > MAX_TIMEOUT : <EOL> newTimeout = MAX_TIMEOUT <EOL> self . _currentTimeout = newTimeout <EOL> if anyActive : <EOL> self . _pollTimer = self . _reschedule ( ) <EOL> import win32pipe <EOL> import win32file <EOL> import win32api <EOL> import pywintypes <EOL> @ implementer ( IPushProducer ) <EOL> class _PollableReadPipe ( _PollableResource ) : <EOL> def __init__ ( self , pipe , receivedCallback , lostCallback ) : <EOL> self . pipe = pipe <EOL> self . receivedCallback = receivedCallback <EOL> self . lostCallback = lostCallback <EOL> def checkWork ( self ) : <EOL> finished = <NUM_LIT:0> <EOL> fullDataRead = [ ] <EOL> while <NUM_LIT:1> : <EOL> try : <EOL> buffer , bytesToRead , result = win32pipe . PeekNamedPipe ( self . pipe , <NUM_LIT:1> ) <EOL> if not bytesToRead : <EOL> break <EOL> hr , data = win32file . ReadFile ( self . pipe , bytesToRead , None ) <EOL> fullDataRead . append ( data ) <EOL> except win32api . error : <EOL> finished = <NUM_LIT:1> <EOL> break <EOL> dataBuf = '<STR_LIT>' . join ( fullDataRead ) <EOL> if dataBuf : <EOL> self . receivedCallback ( dataBuf ) <EOL> if finished : <EOL> self . cleanup ( ) <EOL> return len ( dataBuf ) <EOL> def cleanup ( self ) : <EOL> self . deactivate ( ) <EOL> self . lostCallback ( ) <EOL> def close ( self ) : <EOL> try : <EOL> win32api . CloseHandle ( self . pipe ) <EOL> except pywintypes . error : <EOL> pass <EOL> def stopProducing ( self ) : <EOL> self . close ( ) <EOL>"}
{"rec_id": "1809", "recitation_code": "class PollableWritePipe ( PollableResource ) :", "input_code_id": 37944, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from zope . interface import implements <EOL> from twisted . internet . interfaces import IConsumer , IPushProducer <EOL> MIN_TIMEOUT = <NUM_LIT> <EOL> MAX_TIMEOUT = <NUM_LIT:0.1> <EOL> class _PollableResource : <EOL> active = True <EOL> def activate ( self ) : <EOL> self . active = True <EOL> def deactivate ( self ) : <EOL> self . active = False <EOL> class _PollingTimer : <EOL> def __init__ ( self , reactor ) : <EOL> self . reactor = reactor <EOL> self . _resources = [ ] <EOL> self . _pollTimer = None <EOL> self . _currentTimeout = MAX_TIMEOUT <EOL> self . _paused = False <EOL> def _addPollableResource ( self , res ) : <EOL> self . _resources . append ( res ) <EOL> self . _checkPollingState ( ) <EOL> def _checkPollingState ( self ) : <EOL> for resource in self . _resources : <EOL> if resource . active : <EOL> self . _startPolling ( ) <EOL> break <EOL> else : <EOL> self . _stopPolling ( ) <EOL> def _startPolling ( self ) : <EOL> if self . _pollTimer is None : <EOL> self . _pollTimer = self . _reschedule ( ) <EOL> def _stopPolling ( self ) : <EOL> if self . _pollTimer is not None : <EOL> self . _pollTimer . cancel ( ) <EOL> self . _pollTimer = None <EOL> def _pause ( self ) : <EOL> self . _paused = True <EOL> def _unpause ( self ) : <EOL> self . _paused = False <EOL> self . _checkPollingState ( ) <EOL> def _reschedule ( self ) : <EOL> if not self . _paused : <EOL> return self . reactor . callLater ( self . _currentTimeout , self . _pollEvent ) <EOL> def _pollEvent ( self ) : <EOL> workUnits = <NUM_LIT:0.> <EOL> anyActive = [ ] <EOL> for resource in self . _resources : <EOL> if resource . active : <EOL> workUnits += resource . checkWork ( ) <EOL> if resource . active : <EOL> anyActive . append ( resource ) <EOL> newTimeout = self . _currentTimeout <EOL> if workUnits : <EOL> newTimeout = self . _currentTimeout / ( workUnits + <NUM_LIT:1.> ) <EOL> if newTimeout < MIN_TIMEOUT : <EOL> newTimeout = MIN_TIMEOUT <EOL> else : <EOL> newTimeout = self . _currentTimeout * <NUM_LIT> <EOL> if newTimeout > MAX_TIMEOUT : <EOL> newTimeout = MAX_TIMEOUT <EOL> self . _currentTimeout = newTimeout <EOL> if anyActive : <EOL> self . _pollTimer = self . _reschedule ( ) <EOL> import win32pipe <EOL> import win32file <EOL> import win32api <EOL> import pywintypes <EOL> class _PollableReadPipe ( _PollableResource ) : <EOL> implements ( IPushProducer ) <EOL> def __init__ ( self , pipe , receivedCallback , lostCallback ) : <EOL> self . pipe = pipe <EOL> self . receivedCallback = receivedCallback <EOL> self . lostCallback = lostCallback <EOL> def checkWork ( self ) : <EOL> finished = <NUM_LIT:0> <EOL> fullDataRead = [ ] <EOL> while <NUM_LIT:1> : <EOL> try : <EOL> buffer , bytesToRead , result = win32pipe . PeekNamedPipe ( self . pipe , <NUM_LIT:1> ) <EOL> if not bytesToRead : <EOL> break <EOL> hr , data = win32file . ReadFile ( self . pipe , bytesToRead , None ) <EOL> fullDataRead . append ( data ) <EOL> except win32api . error : <EOL> finished = <NUM_LIT:1> <EOL> break <EOL> dataBuf = '<STR_LIT>' . join ( fullDataRead ) <EOL> if dataBuf : <EOL> self . receivedCallback ( dataBuf ) <EOL> if finished : <EOL> self . cleanup ( ) <EOL> return len ( dataBuf ) <EOL> def cleanup ( self ) : <EOL> self . deactivate ( ) <EOL> self . lostCallback ( ) <EOL> def close ( self ) : <EOL> try : <EOL> win32api . CloseHandle ( self . pipe ) <EOL> except pywintypes . error : <EOL> pass <EOL> def stopProducing ( self ) : <EOL> self . close ( ) <EOL>"}
{"rec_id": "1826", "recitation_code": "self . formatter . end paragraph ( not self . list stack )", "input_code_id": 1826, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from warnings import warnpy3k <EOL> warnpy3k ( \"<STR_LIT>\" , <EOL> stacklevel = <NUM_LIT:2> ) <EOL> del warnpy3k <EOL> import sgmllib <EOL> from formatter import AS_IS <EOL> __all__ = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> class HTMLParseError ( sgmllib . SGMLParseError ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class HTMLParser ( sgmllib . SGMLParser ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from htmlentitydefs import entitydefs <EOL> def __init__ ( self , formatter , verbose = <NUM_LIT:0> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> sgmllib . SGMLParser . __init__ ( self , verbose ) <EOL> self . formatter = formatter <EOL> def error ( self , message ) : <EOL> raise HTMLParseError ( message ) <EOL> def reset ( self ) : <EOL> sgmllib . SGMLParser . reset ( self ) <EOL> self . savedata = None <EOL> self . isindex = <NUM_LIT:0> <EOL> self . title = None <EOL> self . base = None <EOL> self . anchor = None <EOL> self . anchorlist = [ ] <EOL> self . nofill = <NUM_LIT:0> <EOL> self . list_stack = [ ] <EOL> def handle_data ( self , data ) : <EOL> if self . savedata is not None : <EOL> self . savedata = self . savedata + data <EOL> else : <EOL> if self . nofill : <EOL> self . formatter . add_literal_data ( data ) <EOL> else : <EOL> self . formatter . add_flowing_data ( data ) <EOL> def save_bgn ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . savedata = '<STR_LIT>' <EOL> def save_end ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> data = self . savedata <EOL> self . savedata = None <EOL> if not self . nofill : <EOL> data = '<STR_LIT:U+0020>' . join ( data . split ( ) ) <EOL> return data <EOL> def anchor_bgn ( self , href , name , type ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . anchor = href <EOL> if self . anchor : <EOL> self . anchorlist . append ( href ) <EOL> def anchor_end ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . anchor : <EOL> self . handle_data ( \"<STR_LIT>\" % len ( self . anchorlist ) ) <EOL> self . anchor = None <EOL> def handle_image ( self , src , alt , * args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . handle_data ( alt ) <EOL> def start_html ( self , attrs ) : pass <EOL> def end_html ( self ) : pass <EOL> def start_head ( self , attrs ) : pass <EOL> def end_head ( self ) : pass <EOL> def start_body ( self , attrs ) : pass <EOL> def end_body ( self ) : pass <EOL> def start_title ( self , attrs ) : <EOL> self . save_bgn ( ) <EOL> def end_title ( self ) : <EOL> self . title = self . save_end ( ) <EOL> def do_base ( self , attrs ) : <EOL> for a , v in attrs : <EOL> if a == '<STR_LIT>' : <EOL> self . base = v <EOL> def do_isindex ( self , attrs ) : <EOL> self . isindex = <NUM_LIT:1> <EOL> def do_link ( self , attrs ) : <EOL> pass <EOL> def do_meta ( self , attrs ) : <EOL> pass <EOL> def do_nextid ( self , attrs ) : <EOL> pass <EOL> def start_h1 ( self , attrs ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . push_font ( ( '<STR_LIT>' , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> ) ) <EOL> def end_h1 ( self ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . pop_font ( ) <EOL> def start_h2 ( self , attrs ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . push_font ( ( '<STR_LIT>' , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> ) ) <EOL> def end_h2 ( self ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . pop_font ( ) <EOL> def start_h3 ( self , attrs ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . push_font ( ( '<STR_LIT>' , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> ) ) <EOL> def end_h3 ( self ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . pop_font ( ) <EOL> def start_h4 ( self , attrs ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . push_font ( ( '<STR_LIT>' , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> ) ) <EOL> def end_h4 ( self ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . pop_font ( ) <EOL> def start_h5 ( self , attrs ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . push_font ( ( '<STR_LIT>' , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> ) ) <EOL> def end_h5 ( self ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . pop_font ( ) <EOL> def start_h6 ( self , attrs ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . push_font ( ( '<STR_LIT>' , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> ) ) <EOL> def end_h6 ( self ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . pop_font ( ) <EOL> def do_p ( self , attrs ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> def start_pre ( self , attrs ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . push_font ( ( AS_IS , AS_IS , AS_IS , <NUM_LIT:1> ) ) <EOL> self . nofill = self . nofill + <NUM_LIT:1> <EOL> def end_pre ( self ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . pop_font ( ) <EOL> self . nofill = max ( <NUM_LIT:0> , self . nofill - <NUM_LIT:1> ) <EOL> def start_xmp ( self , attrs ) : <EOL> self . start_pre ( attrs ) <EOL> self . setliteral ( '<STR_LIT>' ) <EOL> def end_xmp ( self ) : <EOL> self . end_pre ( ) <EOL> def start_listing ( self , attrs ) : <EOL> self . start_pre ( attrs ) <EOL> self . setliteral ( '<STR_LIT>' ) <EOL> def end_listing ( self ) : <EOL> self . end_pre ( ) <EOL> def start_address ( self , attrs ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:0> ) <EOL> self . formatter . push_font ( ( AS_IS , <NUM_LIT:1> , AS_IS , AS_IS ) ) <EOL> def end_address ( self ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:0> ) <EOL> self . formatter . pop_font ( ) <EOL> def start_blockquote ( self , attrs ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . push_margin ( '<STR_LIT>' ) <EOL> def end_blockquote ( self ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . pop_margin ( ) <EOL> def start_ul ( self , attrs ) : <EOL> self . formatter . end_paragraph ( not self . list_stack ) <EOL> self . formatter . push_margin ( '<STR_LIT>' ) <EOL> self . list_stack . append ( [ '<STR_LIT>' , '<STR_LIT:*>' , <NUM_LIT:0> ] ) <EOL> def end_ul ( self ) : <EOL>"}
{"rec_id": "1826", "recitation_code": "self . formatter . end paragraph ( not self . list stack )", "input_code_id": 33626, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from warnings import warnpy3k <EOL> warnpy3k ( \"<STR_LIT>\" , <EOL> stacklevel = <NUM_LIT:2> ) <EOL> del warnpy3k <EOL> import sgmllib <EOL> from formatter import AS_IS <EOL> __all__ = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> class HTMLParseError ( sgmllib . SGMLParseError ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class HTMLParser ( sgmllib . SGMLParser ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from htmlentitydefs import entitydefs <EOL> def __init__ ( self , formatter , verbose = <NUM_LIT:0> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> sgmllib . SGMLParser . __init__ ( self , verbose ) <EOL> self . formatter = formatter <EOL> def error ( self , message ) : <EOL> raise HTMLParseError ( message ) <EOL> def reset ( self ) : <EOL> sgmllib . SGMLParser . reset ( self ) <EOL> self . savedata = None <EOL> self . isindex = <NUM_LIT:0> <EOL> self . title = None <EOL> self . base = None <EOL> self . anchor = None <EOL> self . anchorlist = [ ] <EOL> self . nofill = <NUM_LIT:0> <EOL> self . list_stack = [ ] <EOL> def handle_data ( self , data ) : <EOL> if self . savedata is not None : <EOL> self . savedata = self . savedata + data <EOL> else : <EOL> if self . nofill : <EOL> self . formatter . add_literal_data ( data ) <EOL> else : <EOL> self . formatter . add_flowing_data ( data ) <EOL> def save_bgn ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . savedata = '<STR_LIT>' <EOL> def save_end ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> data = self . savedata <EOL> self . savedata = None <EOL> if not self . nofill : <EOL> data = '<STR_LIT:U+0020>' . join ( data . split ( ) ) <EOL> return data <EOL> def anchor_bgn ( self , href , name , type ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . anchor = href <EOL> if self . anchor : <EOL> self . anchorlist . append ( href ) <EOL> def anchor_end ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . anchor : <EOL> self . handle_data ( \"<STR_LIT>\" % len ( self . anchorlist ) ) <EOL> self . anchor = None <EOL> def handle_image ( self , src , alt , * args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . handle_data ( alt ) <EOL> def start_html ( self , attrs ) : pass <EOL> def end_html ( self ) : pass <EOL> def start_head ( self , attrs ) : pass <EOL> def end_head ( self ) : pass <EOL> def start_body ( self , attrs ) : pass <EOL> def end_body ( self ) : pass <EOL> def start_title ( self , attrs ) : <EOL> self . save_bgn ( ) <EOL> def end_title ( self ) : <EOL> self . title = self . save_end ( ) <EOL> def do_base ( self , attrs ) : <EOL> for a , v in attrs : <EOL> if a == '<STR_LIT>' : <EOL> self . base = v <EOL> def do_isindex ( self , attrs ) : <EOL> self . isindex = <NUM_LIT:1> <EOL> def do_link ( self , attrs ) : <EOL> pass <EOL> def do_meta ( self , attrs ) : <EOL> pass <EOL> def do_nextid ( self , attrs ) : <EOL> pass <EOL> def start_h1 ( self , attrs ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . push_font ( ( '<STR_LIT>' , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> ) ) <EOL> def end_h1 ( self ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . pop_font ( ) <EOL> def start_h2 ( self , attrs ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . push_font ( ( '<STR_LIT>' , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> ) ) <EOL> def end_h2 ( self ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . pop_font ( ) <EOL> def start_h3 ( self , attrs ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . push_font ( ( '<STR_LIT>' , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> ) ) <EOL> def end_h3 ( self ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . pop_font ( ) <EOL> def start_h4 ( self , attrs ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . push_font ( ( '<STR_LIT>' , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> ) ) <EOL> def end_h4 ( self ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . pop_font ( ) <EOL> def start_h5 ( self , attrs ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . push_font ( ( '<STR_LIT>' , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> ) ) <EOL> def end_h5 ( self ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . pop_font ( ) <EOL> def start_h6 ( self , attrs ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . push_font ( ( '<STR_LIT>' , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> ) ) <EOL> def end_h6 ( self ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . pop_font ( ) <EOL> def do_p ( self , attrs ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> def start_pre ( self , attrs ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . push_font ( ( AS_IS , AS_IS , AS_IS , <NUM_LIT:1> ) ) <EOL> self . nofill = self . nofill + <NUM_LIT:1> <EOL> def end_pre ( self ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . pop_font ( ) <EOL> self . nofill = max ( <NUM_LIT:0> , self . nofill - <NUM_LIT:1> ) <EOL> def start_xmp ( self , attrs ) : <EOL> self . start_pre ( attrs ) <EOL> self . setliteral ( '<STR_LIT>' ) <EOL> def end_xmp ( self ) : <EOL> self . end_pre ( ) <EOL> def start_listing ( self , attrs ) : <EOL> self . start_pre ( attrs ) <EOL> self . setliteral ( '<STR_LIT>' ) <EOL> def end_listing ( self ) : <EOL> self . end_pre ( ) <EOL> def start_address ( self , attrs ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:0> ) <EOL> self . formatter . push_font ( ( AS_IS , <NUM_LIT:1> , AS_IS , AS_IS ) ) <EOL> def end_address ( self ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:0> ) <EOL> self . formatter . pop_font ( ) <EOL> def start_blockquote ( self , attrs ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . push_margin ( '<STR_LIT>' ) <EOL> def end_blockquote ( self ) : <EOL> self . formatter . end_paragraph ( <NUM_LIT:1> ) <EOL> self . formatter . pop_margin ( ) <EOL> def start_ul ( self , attrs ) : <EOL> self . formatter . end_paragraph ( not self . list_stack ) <EOL> self . formatter . push_margin ( '<STR_LIT>' ) <EOL> self . list_stack . append ( [ '<STR_LIT>' , '<STR_LIT:*>' , <NUM_LIT:0> ] ) <EOL> def end_ul ( self ) : <EOL>"}
{"rec_id": "1883", "recitation_code": "registry . Boolean ( False , ( \" \" \" \" \" \" ) ) )", "input_code_id": 1883, "input": "<s> import supybot . conf as conf <EOL> import supybot . registry as registry <EOL> from supybot . i18n import PluginInternationalization , internationalizeDocstring <EOL> _ = PluginInternationalization ( '<STR_LIT>' ) <EOL> def configure ( advanced ) : <EOL> from supybot . questions import expect , anything , something , yn <EOL> Web = conf . registerPlugin ( '<STR_LIT>' , True ) <EOL> if yn ( \"\"\"<STR_LIT>\"\"\" , default = False ) : <EOL> Web . titleSnarfer . setValue ( True ) <EOL> Web = conf . registerPlugin ( '<STR_LIT>' ) <EOL> conf . registerChannelValue ( Web , '<STR_LIT>' , <EOL> registry . Boolean ( False , _ ( \"\"\"<STR_LIT>\"\"\" ) ) ) <EOL> conf . registerChannelValue ( Web , '<STR_LIT>' , <EOL>"}
{"rec_id": "1883", "recitation_code": "registry . Boolean ( False , ( \" \" \" \" \" \" ) ) )", "input_code_id": 8842, "input": "<s> import supybot . conf as conf <EOL> import supybot . registry as registry <EOL> from supybot . i18n import PluginInternationalization , internationalizeDocstring <EOL> _ = PluginInternationalization ( '<STR_LIT>' ) <EOL> def configure ( advanced ) : <EOL> from supybot . questions import expect , anything , something , yn <EOL> conf . registerPlugin ( '<STR_LIT>' , True ) <EOL> AutoMode = conf . registerPlugin ( '<STR_LIT>' ) <EOL> conf . registerChannelValue ( AutoMode , '<STR_LIT>' , <EOL> registry . Boolean ( True , _ ( \"\"\"<STR_LIT>\"\"\" ) ) ) <EOL> conf . registerGlobalValue ( AutoMode , '<STR_LIT>' , <EOL> registry . Boolean ( False , _ ( \"\"\"<STR_LIT>\"\"\" ) ) ) <EOL> conf . registerChannelValue ( AutoMode , '<STR_LIT>' , <EOL> registry . Boolean ( True , _ ( \"\"\"<STR_LIT>\"\"\" ) ) ) <EOL> conf . registerChannelValue ( AutoMode , '<STR_LIT>' , <EOL>"}
{"rec_id": "1914", "recitation_code": "ch . setLevel ( logging . DEBUG )", "input_code_id": 1914, "input": "<s> import logging <EOL> def get_logger ( LOGFILE ) : <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> logger . setLevel ( logging . DEBUG ) <EOL> fh = logging . FileHandler ( LOGFILE ) <EOL> fh . setLevel ( logging . DEBUG ) <EOL> ch = logging . StreamHandler ( ) <EOL>"}
{"rec_id": "1914", "recitation_code": "ch . setLevel ( logging . DEBUG )", "input_code_id": 9218, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import logging <EOL> import os <EOL> import sys <EOL> from cloud_handler import CloudLoggingHandler <EOL> from cron_executor import Executor <EOL> PROJECT = '<STR_LIT>' <EOL> TOPIC = '<STR_LIT:test>' <EOL> script_path = os . path . abspath ( os . path . join ( os . getcwd ( ) , '<STR_LIT>' ) ) <EOL> sample_task = \"<STR_LIT>\" % script_path <EOL> root_logger = logging . getLogger ( '<STR_LIT>' ) <EOL> root_logger . setLevel ( logging . DEBUG ) <EOL> ch = logging . StreamHandler ( sys . stderr ) <EOL>"}
{"rec_id": "1914", "recitation_code": "ch . setLevel ( logging . DEBUG )", "input_code_id": 13883, "input": "<s> import logging <EOL> logger = logging . getLogger ( \"<STR_LIT>\" ) <EOL> logger . setLevel ( logging . DEBUG ) <EOL> ch = logging . StreamHandler ( ) <EOL>"}
{"rec_id": "1914", "recitation_code": "ch . setLevel ( logging . DEBUG )", "input_code_id": 33614, "input": "<s> import logging <EOL> logger = logging . getLogger ( \"<STR_LIT>\" ) <EOL> logger . setLevel ( logging . DEBUG ) <EOL> ch = logging . StreamHandler ( ) <EOL>"}
{"rec_id": "2012", "recitation_code": "@ pl announce ( ' ' )", "input_code_id": 2012, "input": "<s> from spockbot . plugins import default_plugins <EOL> from spockbot . plugins . base import get_settings , pl_announce <EOL> class PloaderFetch ( object ) : <EOL> def __init__ ( self , plugins , plugin_settings ) : <EOL> self . plugins = plugins <EOL> self . plugin_settings = plugin_settings <EOL> def get_plugins ( self ) : <EOL> return self . plugins <EOL> def get_plugin_settings ( self , plugin ) : <EOL> return self . plugin_settings . get ( plugin , { } ) <EOL> @ pl_announce ( '<STR_LIT>' ) <EOL>"}
{"rec_id": "2012", "recitation_code": "@ pl announce ( ' ' )", "input_code_id": 7314, "input": "<s> import logging <EOL> from collections import deque <EOL> from spockbot . plugins . base import pl_announce , PluginBase <EOL> from spockbot . vector import Vector3 <EOL> from bat . command import register_command <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> @ pl_announce ( '<STR_LIT>' ) <EOL> class MovementCommandsPlugin ( PluginBase ) : <EOL> requires = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , ploader , settings ) : <EOL> super ( MovementCommandsPlugin , self ) . __init__ ( ploader , settings ) <EOL> self . commands . register_handlers ( self ) <EOL> ploader . provides ( '<STR_LIT>' , self ) <EOL> self . path_queue = deque ( ) <EOL> self . follow_eid = None <EOL> def on_entity_move ( self , evt , packet ) : <EOL> eid = packet . data [ '<STR_LIT>' ] <EOL> if self . follow_eid and eid == self . follow_eid : <EOL> self . teleport ( Vector3 ( self . entities . entities [ eid ] ) ) <EOL> @ register_command ( '<STR_LIT>' , '<STR_LIT:3>' ) <EOL> def tp_block ( self , coords ) : <EOL> self . teleport ( Vector3 ( * coords ) . ifloor ( ) . iadd ( <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT> ) ) <EOL> @ register_command ( '<STR_LIT>' , '<STR_LIT:3>' ) <EOL> def tp_delta ( self , deltas ) : <EOL> self . teleport ( Vector3 ( * deltas ) . iadd ( self . clientinfo . position ) ) <EOL> @ register_command ( '<STR_LIT>' , '<STR_LIT:3>' ) <EOL> def teleport ( self , coords ) : <EOL> self . clientinfo . position . init ( * coords ) <EOL> @ register_command ( '<STR_LIT>' , '<STR_LIT>' ) <EOL>"}
{"rec_id": "2012", "recitation_code": "@ pl announce ( ' ' )", "input_code_id": 42515, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from spockbot . mcdata . utils import Info <EOL> from spockbot . plugins . base import PluginBase , pl_announce <EOL> class MCEntity ( Info ) : <EOL> eid = <NUM_LIT:0> <EOL> status = <NUM_LIT:0> <EOL> nbt = None <EOL> metadata = None <EOL> class MovementEntity ( MCEntity ) : <EOL> x = <NUM_LIT:0> <EOL> y = <NUM_LIT:0> <EOL> z = <NUM_LIT:0> <EOL> yaw = <NUM_LIT:0> <EOL> pitch = <NUM_LIT:0> <EOL> on_ground = True <EOL> class PlayerEntity ( MovementEntity ) : <EOL> uuid = <NUM_LIT:0> <EOL> current_item = <NUM_LIT:0> <EOL> metadata = None <EOL> class ObjectEntity ( MovementEntity ) : <EOL> obj_type = <NUM_LIT:0> <EOL> obj_data = <NUM_LIT:0> <EOL> speed_x = <NUM_LIT:0> <EOL> speed_y = <NUM_LIT:0> <EOL> speed_z = <NUM_LIT:0> <EOL> class MobEntity ( MovementEntity ) : <EOL> mob_type = <NUM_LIT:0> <EOL> head_pitch = <NUM_LIT:0> <EOL> head_yaw = <NUM_LIT:0> <EOL> velocity_x = <NUM_LIT:0> <EOL> velocity_y = <NUM_LIT:0> <EOL> velocity_z = <NUM_LIT:0> <EOL> metadata = None <EOL> class PaintingEntity ( MCEntity ) : <EOL> title = \"<STR_LIT>\" <EOL> location = { <EOL> '<STR_LIT:x>' : <NUM_LIT:0> , <EOL> '<STR_LIT:y>' : <NUM_LIT:0> , <EOL> '<STR_LIT:z>' : <NUM_LIT:0> , <EOL> } <EOL> direction = <NUM_LIT:0> <EOL> class ExpEntity ( MCEntity ) : <EOL> x = <NUM_LIT:0> <EOL> y = <NUM_LIT:0> <EOL> z = <NUM_LIT:0> <EOL> count = <NUM_LIT:0> <EOL> class GlobalEntity ( MCEntity ) : <EOL> global_type = <NUM_LIT:0> <EOL> x = <NUM_LIT:0> <EOL> y = <NUM_LIT:0> <EOL> z = <NUM_LIT:0> <EOL> class EntitiesCore ( object ) : <EOL> def __init__ ( self ) : <EOL> self . client_player = MCEntity ( ) <EOL> self . entities = { } <EOL> self . players = { } <EOL> self . mobs = { } <EOL> self . objects = { } <EOL> self . paintings = { } <EOL> self . exp_orbs = { } <EOL> self . global_entities = { } <EOL> @ pl_announce ( '<STR_LIT>' ) <EOL> class EntitiesPlugin ( PluginBase ) : <EOL> requires = '<STR_LIT>' <EOL> events = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL>"}
{"rec_id": "2012", "recitation_code": "@ pl announce ( ' ' )", "input_code_id": 52483, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from spockbot . mcdata import constants , windows <EOL> from spockbot . mcdata . windows import make_slot_check <EOL> from spockbot . plugins . base import PluginBase , pl_announce <EOL> from spockbot . plugins . tools . event import EVENT_UNREGISTER <EOL> from spockbot . plugins . tools . inventory_async import InventoryAsync <EOL> class InventoryCore ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , net_plugin , send_click ) : <EOL> self . _net = net_plugin <EOL> self . send_click = send_click <EOL> self . active_slot_nr = <NUM_LIT:0> <EOL> self . cursor_slot = windows . SlotCursor ( ) <EOL> self . window = windows . PlayerWindow ( ) <EOL> self . async = InventoryAsync ( self ) <EOL> def total_stored ( self , wanted , slots = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if slots is None : <EOL> slots = self . window . slots <EOL> wanted = make_slot_check ( wanted ) <EOL> return sum ( slot . amount for slot in slots if wanted ( slot ) ) <EOL> def find_slot ( self , wanted , slots = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for slot in self . find_slots ( wanted , slots ) : <EOL> return slot <EOL> return None <EOL> def find_slots ( self , wanted , slots = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if slots is None : <EOL> slots = self . inv_slots_preferred + self . window . window_slots <EOL> wanted = make_slot_check ( wanted ) <EOL> for slot in slots : <EOL> if wanted ( slot ) : <EOL> yield slot <EOL> def select_active_slot ( self , slot_or_hotbar_index ) : <EOL> if hasattr ( slot_or_hotbar_index , '<STR_LIT>' ) : <EOL> hotbar_start = self . window . hotbar_slots [ <NUM_LIT:0> ] . slot_nr <EOL> slot_or_hotbar_index = slot_or_hotbar_index . slot_nr - hotbar_start <EOL> assert <NUM_LIT:0> <= slot_or_hotbar_index < constants . INV_SLOTS_HOTBAR , '<STR_LIT>' % slot_or_hotbar_index <EOL> if self . active_slot_nr != slot_or_hotbar_index : <EOL> self . active_slot_nr = slot_or_hotbar_index <EOL> self . _net . push_packet ( '<STR_LIT>' , <EOL> { '<STR_LIT>' : slot_or_hotbar_index } ) <EOL> def click_slot ( self , slot , right = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if isinstance ( slot , int ) : <EOL> slot = self . window . slots [ slot ] <EOL> button = constants . INV_BUTTON_RIGHT if right else constants . INV_BUTTON_LEFT <EOL> return self . send_click ( windows . SingleClick ( slot , button ) ) <EOL> def drop_slot ( self , slot = None , drop_stack = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if slot is None : <EOL> if self . cursor_slot . is_empty : <EOL> slot = self . active_slot <EOL> else : <EOL> slot = self . cursor_slot <EOL> elif isinstance ( slot , int ) : <EOL> slot = self . window . slots [ slot ] <EOL> if slot == self . cursor_slot : <EOL> return self . click_slot ( self . cursor_slot , not drop_stack ) <EOL> return self . send_click ( windows . DropClick ( slot , drop_stack ) ) <EOL> def close_window ( self ) : <EOL> self . _net . push_packet ( '<STR_LIT>' , <EOL> { '<STR_LIT>' : self . window . window_id } ) <EOL> def creative_set_slot ( self , slot_nr = None , slot_dict = None , slot = None ) : <EOL> self . _net . push_packet ( '<STR_LIT>' , { <EOL> '<STR_LIT>' : slot_nr or slot . slot_nr , <EOL> '<STR_LIT>' : slot_dict or slot . get_dict ( ) , <EOL> } ) <EOL> @ property <EOL> def active_slot ( self ) : <EOL> return self . window . hotbar_slots [ self . active_slot_nr ] <EOL> @ property <EOL> def inv_slots_preferred ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> slots = [ self . active_slot ] <EOL> slots . extend ( slot for slot in self . window . hotbar_slots <EOL> if slot != self . active_slot ) <EOL> slots . extend ( self . window . inventory_slots ) <EOL> return slots <EOL> @ pl_announce ( '<STR_LIT>' ) <EOL> class InventoryPlugin ( PluginBase ) : <EOL> requires = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> events = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> def __init__ ( self , ploader , settings ) : <EOL> super ( InventoryPlugin , self ) . __init__ ( ploader , settings ) <EOL> self . inventory = InventoryCore ( self . net , self . send_click ) <EOL> ploader . provides ( '<STR_LIT>' , self . inventory ) <EOL> self . action_id = <NUM_LIT:1> <EOL>"}
{"rec_id": "2012", "recitation_code": "@ pl announce ( ' ' )", "input_code_id": 83193, "input": "<s> from spockbot . plugins . base import PluginBase , pl_announce <EOL> from spockbot . plugins . tools . task import Task <EOL> @ pl_announce ( '<STR_LIT>' ) <EOL> class TaskManager ( PluginBase ) : <EOL> requires = '<STR_LIT>' <EOL> def __init__ ( self , ploader , settings ) : <EOL> super ( TaskManager , self ) . __init__ ( ploader , settings ) <EOL>"}
{"rec_id": "2089", "recitation_code": "return len ( text )", "input_code_id": 2089, "input": "<s> '''<STR_LIT>''' <EOL> import clr , sys <EOL> clr . AddReferenceToFileAndPath ( sys . executable ) <EOL> import IronPythonConsole <EOL> import sys <EOL> import re <EOL> import os <EOL> import System <EOL> from event import Event <EOL> from pyreadline . logger import log , log_sock <EOL> from pyreadline . keysyms import make_keysym , make_keyinfo , make_KeyPress , make_KeyPress_from_keydescr <EOL> from pyreadline . console . ansi import AnsiState <EOL> color = System . ConsoleColor <EOL> ansicolor = { \"<STR_LIT>\" : color . Black , <EOL> \"<STR_LIT>\" : color . DarkRed , <EOL> \"<STR_LIT>\" : color . DarkGreen , <EOL> \"<STR_LIT>\" : color . DarkYellow , <EOL> \"<STR_LIT>\" : color . DarkBlue , <EOL> \"<STR_LIT>\" : color . DarkMagenta , <EOL> \"<STR_LIT>\" : color . DarkCyan , <EOL> \"<STR_LIT>\" : color . DarkGray , <EOL> \"<STR_LIT>\" : color . Gray , <EOL> \"<STR_LIT>\" : color . Red , <EOL> \"<STR_LIT>\" : color . Green , <EOL> \"<STR_LIT>\" : color . Yellow , <EOL> \"<STR_LIT>\" : color . Blue , <EOL> \"<STR_LIT>\" : color . Magenta , <EOL> \"<STR_LIT>\" : color . Cyan , <EOL> \"<STR_LIT>\" : color . White <EOL> } <EOL> winattr = { \"<STR_LIT>\" : <NUM_LIT:0> , \"<STR_LIT>\" : <NUM_LIT:0> + <NUM_LIT:8> , <EOL> \"<STR_LIT>\" : <NUM_LIT:4> , \"<STR_LIT>\" : <NUM_LIT:4> + <NUM_LIT:8> , <EOL> \"<STR_LIT>\" : <NUM_LIT:2> , \"<STR_LIT>\" : <NUM_LIT:2> + <NUM_LIT:8> , <EOL> \"<STR_LIT>\" : <NUM_LIT:6> , \"<STR_LIT>\" : <NUM_LIT:6> + <NUM_LIT:8> , <EOL> \"<STR_LIT>\" : <NUM_LIT:1> , \"<STR_LIT>\" : <NUM_LIT:1> + <NUM_LIT:8> , <EOL> \"<STR_LIT>\" : <NUM_LIT:5> , \"<STR_LIT>\" : <NUM_LIT:5> + <NUM_LIT:8> , <EOL> \"<STR_LIT>\" : <NUM_LIT:3> , \"<STR_LIT>\" : <NUM_LIT:3> + <NUM_LIT:8> , <EOL> \"<STR_LIT>\" : <NUM_LIT:7> , \"<STR_LIT>\" : <NUM_LIT:7> + <NUM_LIT:8> } <EOL> class Console ( object ) : <EOL> '''<STR_LIT>''' <EOL> def __init__ ( self , newbuffer = <NUM_LIT:0> ) : <EOL> '''<STR_LIT>''' <EOL> self . serial = <NUM_LIT:0> <EOL> self . attr = System . Console . ForegroundColor <EOL> self . saveattr = winattr [ str ( System . Console . ForegroundColor ) . lower ( ) ] <EOL> self . savebg = System . Console . BackgroundColor <EOL> log ( '<STR_LIT>' % self . attr ) <EOL> log_sock ( \"<STR_LIT:%s>\" % self . saveattr ) <EOL> def _get ( self ) : <EOL> top = System . Console . WindowTop <EOL> log_sock ( \"<STR_LIT>\" % top , \"<STR_LIT>\" ) <EOL> return top <EOL> def _set ( self , value ) : <EOL> top = System . Console . WindowTop <EOL> log_sock ( \"<STR_LIT>\" % ( top , value ) , \"<STR_LIT>\" ) <EOL> WindowTop = property ( _get , _set ) <EOL> del _get , _set <EOL> def __del__ ( self ) : <EOL> '''<STR_LIT>''' <EOL> pass <EOL> def pos ( self , x = None , y = None ) : <EOL> '''<STR_LIT>''' <EOL> if x is not None : <EOL> System . Console . CursorLeft = x <EOL> else : <EOL> x = System . Console . CursorLeft <EOL> if y is not None : <EOL> System . Console . CursorTop = y <EOL> else : <EOL> y = System . Console . CursorTop <EOL> return x , y <EOL> def home ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . pos ( <NUM_LIT:0> , <NUM_LIT:0> ) <EOL> terminal_escape = re . compile ( '<STR_LIT>' ) <EOL> escape_parts = re . compile ( '<STR_LIT>' ) <EOL> motion_char_re = re . compile ( '<STR_LIT>' ) <EOL> def write_scrolling ( self , text , attr = None ) : <EOL> '''<STR_LIT>''' <EOL> x , y = self . pos ( ) <EOL> w , h = self . size ( ) <EOL> scroll = <NUM_LIT:0> <EOL> chunks = self . motion_char_re . split ( text ) <EOL> for chunk in chunks : <EOL> log ( '<STR_LIT>' + chunk ) <EOL> n = self . write_color ( chunk , attr ) <EOL> if len ( chunk ) == <NUM_LIT:1> : <EOL> if chunk [ <NUM_LIT:0> ] == '<STR_LIT:\\n>' : <EOL> x = <NUM_LIT:0> <EOL> y += <NUM_LIT:1> <EOL> elif chunk [ <NUM_LIT:0> ] == '<STR_LIT:\\r>' : <EOL> x = <NUM_LIT:0> <EOL> elif chunk [ <NUM_LIT:0> ] == '<STR_LIT:\\t>' : <EOL> x = <NUM_LIT:8> * ( int ( x / <NUM_LIT:8> ) + <NUM_LIT:1> ) <EOL> if x > w : <EOL> x -= w <EOL> y += <NUM_LIT:1> <EOL> elif chunk [ <NUM_LIT:0> ] == '<STR_LIT>' : <EOL> pass <EOL> elif chunk [ <NUM_LIT:0> ] == '<STR_LIT>' : <EOL> x -= <NUM_LIT:1> <EOL> if x < <NUM_LIT:0> : <EOL> y -= <NUM_LIT:1> <EOL> else : <EOL> x += <NUM_LIT:1> <EOL> if x == w : <EOL> x = <NUM_LIT:0> <EOL> y += <NUM_LIT:1> <EOL> if y == h : <EOL> scroll += <NUM_LIT:1> <EOL> y = h - <NUM_LIT:1> <EOL> else : <EOL> x += n <EOL> l = int ( x / w ) <EOL> x = x % w <EOL> y += l <EOL> if y >= h : <EOL> scroll += y - h + <NUM_LIT:1> <EOL> y = h - <NUM_LIT:1> <EOL> return scroll <EOL> trtable = { <NUM_LIT:0> : color . Black , <NUM_LIT:4> : color . DarkRed , <NUM_LIT:2> : color . DarkGreen , <NUM_LIT:6> : color . DarkYellow , <EOL> <NUM_LIT:1> : color . DarkBlue , <NUM_LIT:5> : color . DarkMagenta , <NUM_LIT:3> : color . DarkCyan , <NUM_LIT:7> : color . Gray , <EOL> <NUM_LIT:8> : color . DarkGray , <NUM_LIT:4> + <NUM_LIT:8> : color . Red , <NUM_LIT:2> + <NUM_LIT:8> : color . Green , <NUM_LIT:6> + <NUM_LIT:8> : color . Yellow , <EOL> <NUM_LIT:1> + <NUM_LIT:8> : color . Blue , <NUM_LIT:5> + <NUM_LIT:8> : color . Magenta , <NUM_LIT:3> + <NUM_LIT:8> : color . Cyan , <NUM_LIT:7> + <NUM_LIT:8> : color . White } <EOL> def write_color ( self , text , attr = None ) : <EOL> '''<STR_LIT>''' <EOL> log ( '<STR_LIT>' % ( text , attr ) ) <EOL> chunks = self . terminal_escape . split ( text ) <EOL> log ( '<STR_LIT>' % repr ( chunks ) ) <EOL> bg = self . savebg <EOL> n = <NUM_LIT:0> <EOL> if attr is None : <EOL> attr = self . attr <EOL> try : <EOL> fg = self . trtable [ ( <NUM_LIT> & attr ) ] <EOL> bg = self . trtable [ ( <NUM_LIT> & attr ) >> <NUM_LIT:4> ] <EOL> except TypeError : <EOL> fg = attr <EOL> for chunk in chunks : <EOL> m = self . escape_parts . match ( chunk ) <EOL> if m : <EOL> log ( m . group ( <NUM_LIT:1> ) ) <EOL> attr = ansicolor . get ( m . group ( <NUM_LIT:1> ) , self . attr ) <EOL> n += len ( chunk ) <EOL> System . Console . ForegroundColor = fg <EOL> System . Console . BackgroundColor = bg <EOL> System . Console . Write ( chunk ) <EOL> return n <EOL> def write_plain ( self , text , attr = None ) : <EOL> '''<STR_LIT>''' <EOL> log ( '<STR_LIT>' % ( text , attr ) ) <EOL> if attr is None : <EOL> attr = self . attr <EOL> n = c_int ( <NUM_LIT:0> ) <EOL> self . SetConsoleTextAttribute ( self . hout , attr ) <EOL> self . WriteConsoleA ( self . hout , text , len ( text ) , byref ( n ) , None ) <EOL> return len ( text ) <EOL> if os . environ . has_key ( \"<STR_LIT>\" ) : <EOL> def write_color ( self , text , attr = None ) : <EOL> junk = c_int ( <NUM_LIT:0> ) <EOL> self . WriteFile ( self . hout , text , len ( text ) , byref ( junk ) , None ) <EOL>"}
{"rec_id": "2089", "recitation_code": "return len ( text )", "input_code_id": 38789, "input": "<s> '''<STR_LIT>''' <EOL> import clr , sys <EOL> clr . AddReferenceToFileAndPath ( sys . executable ) <EOL> import IronPythonConsole <EOL> import sys <EOL> import re <EOL> import os <EOL> import System <EOL> from event import Event <EOL> from pyreadline . logger import log , log_sock <EOL> from pyreadline . keysyms import make_keysym , make_keyinfo , make_KeyPress , make_KeyPress_from_keydescr <EOL> from pyreadline . console . ansi import AnsiState <EOL> color = System . ConsoleColor <EOL> ansicolor = { \"<STR_LIT>\" : color . Black , <EOL> \"<STR_LIT>\" : color . DarkRed , <EOL> \"<STR_LIT>\" : color . DarkGreen , <EOL> \"<STR_LIT>\" : color . DarkYellow , <EOL> \"<STR_LIT>\" : color . DarkBlue , <EOL> \"<STR_LIT>\" : color . DarkMagenta , <EOL> \"<STR_LIT>\" : color . DarkCyan , <EOL> \"<STR_LIT>\" : color . DarkGray , <EOL> \"<STR_LIT>\" : color . Gray , <EOL> \"<STR_LIT>\" : color . Red , <EOL> \"<STR_LIT>\" : color . Green , <EOL> \"<STR_LIT>\" : color . Yellow , <EOL> \"<STR_LIT>\" : color . Blue , <EOL> \"<STR_LIT>\" : color . Magenta , <EOL> \"<STR_LIT>\" : color . Cyan , <EOL> \"<STR_LIT>\" : color . White <EOL> } <EOL> winattr = { \"<STR_LIT>\" : <NUM_LIT:0> , \"<STR_LIT>\" : <NUM_LIT:0> + <NUM_LIT:8> , <EOL> \"<STR_LIT>\" : <NUM_LIT:4> , \"<STR_LIT>\" : <NUM_LIT:4> + <NUM_LIT:8> , <EOL> \"<STR_LIT>\" : <NUM_LIT:2> , \"<STR_LIT>\" : <NUM_LIT:2> + <NUM_LIT:8> , <EOL> \"<STR_LIT>\" : <NUM_LIT:6> , \"<STR_LIT>\" : <NUM_LIT:6> + <NUM_LIT:8> , <EOL> \"<STR_LIT>\" : <NUM_LIT:1> , \"<STR_LIT>\" : <NUM_LIT:1> + <NUM_LIT:8> , <EOL> \"<STR_LIT>\" : <NUM_LIT:5> , \"<STR_LIT>\" : <NUM_LIT:5> + <NUM_LIT:8> , <EOL> \"<STR_LIT>\" : <NUM_LIT:3> , \"<STR_LIT>\" : <NUM_LIT:3> + <NUM_LIT:8> , <EOL> \"<STR_LIT>\" : <NUM_LIT:7> , \"<STR_LIT>\" : <NUM_LIT:7> + <NUM_LIT:8> } <EOL> class Console ( object ) : <EOL> '''<STR_LIT>''' <EOL> def __init__ ( self , newbuffer = <NUM_LIT:0> ) : <EOL> '''<STR_LIT>''' <EOL> self . serial = <NUM_LIT:0> <EOL> self . attr = System . Console . ForegroundColor <EOL> self . saveattr = winattr [ str ( System . Console . ForegroundColor ) . lower ( ) ] <EOL> self . savebg = System . Console . BackgroundColor <EOL> log ( '<STR_LIT>' % self . attr ) <EOL> log_sock ( \"<STR_LIT:%s>\" % self . saveattr ) <EOL> def _get ( self ) : <EOL> top = System . Console . WindowTop <EOL> log_sock ( \"<STR_LIT>\" % top , \"<STR_LIT>\" ) <EOL> return top <EOL> def _set ( self , value ) : <EOL> top = System . Console . WindowTop <EOL> log_sock ( \"<STR_LIT>\" % ( top , value ) , \"<STR_LIT>\" ) <EOL> WindowTop = property ( _get , _set ) <EOL> del _get , _set <EOL> def __del__ ( self ) : <EOL> '''<STR_LIT>''' <EOL> pass <EOL> def pos ( self , x = None , y = None ) : <EOL> '''<STR_LIT>''' <EOL> if x is not None : <EOL> System . Console . CursorLeft = x <EOL> else : <EOL> x = System . Console . CursorLeft <EOL> if y is not None : <EOL> System . Console . CursorTop = y <EOL> else : <EOL> y = System . Console . CursorTop <EOL> return x , y <EOL> def home ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . pos ( <NUM_LIT:0> , <NUM_LIT:0> ) <EOL> terminal_escape = re . compile ( '<STR_LIT>' ) <EOL> escape_parts = re . compile ( '<STR_LIT>' ) <EOL> motion_char_re = re . compile ( '<STR_LIT>' ) <EOL> def write_scrolling ( self , text , attr = None ) : <EOL> '''<STR_LIT>''' <EOL> x , y = self . pos ( ) <EOL> w , h = self . size ( ) <EOL> scroll = <NUM_LIT:0> <EOL> chunks = self . motion_char_re . split ( text ) <EOL> for chunk in chunks : <EOL> log ( '<STR_LIT>' + chunk ) <EOL> n = self . write_color ( chunk , attr ) <EOL> if len ( chunk ) == <NUM_LIT:1> : <EOL> if chunk [ <NUM_LIT:0> ] == '<STR_LIT:\\n>' : <EOL> x = <NUM_LIT:0> <EOL> y += <NUM_LIT:1> <EOL> elif chunk [ <NUM_LIT:0> ] == '<STR_LIT:\\r>' : <EOL> x = <NUM_LIT:0> <EOL> elif chunk [ <NUM_LIT:0> ] == '<STR_LIT:\\t>' : <EOL> x = <NUM_LIT:8> * ( int ( x / <NUM_LIT:8> ) + <NUM_LIT:1> ) <EOL> if x > w : <EOL> x -= w <EOL> y += <NUM_LIT:1> <EOL> elif chunk [ <NUM_LIT:0> ] == '<STR_LIT>' : <EOL> pass <EOL> elif chunk [ <NUM_LIT:0> ] == '<STR_LIT>' : <EOL> x -= <NUM_LIT:1> <EOL> if x < <NUM_LIT:0> : <EOL> y -= <NUM_LIT:1> <EOL> else : <EOL> x += <NUM_LIT:1> <EOL> if x == w : <EOL> x = <NUM_LIT:0> <EOL> y += <NUM_LIT:1> <EOL> if y == h : <EOL> scroll += <NUM_LIT:1> <EOL> y = h - <NUM_LIT:1> <EOL> else : <EOL> x += n <EOL> l = int ( x / w ) <EOL> x = x % w <EOL> y += l <EOL> if y >= h : <EOL> scroll += y - h + <NUM_LIT:1> <EOL> y = h - <NUM_LIT:1> <EOL> return scroll <EOL> trtable = { <NUM_LIT:0> : color . Black , <NUM_LIT:4> : color . DarkRed , <NUM_LIT:2> : color . DarkGreen , <NUM_LIT:6> : color . DarkYellow , <EOL> <NUM_LIT:1> : color . DarkBlue , <NUM_LIT:5> : color . DarkMagenta , <NUM_LIT:3> : color . DarkCyan , <NUM_LIT:7> : color . Gray , <EOL> <NUM_LIT:8> : color . DarkGray , <NUM_LIT:4> + <NUM_LIT:8> : color . Red , <NUM_LIT:2> + <NUM_LIT:8> : color . Green , <NUM_LIT:6> + <NUM_LIT:8> : color . Yellow , <EOL> <NUM_LIT:1> + <NUM_LIT:8> : color . Blue , <NUM_LIT:5> + <NUM_LIT:8> : color . Magenta , <NUM_LIT:3> + <NUM_LIT:8> : color . Cyan , <NUM_LIT:7> + <NUM_LIT:8> : color . White } <EOL> def write_color ( self , text , attr = None ) : <EOL> '''<STR_LIT>''' <EOL> log ( '<STR_LIT>' % ( text , attr ) ) <EOL> chunks = self . terminal_escape . split ( text ) <EOL> log ( '<STR_LIT>' % repr ( chunks ) ) <EOL> bg = self . savebg <EOL> n = <NUM_LIT:0> <EOL> if attr is None : <EOL> attr = self . attr <EOL> try : <EOL> fg = self . trtable [ ( <NUM_LIT> & attr ) ] <EOL> bg = self . trtable [ ( <NUM_LIT> & attr ) >> <NUM_LIT:4> ] <EOL> except TypeError : <EOL> fg = attr <EOL> for chunk in chunks : <EOL> m = self . escape_parts . match ( chunk ) <EOL> if m : <EOL> log ( m . group ( <NUM_LIT:1> ) ) <EOL> attr = ansicolor . get ( m . group ( <NUM_LIT:1> ) , self . attr ) <EOL> n += len ( chunk ) <EOL> System . Console . ForegroundColor = fg <EOL> System . Console . BackgroundColor = bg <EOL> System . Console . Write ( chunk ) <EOL> return n <EOL> def write_plain ( self , text , attr = None ) : <EOL> '''<STR_LIT>''' <EOL> log ( '<STR_LIT>' % ( text , attr ) ) <EOL> if attr is None : <EOL> attr = self . attr <EOL> n = c_int ( <NUM_LIT:0> ) <EOL> self . SetConsoleTextAttribute ( self . hout , attr ) <EOL> self . WriteConsoleA ( self . hout , text , len ( text ) , byref ( n ) , None ) <EOL> return len ( text ) <EOL> if os . environ . has_key ( \"<STR_LIT>\" ) : <EOL> def write_color ( self , text , attr = None ) : <EOL> junk = c_int ( <NUM_LIT:0> ) <EOL> self . WriteFile ( self . hout , text , len ( text ) , byref ( junk ) , None ) <EOL>"}
{"rec_id": "2097", "recitation_code": "from . item import Item", "input_code_id": 2097, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from . characters import Goblin , Adventurer , Wizard <EOL> from . characters import strong , weak <EOL> from . weapons import Dagger , Sword , Club , Bow , Arrows , Warhammer <EOL> from . armours import ( LeatherArmour , ScaleMail , PlateMail , <EOL> LightBoots , HeavyBoots , IronBoots , SpeedBoots , <EOL> FlyingBoots ) <EOL> from . items import Rune <EOL>"}
{"rec_id": "2097", "recitation_code": "from . item import Item", "input_code_id": 40549, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from . combat import ( new_attack_hit_event , new_attack_miss_event , <EOL> new_attack_nothing_event ) <EOL> from . damage import ( damage_triggered , damage_added , damage_ended ) <EOL> from . dig import new_dig_event <EOL> from . death import new_death_event <EOL> from . effect import new_effect_added_event , new_effect_removed_event <EOL> from . error import new_error_event <EOL> from . event import ( e_event_type , e_level , e_location , e_character , e_old_spirit , <EOL> e_new_spirit , e_target , e_damage , e_deceased , e_new_items , <EOL> e_new_characters , e_item , e_new_character , e_destroyed_characters , <EOL> e_old_location , e_direction , e_attacker , e_old_hit_points , <EOL> e_new_hit_points , e_trap , empty_event , e_healing ) <EOL>"}
{"rec_id": "2113", "recitation_code": "return betweenness", "input_code_id": 2113, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __author__ = \"\"\"<STR_LIT>\"\"\" <EOL> __all__ = [ '<STR_LIT>' , <EOL> '<STR_LIT>' ] <EOL> import itertools <EOL> import networkx as nx <EOL> from networkx . algorithms . centrality . flow_matrix import * <EOL> def current_flow_betweenness_centrality_subset ( G , sources , targets , <EOL> normalized = True , <EOL> weight = '<STR_LIT>' , <EOL> dtype = float , solver = '<STR_LIT>' ) : <EOL> r\"\"\"<STR_LIT>\"\"\" <EOL> from networkx . utils import reverse_cuthill_mckee_ordering <EOL> try : <EOL> import numpy as np <EOL> except ImportError : <EOL> raise ImportError ( '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> try : <EOL> import scipy <EOL> except ImportError : <EOL> raise ImportError ( '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> if G . is_directed ( ) : <EOL> raise nx . NetworkXError ( '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> if not nx . is_connected ( G ) : <EOL> raise nx . NetworkXError ( \"<STR_LIT>\" ) <EOL> n = G . number_of_nodes ( ) <EOL> ordering = list ( reverse_cuthill_mckee_ordering ( G ) ) <EOL> mapping = dict ( zip ( ordering , range ( n ) ) ) <EOL> H = nx . relabel_nodes ( G , mapping ) <EOL> betweenness = dict . fromkeys ( H , <NUM_LIT:0.0> ) <EOL> for row , ( s , t ) in flow_matrix_row ( H , weight = weight , dtype = dtype , <EOL> solver = solver ) : <EOL> for ss in sources : <EOL> i = mapping [ ss ] <EOL> for tt in targets : <EOL> j = mapping [ tt ] <EOL> betweenness [ s ] += <NUM_LIT:0.5> * np . abs ( row [ i ] - row [ j ] ) <EOL> betweenness [ t ] += <NUM_LIT:0.5> * np . abs ( row [ i ] - row [ j ] ) <EOL> if normalized : <EOL> nb = ( n - <NUM_LIT:1.0> ) * ( n - <NUM_LIT> ) <EOL> else : <EOL> nb = <NUM_LIT> <EOL> for v in H : <EOL> betweenness [ v ] = betweenness [ v ] / nb + <NUM_LIT:1.0> / ( <NUM_LIT:2> - n ) <EOL>"}
{"rec_id": "2113", "recitation_code": "return betweenness", "input_code_id": 17304, "input": "<s> import networkx as nx <EOL> __author__ = \"\"\"<STR_LIT:\\n>\"\"\" . join ( [ '<STR_LIT>' , <EOL> '<STR_LIT>' ] ) <EOL> __all__ = [ '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ] <EOL> def degree_centrality ( G , nodes ) : <EOL> r\"\"\"<STR_LIT>\"\"\" <EOL> top = set ( nodes ) <EOL> bottom = set ( G ) - top <EOL> s = <NUM_LIT:1.0> / len ( bottom ) <EOL> centrality = dict ( ( n , d * s ) for n , d in G . degree ( top ) ) <EOL> s = <NUM_LIT:1.0> / len ( top ) <EOL> centrality . update ( dict ( ( n , d * s ) for n , d in G . degree ( bottom ) ) ) <EOL> return centrality <EOL> def betweenness_centrality ( G , nodes ) : <EOL> r\"\"\"<STR_LIT>\"\"\" <EOL> top = set ( nodes ) <EOL> bottom = set ( G ) - top <EOL> n = float ( len ( top ) ) <EOL> m = float ( len ( bottom ) ) <EOL> s = ( n - <NUM_LIT:1> ) // m <EOL> t = ( n - <NUM_LIT:1> ) % m <EOL> bet_max_top = ( ( ( m ** <NUM_LIT:2> ) * ( ( s + <NUM_LIT:1> ) ** <NUM_LIT:2> ) ) + <EOL> ( m * ( s + <NUM_LIT:1> ) * ( <NUM_LIT:2> * t - s - <NUM_LIT:1> ) ) - <EOL> ( t * ( ( <NUM_LIT:2> * s ) - t + <NUM_LIT:3> ) ) ) / <NUM_LIT> <EOL> p = ( m - <NUM_LIT:1> ) // n <EOL> r = ( m - <NUM_LIT:1> ) % n <EOL> bet_max_bot = ( ( ( n ** <NUM_LIT:2> ) * ( ( p + <NUM_LIT:1> ) ** <NUM_LIT:2> ) ) + <EOL> ( n * ( p + <NUM_LIT:1> ) * ( <NUM_LIT:2> * r - p - <NUM_LIT:1> ) ) - <EOL> ( r * ( ( <NUM_LIT:2> * p ) - r + <NUM_LIT:3> ) ) ) / <NUM_LIT> <EOL> betweenness = nx . betweenness_centrality ( G , normalized = False , <EOL> weight = None ) <EOL>"}
{"rec_id": "2178", "recitation_code": "def handle extra path ( self ) :", "input_code_id": 2178, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from distutils import log <EOL> __revision__ = \"<STR_LIT>\" <EOL> import sys , os , string <EOL> from types import * <EOL> from distutils . core import Command <EOL> from distutils . debug import DEBUG <EOL> from distutils . sysconfig import get_config_vars <EOL> from distutils . errors import DistutilsPlatformError <EOL> from distutils . file_util import write_file <EOL> from distutils . util import convert_path , subst_vars , change_root <EOL> from distutils . util import get_platform <EOL> from distutils . errors import DistutilsOptionError <EOL> from site import USER_BASE <EOL> from site import USER_SITE <EOL> if sys . version < \"<STR_LIT>\" : <EOL> WINDOWS_SCHEME = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:data>' : '<STR_LIT>' , <EOL> } <EOL> else : <EOL> WINDOWS_SCHEME = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:data>' : '<STR_LIT>' , <EOL> } <EOL> INSTALL_SCHEMES = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:data>' : '<STR_LIT>' , <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:data>' : '<STR_LIT>' , <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:data>' : '<STR_LIT>' , <EOL> } , <EOL> '<STR_LIT>' : WINDOWS_SCHEME , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:data>' : '<STR_LIT>' , <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:data>' : '<STR_LIT>' , <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:data>' : '<STR_LIT>' , <EOL> } , <EOL> } <EOL> SCHEME_KEYS = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:data>' ) <EOL> class install ( Command ) : <EOL> description = \"<STR_LIT>\" <EOL> user_options = [ <EOL> ( '<STR_LIT>' , None , <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , None , <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , None , <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT:user>' , None , <EOL> \"<STR_LIT>\" % USER_SITE ) , <EOL> ( '<STR_LIT>' , None , <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , None , <EOL> \"<STR_LIT>\" + <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , None , <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , None , <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , None , <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , None , <EOL> \"<STR_LIT>\" + <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , None , <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , None , <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , None , <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , '<STR_LIT:c>' , \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , None , \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , '<STR_LIT:O>' , <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , '<STR_LIT:f>' , <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , None , <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , None , <EOL> \"<STR_LIT>\" ) , <EOL> ] <EOL> boolean_options = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:user>' ] <EOL> negative_opt = { '<STR_LIT>' : '<STR_LIT>' } <EOL> def initialize_options ( self ) : <EOL> self . prefix = None <EOL> self . exec_prefix = None <EOL> self . home = None <EOL> self . user = <NUM_LIT:0> <EOL> self . install_base = None <EOL> self . install_platbase = None <EOL> self . root = None <EOL> self . install_purelib = None <EOL> self . install_platlib = None <EOL> self . install_headers = None <EOL> self . install_lib = None <EOL> self . install_scripts = None <EOL> self . install_data = None <EOL> self . install_userbase = USER_BASE <EOL> self . install_usersite = USER_SITE <EOL> self . compile = None <EOL> self . optimize = None <EOL> self . extra_path = None <EOL> self . install_path_file = <NUM_LIT:1> <EOL> self . force = <NUM_LIT:0> <EOL> self . skip_build = <NUM_LIT:0> <EOL> self . warn_dir = <NUM_LIT:1> <EOL> self . build_base = None <EOL> self . build_lib = None <EOL> self . record = None <EOL> def finalize_options ( self ) : <EOL> if ( ( self . prefix or self . exec_prefix or self . home ) and <EOL> ( self . install_base or self . install_platbase ) ) : <EOL> raise DistutilsOptionError , ( \"<STR_LIT>\" + <EOL> \"<STR_LIT>\" ) <EOL> if self . home and ( self . prefix or self . exec_prefix ) : <EOL> raise DistutilsOptionError , \"<STR_LIT>\" <EOL> if self . user and ( self . prefix or self . exec_prefix or self . home or <EOL> self . install_base or self . install_platbase ) : <EOL> raise DistutilsOptionError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> if os . name != \"<STR_LIT>\" : <EOL> if self . exec_prefix : <EOL> self . warn ( \"<STR_LIT>\" ) <EOL> self . exec_prefix = None <EOL> self . dump_dirs ( \"<STR_LIT>\" ) <EOL> if os . name == '<STR_LIT>' : <EOL> self . finalize_unix ( ) <EOL> else : <EOL> self . finalize_other ( ) <EOL> self . dump_dirs ( \"<STR_LIT>\" ) <EOL> py_version = ( string . split ( sys . version ) ) [ <NUM_LIT:0> ] <EOL> ( prefix , exec_prefix ) = get_config_vars ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . config_vars = { '<STR_LIT>' : self . distribution . get_name ( ) , <EOL> '<STR_LIT>' : self . distribution . get_version ( ) , <EOL> '<STR_LIT>' : self . distribution . get_fullname ( ) , <EOL> '<STR_LIT>' : py_version , <EOL> '<STR_LIT>' : py_version [ <NUM_LIT:0> : <NUM_LIT:3> ] , <EOL> '<STR_LIT>' : py_version [ <NUM_LIT:0> ] + py_version [ <NUM_LIT:2> ] , <EOL> '<STR_LIT>' : prefix , <EOL> '<STR_LIT>' : prefix , <EOL> '<STR_LIT>' : exec_prefix , <EOL> '<STR_LIT>' : exec_prefix , <EOL> '<STR_LIT>' : self . install_userbase , <EOL> '<STR_LIT>' : self . install_usersite , <EOL> } <EOL> self . expand_basedirs ( ) <EOL> self . dump_dirs ( \"<STR_LIT>\" ) <EOL> self . config_vars [ '<STR_LIT>' ] = self . install_base <EOL> self . config_vars [ '<STR_LIT>' ] = self . install_platbase <EOL> if DEBUG : <EOL> from pprint import pprint <EOL> print \"<STR_LIT>\" <EOL> pprint ( self . config_vars ) <EOL> self . expand_dirs ( ) <EOL> self . dump_dirs ( \"<STR_LIT>\" ) <EOL> if self . user : <EOL> self . create_home_path ( ) <EOL> if self . install_lib is None : <EOL> if self . distribution . ext_modules : <EOL> self . install_lib = self . install_platlib <EOL> else : <EOL> self . install_lib = self . install_purelib <EOL> self . convert_paths ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT:data>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . handle_extra_path ( ) <EOL> self . install_libbase = self . install_lib <EOL> self . install_lib = os . path . join ( self . install_lib , self . extra_dirs ) <EOL>"}
{"rec_id": "2178", "recitation_code": "def handle extra path ( self ) :", "input_code_id": 25328, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from distutils import log <EOL> __revision__ = \"<STR_LIT>\" <EOL> import sys , os , string <EOL> from types import * <EOL> from distutils . core import Command <EOL> from distutils . debug import DEBUG <EOL> from distutils . sysconfig import get_config_vars <EOL> from distutils . errors import DistutilsPlatformError <EOL> from distutils . file_util import write_file <EOL> from distutils . util import convert_path , subst_vars , change_root <EOL> from distutils . util import get_platform <EOL> from distutils . errors import DistutilsOptionError <EOL> from site import USER_BASE <EOL> from site import USER_SITE <EOL> if sys . version < \"<STR_LIT>\" : <EOL> WINDOWS_SCHEME = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:data>' : '<STR_LIT>' , <EOL> } <EOL> else : <EOL> WINDOWS_SCHEME = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:data>' : '<STR_LIT>' , <EOL> } <EOL> INSTALL_SCHEMES = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:data>' : '<STR_LIT>' , <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:data>' : '<STR_LIT>' , <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:data>' : '<STR_LIT>' , <EOL> } , <EOL> '<STR_LIT>' : WINDOWS_SCHEME , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:data>' : '<STR_LIT>' , <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:data>' : '<STR_LIT>' , <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:data>' : '<STR_LIT>' , <EOL> } , <EOL> } <EOL> SCHEME_KEYS = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:data>' ) <EOL> class install ( Command ) : <EOL> description = \"<STR_LIT>\" <EOL> user_options = [ <EOL> ( '<STR_LIT>' , None , <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , None , <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , None , <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT:user>' , None , <EOL> \"<STR_LIT>\" % USER_SITE ) , <EOL> ( '<STR_LIT>' , None , <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , None , <EOL> \"<STR_LIT>\" + <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , None , <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , None , <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , None , <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , None , <EOL> \"<STR_LIT>\" + <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , None , <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , None , <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , None , <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , '<STR_LIT:c>' , \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , None , \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , '<STR_LIT:O>' , <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , '<STR_LIT:f>' , <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , None , <EOL> \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , None , <EOL> \"<STR_LIT>\" ) , <EOL> ] <EOL> boolean_options = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:user>' ] <EOL> negative_opt = { '<STR_LIT>' : '<STR_LIT>' } <EOL> def initialize_options ( self ) : <EOL> self . prefix = None <EOL> self . exec_prefix = None <EOL> self . home = None <EOL> self . user = <NUM_LIT:0> <EOL> self . install_base = None <EOL> self . install_platbase = None <EOL> self . root = None <EOL> self . install_purelib = None <EOL> self . install_platlib = None <EOL> self . install_headers = None <EOL> self . install_lib = None <EOL> self . install_scripts = None <EOL> self . install_data = None <EOL> self . install_userbase = USER_BASE <EOL> self . install_usersite = USER_SITE <EOL> self . compile = None <EOL> self . optimize = None <EOL> self . extra_path = None <EOL> self . install_path_file = <NUM_LIT:1> <EOL> self . force = <NUM_LIT:0> <EOL> self . skip_build = <NUM_LIT:0> <EOL> self . warn_dir = <NUM_LIT:1> <EOL> self . build_base = None <EOL> self . build_lib = None <EOL> self . record = None <EOL> def finalize_options ( self ) : <EOL> if ( ( self . prefix or self . exec_prefix or self . home ) and <EOL> ( self . install_base or self . install_platbase ) ) : <EOL> raise DistutilsOptionError , ( \"<STR_LIT>\" + <EOL> \"<STR_LIT>\" ) <EOL> if self . home and ( self . prefix or self . exec_prefix ) : <EOL> raise DistutilsOptionError , \"<STR_LIT>\" <EOL> if self . user and ( self . prefix or self . exec_prefix or self . home or <EOL> self . install_base or self . install_platbase ) : <EOL> raise DistutilsOptionError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> if os . name != \"<STR_LIT>\" : <EOL> if self . exec_prefix : <EOL> self . warn ( \"<STR_LIT>\" ) <EOL> self . exec_prefix = None <EOL> self . dump_dirs ( \"<STR_LIT>\" ) <EOL> if os . name == '<STR_LIT>' : <EOL> self . finalize_unix ( ) <EOL> else : <EOL> self . finalize_other ( ) <EOL> self . dump_dirs ( \"<STR_LIT>\" ) <EOL> py_version = ( string . split ( sys . version ) ) [ <NUM_LIT:0> ] <EOL> ( prefix , exec_prefix ) = get_config_vars ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . config_vars = { '<STR_LIT>' : self . distribution . get_name ( ) , <EOL> '<STR_LIT>' : self . distribution . get_version ( ) , <EOL> '<STR_LIT>' : self . distribution . get_fullname ( ) , <EOL> '<STR_LIT>' : py_version , <EOL> '<STR_LIT>' : py_version [ <NUM_LIT:0> : <NUM_LIT:3> ] , <EOL> '<STR_LIT>' : py_version [ <NUM_LIT:0> ] + py_version [ <NUM_LIT:2> ] , <EOL> '<STR_LIT>' : prefix , <EOL> '<STR_LIT>' : prefix , <EOL> '<STR_LIT>' : exec_prefix , <EOL> '<STR_LIT>' : exec_prefix , <EOL> '<STR_LIT>' : self . install_userbase , <EOL> '<STR_LIT>' : self . install_usersite , <EOL> } <EOL> self . expand_basedirs ( ) <EOL> self . dump_dirs ( \"<STR_LIT>\" ) <EOL> self . config_vars [ '<STR_LIT>' ] = self . install_base <EOL> self . config_vars [ '<STR_LIT>' ] = self . install_platbase <EOL> if DEBUG : <EOL> from pprint import pprint <EOL> print \"<STR_LIT>\" <EOL> pprint ( self . config_vars ) <EOL> self . expand_dirs ( ) <EOL> self . dump_dirs ( \"<STR_LIT>\" ) <EOL> if self . user : <EOL> self . create_home_path ( ) <EOL> if self . install_lib is None : <EOL> if self . distribution . ext_modules : <EOL> self . install_lib = self . install_platlib <EOL> else : <EOL> self . install_lib = self . install_purelib <EOL> self . convert_paths ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT:data>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . handle_extra_path ( ) <EOL> self . install_libbase = self . install_lib <EOL> self . install_lib = os . path . join ( self . install_lib , self . extra_dirs ) <EOL>"}
{"rec_id": "2453", "recitation_code": "return self . required + self . optional", "input_code_id": 2453, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from openid . message import registerNamespaceAlias , NamespaceAliasRegistrationError <EOL> from openid . extension import Extension <EOL> import logging <EOL> try : <EOL> str <EOL> except NameError : <EOL> str = ( str , str ) <EOL> __all__ = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> data_fields = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:email>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> def checkFieldName ( field_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if field_name not in data_fields : <EOL> raise ValueError ( '<STR_LIT>' % <EOL> ( field_name , ) ) <EOL> ns_uri_1_0 = '<STR_LIT>' <EOL> ns_uri_1_1 = '<STR_LIT>' <EOL> ns_uri = ns_uri_1_1 <EOL> try : <EOL> registerNamespaceAlias ( ns_uri_1_1 , '<STR_LIT>' ) <EOL> except NamespaceAliasRegistrationError as e : <EOL> logging . exception ( '<STR_LIT>' % ( ns_uri_1_1 , <EOL> '<STR_LIT>' , str ( e ) , ) ) <EOL> def supportsSReg ( endpoint ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return ( endpoint . usesExtension ( ns_uri_1_1 ) or <EOL> endpoint . usesExtension ( ns_uri_1_0 ) ) <EOL> class SRegNamespaceError ( ValueError ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def getSRegNS ( message ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for sreg_ns_uri in [ ns_uri_1_1 , ns_uri_1_0 ] : <EOL> alias = message . namespaces . getAlias ( sreg_ns_uri ) <EOL> if alias is not None : <EOL> break <EOL> else : <EOL> sreg_ns_uri = ns_uri_1_1 <EOL> try : <EOL> message . namespaces . addAlias ( ns_uri_1_1 , '<STR_LIT>' ) <EOL> except KeyError as why : <EOL> raise SRegNamespaceError ( why ) <EOL> return sreg_ns_uri <EOL> class SRegRequest ( Extension ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ns_alias = '<STR_LIT>' <EOL> def __init__ ( self , required = None , optional = None , policy_url = None , <EOL> sreg_ns_uri = ns_uri ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> Extension . __init__ ( self ) <EOL> self . required = [ ] <EOL> self . optional = [ ] <EOL> self . policy_url = policy_url <EOL> self . ns_uri = sreg_ns_uri <EOL> if required : <EOL> self . requestFields ( required , required = True , strict = True ) <EOL> if optional : <EOL> self . requestFields ( optional , required = False , strict = True ) <EOL> _getSRegNS = staticmethod ( getSRegNS ) <EOL> def fromOpenIDRequest ( cls , request ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self = cls ( ) <EOL> message = request . message . copy ( ) <EOL> self . ns_uri = self . _getSRegNS ( message ) <EOL> args = message . getArgs ( self . ns_uri ) <EOL> self . parseExtensionArgs ( args ) <EOL> return self <EOL> fromOpenIDRequest = classmethod ( fromOpenIDRequest ) <EOL> def parseExtensionArgs ( self , args , strict = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for list_name in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> required = ( list_name == '<STR_LIT>' ) <EOL> items = args . get ( list_name ) <EOL> if items : <EOL> for field_name in items . split ( '<STR_LIT:U+002C>' ) : <EOL> try : <EOL> self . requestField ( field_name , required , strict ) <EOL> except ValueError : <EOL> if strict : <EOL> raise <EOL> self . policy_url = args . get ( '<STR_LIT>' ) <EOL> def allRequestedFields ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . required + self . optional <EOL> def wereFieldsRequested ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>"}
{"rec_id": "2453", "recitation_code": "return self . required + self . optional", "input_code_id": 48358, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from openid . message import registerNamespaceAlias , NamespaceAliasRegistrationError <EOL> from openid . extension import Extension <EOL> import logging <EOL> try : <EOL> basestring <EOL> except NameError : <EOL> basestring = ( str , unicode ) <EOL> __all__ = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> data_fields = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:email>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> def checkFieldName ( field_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if field_name not in data_fields : <EOL> raise ValueError ( '<STR_LIT>' % <EOL> ( field_name , ) ) <EOL> ns_uri_1_0 = '<STR_LIT>' <EOL> ns_uri_1_1 = '<STR_LIT>' <EOL> ns_uri = ns_uri_1_1 <EOL> try : <EOL> registerNamespaceAlias ( ns_uri_1_1 , '<STR_LIT>' ) <EOL> except NamespaceAliasRegistrationError , e : <EOL> logging . exception ( '<STR_LIT>' % ( ns_uri_1_1 , <EOL> '<STR_LIT>' , str ( e ) , ) ) <EOL> def supportsSReg ( endpoint ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return ( endpoint . usesExtension ( ns_uri_1_1 ) or <EOL> endpoint . usesExtension ( ns_uri_1_0 ) ) <EOL> class SRegNamespaceError ( ValueError ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def getSRegNS ( message ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for sreg_ns_uri in [ ns_uri_1_1 , ns_uri_1_0 ] : <EOL> alias = message . namespaces . getAlias ( sreg_ns_uri ) <EOL> if alias is not None : <EOL> break <EOL> else : <EOL> sreg_ns_uri = ns_uri_1_1 <EOL> try : <EOL> message . namespaces . addAlias ( ns_uri_1_1 , '<STR_LIT>' ) <EOL> except KeyError , why : <EOL> raise SRegNamespaceError ( why [ <NUM_LIT:0> ] ) <EOL> return sreg_ns_uri <EOL> class SRegRequest ( Extension ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ns_alias = '<STR_LIT>' <EOL> def __init__ ( self , required = None , optional = None , policy_url = None , <EOL> sreg_ns_uri = ns_uri ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> Extension . __init__ ( self ) <EOL> self . required = [ ] <EOL> self . optional = [ ] <EOL> self . policy_url = policy_url <EOL> self . ns_uri = sreg_ns_uri <EOL> if required : <EOL> self . requestFields ( required , required = True , strict = True ) <EOL> if optional : <EOL> self . requestFields ( optional , required = False , strict = True ) <EOL> _getSRegNS = staticmethod ( getSRegNS ) <EOL> def fromOpenIDRequest ( cls , request ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self = cls ( ) <EOL> message = request . message . copy ( ) <EOL> self . ns_uri = self . _getSRegNS ( message ) <EOL> args = message . getArgs ( self . ns_uri ) <EOL> self . parseExtensionArgs ( args ) <EOL> return self <EOL> fromOpenIDRequest = classmethod ( fromOpenIDRequest ) <EOL> def parseExtensionArgs ( self , args , strict = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for list_name in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> required = ( list_name == '<STR_LIT>' ) <EOL> items = args . get ( list_name ) <EOL> if items : <EOL> for field_name in items . split ( '<STR_LIT:U+002C>' ) : <EOL> try : <EOL> self . requestField ( field_name , required , strict ) <EOL> except ValueError : <EOL> if strict : <EOL> raise <EOL> self . policy_url = args . get ( '<STR_LIT>' ) <EOL> def allRequestedFields ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . required + self . optional <EOL> def wereFieldsRequested ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>"}
{"rec_id": "2716", "recitation_code": "mode . enabled = True", "input_code_id": 2716, "input": "<s> from pyqode . qt . QtTest import QTest <EOL> from pyqode . core import api <EOL> from pyqode . core import modes <EOL> from pyqode . core . api import TextHelper <EOL> def test_enabled ( editor ) : <EOL> mode = editor . modes . get ( modes . IndenterMode ) <EOL> assert mode . enabled <EOL> mode . enabled = False <EOL> mode . enabled = True <EOL> def test_indent_selection ( editor ) : <EOL> mode = editor . modes . get ( modes . IndenterMode ) <EOL> TextHelper ( editor ) . select_lines ( ) <EOL> mode . indent ( ) <EOL> mode . unindent ( ) <EOL>"}
{"rec_id": "2716", "recitation_code": "mode . enabled = True", "input_code_id": 69395, "input": "<s> from pyqode . qt . QtTest import QTest <EOL> from pyqode . core import modes <EOL> from test . helpers import editor_open <EOL> def get_mode ( editor ) : <EOL> return editor . modes . get ( modes . PygmentsSyntaxHighlighter ) <EOL> def test_enabled ( editor ) : <EOL> mode = get_mode ( editor ) <EOL> assert mode . enabled <EOL> mode . enabled = False <EOL> mode . enabled = True <EOL>"}
{"rec_id": "2738", "recitation_code": "def run ( self , parsed args ) :", "input_code_id": 2738, "input": "<s> import requests <EOL> from st2actions . runners . pythonrunner import Action <EOL> class GetMetricDataAction ( Action ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( GetMetricDataAction , self ) . __init__ ( * args , ** kwargs ) <EOL> self . base_url = '<STR_LIT>' <EOL> self . metrics_url = '<STR_LIT>' <EOL> self . url = None <EOL> self . headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL>"}
{"rec_id": "2738", "recitation_code": "def run ( self , parsed args ) :", "input_code_id": 52527, "input": "<s> import sys <EOL> from st2actions . runners . pythonrunner import Action <EOL> class CheckPermission ( Action ) : <EOL>"}
{"rec_id": "2738", "recitation_code": "def run ( self , parsed args ) :", "input_code_id": 83221, "input": "<s> from st2actions . runners . pythonrunner import Action <EOL> from lib . get_scan_list import GetScanList <EOL> from lib . get_scan_executions import GetScanExecutions <EOL> class ListScanExecutions ( Action ) : <EOL>"}
{"rec_id": "2750", "recitation_code": "fig = figure ( )", "input_code_id": 2750, "input": "<s> from math import pi <EOL> import pandas as pd <EOL> from bokeh . plotting import figure , show , output_file <EOL> from bokeh . sampledata . stocks import MSFT <EOL> df = pd . DataFrame ( MSFT ) [ : <NUM_LIT:50> ] <EOL> df [ \"<STR_LIT:date>\" ] = pd . to_datetime ( df [ \"<STR_LIT:date>\" ] ) <EOL> mids = ( df . open + df . close ) / <NUM_LIT:2> <EOL> spans = abs ( df . close - df . open ) <EOL> inc = df . close > df . open <EOL> dec = df . open > df . close <EOL>"}
{"rec_id": "2750", "recitation_code": "fig = figure ( )", "input_code_id": 23601, "input": "<s> from math import pi <EOL> import pandas as pd <EOL> from bokeh . models . formatters import TickFormatter , String , List <EOL> from bokeh . plotting import figure , show , output_file <EOL> from bokeh . sampledata . stocks import MSFT <EOL> class DateGapTickFormatter ( TickFormatter ) : <EOL> '''<STR_LIT>''' <EOL> date_labels = List ( String , help = \"\"\"<STR_LIT>\"\"\" ) <EOL> __implementation__ = \"\"\"<STR_LIT>\"\"\" <EOL> df = pd . DataFrame ( MSFT ) [ : <NUM_LIT:50> ] <EOL> date_labels = [ date . strftime ( '<STR_LIT>' ) for date in pd . to_datetime ( df [ \"<STR_LIT:date>\" ] ) ] <EOL> mids = ( df . open + df . close ) / <NUM_LIT:2> <EOL> spans = abs ( df . close - df . open ) <EOL>"}
{"rec_id": "2778", "recitation_code": "return Element ( qname = ( FORMNS , ' image ' ) , * * args )", "input_code_id": 2778, "input": "<s> from . namespaces import FORMNS <EOL> from . element import Element <EOL> def Button ( ** args ) : <EOL> return Element ( qname = ( FORMNS , '<STR_LIT>' ) , ** args ) <EOL> def Checkbox ( ** args ) : <EOL> return Element ( qname = ( FORMNS , '<STR_LIT>' ) , ** args ) <EOL> def Column ( ** args ) : <EOL> return Element ( qname = ( FORMNS , '<STR_LIT>' ) , ** args ) <EOL> def Combobox ( ** args ) : <EOL> return Element ( qname = ( FORMNS , '<STR_LIT>' ) , ** args ) <EOL> def ConnectionResource ( ** args ) : <EOL> return Element ( qname = ( FORMNS , '<STR_LIT>' ) , ** args ) <EOL> def Date ( ** args ) : <EOL> return Element ( qname = ( FORMNS , '<STR_LIT:date>' ) , ** args ) <EOL> def File ( ** args ) : <EOL> return Element ( qname = ( FORMNS , '<STR_LIT:file>' ) , ** args ) <EOL> def FixedText ( ** args ) : <EOL> return Element ( qname = ( FORMNS , '<STR_LIT>' ) , ** args ) <EOL> def Form ( ** args ) : <EOL> return Element ( qname = ( FORMNS , '<STR_LIT>' ) , ** args ) <EOL> def FormattedText ( ** args ) : <EOL> return Element ( qname = ( FORMNS , '<STR_LIT>' ) , ** args ) <EOL> def Frame ( ** args ) : <EOL> return Element ( qname = ( FORMNS , '<STR_LIT>' ) , ** args ) <EOL> def GenericControl ( ** args ) : <EOL> return Element ( qname = ( FORMNS , '<STR_LIT>' ) , ** args ) <EOL> def Grid ( ** args ) : <EOL> return Element ( qname = ( FORMNS , '<STR_LIT>' ) , ** args ) <EOL> def Hidden ( ** args ) : <EOL> return Element ( qname = ( FORMNS , '<STR_LIT>' ) , ** args ) <EOL> def Image ( ** args ) : <EOL>"}
{"rec_id": "2778", "recitation_code": "return Element ( qname = ( FORMNS , ' image ' ) , * * args )", "input_code_id": 74956, "input": "<s> from namespaces import FORMNS <EOL> from element import Element <EOL> def Button ( ** args ) : <EOL> return Element ( qname = ( FORMNS , '<STR_LIT>' ) , ** args ) <EOL> def Checkbox ( ** args ) : <EOL> return Element ( qname = ( FORMNS , '<STR_LIT>' ) , ** args ) <EOL> def Column ( ** args ) : <EOL> return Element ( qname = ( FORMNS , '<STR_LIT>' ) , ** args ) <EOL> def Combobox ( ** args ) : <EOL> return Element ( qname = ( FORMNS , '<STR_LIT>' ) , ** args ) <EOL> def ConnectionResource ( ** args ) : <EOL> return Element ( qname = ( FORMNS , '<STR_LIT>' ) , ** args ) <EOL> def Date ( ** args ) : <EOL> return Element ( qname = ( FORMNS , '<STR_LIT:date>' ) , ** args ) <EOL> def File ( ** args ) : <EOL> return Element ( qname = ( FORMNS , '<STR_LIT:file>' ) , ** args ) <EOL> def FixedText ( ** args ) : <EOL> return Element ( qname = ( FORMNS , '<STR_LIT>' ) , ** args ) <EOL> def Form ( ** args ) : <EOL> return Element ( qname = ( FORMNS , '<STR_LIT>' ) , ** args ) <EOL> def FormattedText ( ** args ) : <EOL> return Element ( qname = ( FORMNS , '<STR_LIT>' ) , ** args ) <EOL> def Frame ( ** args ) : <EOL> return Element ( qname = ( FORMNS , '<STR_LIT>' ) , ** args ) <EOL> def GenericControl ( ** args ) : <EOL> return Element ( qname = ( FORMNS , '<STR_LIT>' ) , ** args ) <EOL> def Grid ( ** args ) : <EOL> return Element ( qname = ( FORMNS , '<STR_LIT>' ) , ** args ) <EOL> def Hidden ( ** args ) : <EOL> return Element ( qname = ( FORMNS , '<STR_LIT>' ) , ** args ) <EOL> def Image ( ** args ) : <EOL>"}
{"rec_id": "2888", "recitation_code": "def init ( self , expecting , input ) :", "input_code_id": 2888, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from google . appengine . _internal . antlr3 . constants import INVALID_TOKEN_TYPE <EOL> class BacktrackingFailed ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> class RecognitionException ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , input = None ) : <EOL> Exception . __init__ ( self ) <EOL> self . input = None <EOL> self . index = None <EOL> self . token = None <EOL> self . node = None <EOL> self . c = None <EOL> self . line = None <EOL> self . charPositionInLine = None <EOL> self . approximateLineInfo = False <EOL> if input is not None : <EOL> self . input = input <EOL> self . index = input . index ( ) <EOL> from google . appengine . _internal . antlr3 . streams import TokenStream , CharStream <EOL> from google . appengine . _internal . antlr3 . tree import TreeNodeStream <EOL> if isinstance ( self . input , TokenStream ) : <EOL> self . token = self . input . LT ( <NUM_LIT:1> ) <EOL> self . line = self . token . line <EOL> self . charPositionInLine = self . token . charPositionInLine <EOL> if isinstance ( self . input , TreeNodeStream ) : <EOL> self . extractInformationFromTreeNodeStream ( self . input ) <EOL> else : <EOL> if isinstance ( self . input , CharStream ) : <EOL> self . c = self . input . LT ( <NUM_LIT:1> ) <EOL> self . line = self . input . line <EOL> self . charPositionInLine = self . input . charPositionInLine <EOL> else : <EOL> self . c = self . input . LA ( <NUM_LIT:1> ) <EOL> def extractInformationFromTreeNodeStream ( self , nodes ) : <EOL> from google . appengine . _internal . antlr3 . tree import Tree , CommonTree <EOL> from google . appengine . _internal . antlr3 . tokens import CommonToken <EOL> self . node = nodes . LT ( <NUM_LIT:1> ) <EOL> adaptor = nodes . adaptor <EOL> payload = adaptor . getToken ( self . node ) <EOL> if payload is not None : <EOL> self . token = payload <EOL> if payload . line <= <NUM_LIT:0> : <EOL> i = - <NUM_LIT:1> <EOL> priorNode = nodes . LT ( i ) <EOL> while priorNode is not None : <EOL> priorPayload = adaptor . getToken ( priorNode ) <EOL> if priorPayload is not None and priorPayload . line > <NUM_LIT:0> : <EOL> self . line = priorPayload . line <EOL> self . charPositionInLine = priorPayload . charPositionInLine <EOL> self . approximateLineInfo = True <EOL> break <EOL> i -= <NUM_LIT:1> <EOL> priorNode = nodes . LT ( i ) <EOL> else : <EOL> self . line = payload . line <EOL> self . charPositionInLine = payload . charPositionInLine <EOL> elif isinstance ( self . node , Tree ) : <EOL> self . line = self . node . line <EOL> self . charPositionInLine = self . node . charPositionInLine <EOL> if isinstance ( self . node , CommonTree ) : <EOL> self . token = self . node . token <EOL> else : <EOL> type = adaptor . getType ( self . node ) <EOL> text = adaptor . getText ( self . node ) <EOL> self . token = CommonToken ( type = type , text = text ) <EOL> def getUnexpectedType ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from google . appengine . _internal . antlr3 . streams import TokenStream <EOL> from google . appengine . _internal . antlr3 . tree import TreeNodeStream <EOL> if isinstance ( self . input , TokenStream ) : <EOL> return self . token . type <EOL> elif isinstance ( self . input , TreeNodeStream ) : <EOL> adaptor = self . input . treeAdaptor <EOL> return adaptor . getType ( self . node ) <EOL> else : <EOL> return self . c <EOL> unexpectedType = property ( getUnexpectedType ) <EOL> class MismatchedTokenException ( RecognitionException ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , expecting , input ) : <EOL> RecognitionException . __init__ ( self , input ) <EOL> self . expecting = expecting <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" % ( <EOL> self . getUnexpectedType ( ) , self . expecting <EOL> ) <EOL> __repr__ = __str__ <EOL> class UnwantedTokenException ( MismatchedTokenException ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>"}
{"rec_id": "2888", "recitation_code": "def init ( self , expecting , input ) :", "input_code_id": 41200, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from antlr3 . constants import INVALID_TOKEN_TYPE <EOL> class BacktrackingFailed ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> class RecognitionException ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , input = None ) : <EOL> Exception . __init__ ( self ) <EOL> self . input = None <EOL> self . index = None <EOL> self . token = None <EOL> self . node = None <EOL> self . c = None <EOL> self . line = None <EOL> self . charPositionInLine = None <EOL> self . approximateLineInfo = False <EOL> if input is not None : <EOL> self . input = input <EOL> self . index = input . index ( ) <EOL> from antlr3 . streams import TokenStream , CharStream <EOL> from antlr3 . tree import TreeNodeStream <EOL> if isinstance ( self . input , TokenStream ) : <EOL> self . token = self . input . LT ( <NUM_LIT:1> ) <EOL> self . line = self . token . line <EOL> self . charPositionInLine = self . token . charPositionInLine <EOL> if isinstance ( self . input , TreeNodeStream ) : <EOL> self . extractInformationFromTreeNodeStream ( self . input ) <EOL> else : <EOL> if isinstance ( self . input , CharStream ) : <EOL> self . c = self . input . LT ( <NUM_LIT:1> ) <EOL> self . line = self . input . line <EOL> self . charPositionInLine = self . input . charPositionInLine <EOL> else : <EOL> self . c = self . input . LA ( <NUM_LIT:1> ) <EOL> def extractInformationFromTreeNodeStream ( self , nodes ) : <EOL> from antlr3 . tree import Tree , CommonTree <EOL> from antlr3 . tokens import CommonToken <EOL> self . node = nodes . LT ( <NUM_LIT:1> ) <EOL> adaptor = nodes . adaptor <EOL> payload = adaptor . getToken ( self . node ) <EOL> if payload is not None : <EOL> self . token = payload <EOL> if payload . line <= <NUM_LIT:0> : <EOL> i = - <NUM_LIT:1> <EOL> priorNode = nodes . LT ( i ) <EOL> while priorNode is not None : <EOL> priorPayload = adaptor . getToken ( priorNode ) <EOL> if priorPayload is not None and priorPayload . line > <NUM_LIT:0> : <EOL> self . line = priorPayload . line <EOL> self . charPositionInLine = priorPayload . charPositionInLine <EOL> self . approximateLineInfo = True <EOL> break <EOL> i -= <NUM_LIT:1> <EOL> priorNode = nodes . LT ( i ) <EOL> else : <EOL> self . line = payload . line <EOL> self . charPositionInLine = payload . charPositionInLine <EOL> elif isinstance ( self . node , Tree ) : <EOL> self . line = self . node . line <EOL> self . charPositionInLine = self . node . charPositionInLine <EOL> if isinstance ( self . node , CommonTree ) : <EOL> self . token = self . node . token <EOL> else : <EOL> type = adaptor . getType ( self . node ) <EOL> text = adaptor . getText ( self . node ) <EOL> self . token = CommonToken ( type = type , text = text ) <EOL> def getUnexpectedType ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from antlr3 . streams import TokenStream <EOL> from antlr3 . tree import TreeNodeStream <EOL> if isinstance ( self . input , TokenStream ) : <EOL> return self . token . type <EOL> elif isinstance ( self . input , TreeNodeStream ) : <EOL> adaptor = self . input . treeAdaptor <EOL> return adaptor . getType ( self . node ) <EOL> else : <EOL> return self . c <EOL> unexpectedType = property ( getUnexpectedType ) <EOL> class MismatchedTokenException ( RecognitionException ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , expecting , input ) : <EOL> RecognitionException . __init__ ( self , input ) <EOL> self . expecting = expecting <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" % ( <EOL> self . getUnexpectedType ( ) , self . expecting <EOL> ) <EOL> __repr__ = __str__ <EOL> class UnwantedTokenException ( MismatchedTokenException ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>"}
{"rec_id": "2991", "recitation_code": "if not path spec . HasParent ( ) :", "input_code_id": 2991, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import abc <EOL> from dfvfs . lib import errors <EOL> from dfvfs . vfs import file_system <EOL> class RootOnlyFileSystem ( file_system . FileSystem ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _Close ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return <EOL> def _Open ( self , path_spec , mode = '<STR_LIT:rb>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>"}
{"rec_id": "2991", "recitation_code": "if not path spec . HasParent ( ) :", "input_code_id": 9698, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from dfvfs . lib import definitions <EOL> from dfvfs . lib import errors <EOL> from dfvfs . path import encrypted_stream_path_spec <EOL> from dfvfs . vfs import encrypted_stream_file_entry <EOL> from dfvfs . vfs import root_only_file_system <EOL> class EncryptedStreamFileSystem ( root_only_file_system . RootOnlyFileSystem ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> TYPE_INDICATOR = definitions . TYPE_INDICATOR_ENCRYPTED_STREAM <EOL> def __init__ ( self , resolver_context ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> super ( EncryptedStreamFileSystem , self ) . __init__ ( resolver_context ) <EOL> self . _encryption_method = None <EOL> def _Close ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _encryption_method = None <EOL> def _Open ( self , path_spec , mode = '<STR_LIT:rb>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>"}
{"rec_id": "3027", "recitation_code": "config . add extension ( ' ' , sources = [ ' ' ] ,", "input_code_id": 3027, "input": "<s> import os <EOL> from os . path import join <EOL> import numpy <EOL> from sklearn . _build_utils import get_blas_info <EOL> def configuration ( parent_package = '<STR_LIT>' , top_path = None ) : <EOL> from numpy . distutils . misc_util import Configuration <EOL> config = Configuration ( '<STR_LIT>' , parent_package , top_path ) <EOL> cblas_libs , blas_info = get_blas_info ( ) <EOL> if os . name == '<STR_LIT>' : <EOL> cblas_libs . append ( '<STR_LIT:m>' ) <EOL> config . add_extension ( '<STR_LIT>' , sources = [ '<STR_LIT>' ] , <EOL> libraries = cblas_libs , <EOL> include_dirs = [ join ( '<STR_LIT:..>' , '<STR_LIT:src>' , '<STR_LIT>' ) , <EOL> numpy . get_include ( ) , <EOL> blas_info . pop ( '<STR_LIT>' , [ ] ) ] , <EOL> extra_compile_args = blas_info . pop ( '<STR_LIT>' , <EOL> [ ] ) , ** blas_info ) <EOL>"}
{"rec_id": "3027", "recitation_code": "config . add extension ( ' ' , sources = [ ' ' ] ,", "input_code_id": 49598, "input": "<s> import os <EOL> from skimage . _build import cython <EOL> base_path = os . path . abspath ( os . path . dirname ( __file__ ) ) <EOL> def configuration ( parent_package = '<STR_LIT>' , top_path = None ) : <EOL> from numpy . distutils . misc_util import Configuration , get_numpy_include_dirs <EOL> config = Configuration ( '<STR_LIT>' , parent_package , top_path ) <EOL> cython ( [ '<STR_LIT>' ] , working_path = base_path ) <EOL> config . add_extension ( '<STR_LIT>' , sources = [ '<STR_LIT>' ] , <EOL> include_dirs = [ get_numpy_include_dirs ( ) ] ) <EOL> cython ( [ '<STR_LIT>' ] , working_path = base_path ) <EOL> config . add_extension ( '<STR_LIT>' , sources = [ '<STR_LIT>' ] , <EOL> include_dirs = [ get_numpy_include_dirs ( ) ] ) <EOL>"}
{"rec_id": "3032", "recitation_code": "iteritems = MutableMapping . iteritems", "input_code_id": 3032, "input": "<s> from collections import Mapping , MutableMapping <EOL> try : <EOL> from threading import RLock <EOL> except ImportError : <EOL> class RLock : <EOL> def __enter__ ( self ) : <EOL> pass <EOL> def __exit__ ( self , exc_type , exc_value , traceback ) : <EOL> pass <EOL> try : <EOL> from collections import OrderedDict <EOL> except ImportError : <EOL> from . packages . ordered_dict import OrderedDict <EOL> from . packages . six import iterkeys , itervalues , PY3 <EOL> __all__ = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> _Null = object ( ) <EOL> class RecentlyUsedContainer ( MutableMapping ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ContainerCls = OrderedDict <EOL> def __init__ ( self , maxsize = <NUM_LIT:10> , dispose_func = None ) : <EOL> self . _maxsize = maxsize <EOL> self . dispose_func = dispose_func <EOL> self . _container = self . ContainerCls ( ) <EOL> self . lock = RLock ( ) <EOL> def __getitem__ ( self , key ) : <EOL> with self . lock : <EOL> item = self . _container . pop ( key ) <EOL> self . _container [ key ] = item <EOL> return item <EOL> def __setitem__ ( self , key , value ) : <EOL> evicted_value = _Null <EOL> with self . lock : <EOL> evicted_value = self . _container . get ( key , _Null ) <EOL> self . _container [ key ] = value <EOL> if len ( self . _container ) > self . _maxsize : <EOL> _key , evicted_value = self . _container . popitem ( last = False ) <EOL> if self . dispose_func and evicted_value is not _Null : <EOL> self . dispose_func ( evicted_value ) <EOL> def __delitem__ ( self , key ) : <EOL> with self . lock : <EOL> value = self . _container . pop ( key ) <EOL> if self . dispose_func : <EOL> self . dispose_func ( value ) <EOL> def __len__ ( self ) : <EOL> with self . lock : <EOL> return len ( self . _container ) <EOL> def __iter__ ( self ) : <EOL> raise NotImplementedError ( '<STR_LIT>' ) <EOL> def clear ( self ) : <EOL> with self . lock : <EOL> values = list ( itervalues ( self . _container ) ) <EOL> self . _container . clear ( ) <EOL> if self . dispose_func : <EOL> for value in values : <EOL> self . dispose_func ( value ) <EOL> def keys ( self ) : <EOL> with self . lock : <EOL> return list ( iterkeys ( self . _container ) ) <EOL> _dict_setitem = dict . __setitem__ <EOL> _dict_getitem = dict . __getitem__ <EOL> _dict_delitem = dict . __delitem__ <EOL> _dict_contains = dict . __contains__ <EOL> _dict_setdefault = dict . setdefault <EOL> class HTTPHeaderDict ( dict ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , headers = None , ** kwargs ) : <EOL> dict . __init__ ( self ) <EOL> if headers is not None : <EOL> if isinstance ( headers , HTTPHeaderDict ) : <EOL> self . _copy_from ( headers ) <EOL> else : <EOL> self . extend ( headers ) <EOL> if kwargs : <EOL> self . extend ( kwargs ) <EOL> def __setitem__ ( self , key , val ) : <EOL> return _dict_setitem ( self , key . lower ( ) , ( key , val ) ) <EOL> def __getitem__ ( self , key ) : <EOL> val = _dict_getitem ( self , key . lower ( ) ) <EOL> return '<STR_LIT:U+002CU+0020>' . join ( val [ <NUM_LIT:1> : ] ) <EOL> def __delitem__ ( self , key ) : <EOL> return _dict_delitem ( self , key . lower ( ) ) <EOL> def __contains__ ( self , key ) : <EOL> return _dict_contains ( self , key . lower ( ) ) <EOL> def __eq__ ( self , other ) : <EOL> if not isinstance ( other , Mapping ) and not hasattr ( other , '<STR_LIT>' ) : <EOL> return False <EOL> if not isinstance ( other , type ( self ) ) : <EOL> other = type ( self ) ( other ) <EOL> return dict ( ( k1 , self [ k1 ] ) for k1 in self ) == dict ( ( k2 , other [ k2 ] ) for k2 in other ) <EOL> def __ne__ ( self , other ) : <EOL> return not self . __eq__ ( other ) <EOL> values = MutableMapping . values <EOL> get = MutableMapping . get <EOL> update = MutableMapping . update <EOL> if not PY3 : <EOL> iterkeys = MutableMapping . iterkeys <EOL> itervalues = MutableMapping . itervalues <EOL>"}
{"rec_id": "3032", "recitation_code": "iteritems = MutableMapping . iteritems", "input_code_id": 15756, "input": "<s> from collections import Mapping , MutableMapping <EOL> try : <EOL> from threading import RLock <EOL> except ImportError : <EOL> class RLock : <EOL> def __enter__ ( self ) : <EOL> pass <EOL> def __exit__ ( self , exc_type , exc_value , traceback ) : <EOL> pass <EOL> try : <EOL> from collections import OrderedDict <EOL> except ImportError : <EOL> from . packages . ordered_dict import OrderedDict <EOL> from . packages . six import iterkeys , itervalues , PY3 <EOL> __all__ = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> MULTIPLE_HEADERS_ALLOWED = frozenset ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> _Null = object ( ) <EOL> class RecentlyUsedContainer ( MutableMapping ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ContainerCls = OrderedDict <EOL> def __init__ ( self , maxsize = <NUM_LIT:10> , dispose_func = None ) : <EOL> self . _maxsize = maxsize <EOL> self . dispose_func = dispose_func <EOL> self . _container = self . ContainerCls ( ) <EOL> self . lock = RLock ( ) <EOL> def __getitem__ ( self , key ) : <EOL> with self . lock : <EOL> item = self . _container . pop ( key ) <EOL> self . _container [ key ] = item <EOL> return item <EOL> def __setitem__ ( self , key , value ) : <EOL> evicted_value = _Null <EOL> with self . lock : <EOL> evicted_value = self . _container . get ( key , _Null ) <EOL> self . _container [ key ] = value <EOL> if len ( self . _container ) > self . _maxsize : <EOL> _key , evicted_value = self . _container . popitem ( last = False ) <EOL> if self . dispose_func and evicted_value is not _Null : <EOL> self . dispose_func ( evicted_value ) <EOL> def __delitem__ ( self , key ) : <EOL> with self . lock : <EOL> value = self . _container . pop ( key ) <EOL> if self . dispose_func : <EOL> self . dispose_func ( value ) <EOL> def __len__ ( self ) : <EOL> with self . lock : <EOL> return len ( self . _container ) <EOL> def __iter__ ( self ) : <EOL> raise NotImplementedError ( '<STR_LIT>' ) <EOL> def clear ( self ) : <EOL> with self . lock : <EOL> values = list ( itervalues ( self . _container ) ) <EOL> self . _container . clear ( ) <EOL> if self . dispose_func : <EOL> for value in values : <EOL> self . dispose_func ( value ) <EOL> def keys ( self ) : <EOL> with self . lock : <EOL> return list ( iterkeys ( self . _container ) ) <EOL> _dict_setitem = dict . __setitem__ <EOL> _dict_getitem = dict . __getitem__ <EOL> _dict_delitem = dict . __delitem__ <EOL> _dict_contains = dict . __contains__ <EOL> _dict_setdefault = dict . setdefault <EOL> class HTTPHeaderDict ( dict ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , headers = None , ** kwargs ) : <EOL> dict . __init__ ( self ) <EOL> if headers is not None : <EOL> self . extend ( headers ) <EOL> if kwargs : <EOL> self . extend ( kwargs ) <EOL> def __setitem__ ( self , key , val ) : <EOL> return _dict_setitem ( self , key . lower ( ) , ( key , val ) ) <EOL> def __getitem__ ( self , key ) : <EOL> val = _dict_getitem ( self , key . lower ( ) ) <EOL> return '<STR_LIT:U+002CU+0020>' . join ( val [ <NUM_LIT:1> : ] ) <EOL> def __delitem__ ( self , key ) : <EOL> return _dict_delitem ( self , key . lower ( ) ) <EOL> def __contains__ ( self , key ) : <EOL> return _dict_contains ( self , key . lower ( ) ) <EOL> def __eq__ ( self , other ) : <EOL> if not isinstance ( other , Mapping ) and not hasattr ( other , '<STR_LIT>' ) : <EOL> return False <EOL> if not isinstance ( other , type ( self ) ) : <EOL> other = type ( self ) ( other ) <EOL> return dict ( ( k1 , self [ k1 ] ) for k1 in self ) == dict ( ( k2 , other [ k2 ] ) for k2 in other ) <EOL> def __ne__ ( self , other ) : <EOL> return not self . __eq__ ( other ) <EOL> values = MutableMapping . values <EOL> get = MutableMapping . get <EOL> update = MutableMapping . update <EOL> if not PY3 : <EOL> iterkeys = MutableMapping . iterkeys <EOL> itervalues = MutableMapping . itervalues <EOL>"}
{"rec_id": "3036", "recitation_code": "menu = QtGui . QMenu ( )", "input_code_id": 3036, "input": "<s> import ctypes , os , sys <EOL> libcef_so = os . path . join ( os . path . dirname ( os . path . abspath ( __file__ ) ) , '<STR_LIT>' ) <EOL> if os . path . exists ( libcef_so ) : <EOL> ctypes . CDLL ( libcef_so , ctypes . RTLD_GLOBAL ) <EOL> if <NUM_LIT> <= sys . hexversion < <NUM_LIT> : <EOL> import cefpython_py27 as cefpython <EOL> else : <EOL> raise Exception ( \"<STR_LIT>\" % sys . version ) <EOL> else : <EOL> from cefpython3 import cefpython <EOL> from PyQt4 import QtGui <EOL> from PyQt4 import QtCore <EOL> def GetApplicationPath ( file = None ) : <EOL> import re , os , platform <EOL> if not hasattr ( GetApplicationPath , \"<STR_LIT>\" ) : <EOL> if hasattr ( sys , \"<STR_LIT>\" ) : <EOL> dir = os . path . dirname ( sys . executable ) <EOL> elif \"<STR_LIT>\" in globals ( ) : <EOL> dir = os . path . dirname ( os . path . realpath ( __file__ ) ) <EOL> else : <EOL> dir = os . getcwd ( ) <EOL> GetApplicationPath . dir = dir <EOL> if file is None : <EOL> file = \"<STR_LIT>\" <EOL> if not file . startswith ( \"<STR_LIT:/>\" ) and not file . startswith ( \"<STR_LIT:\\\\>\" ) and ( <EOL> not re . search ( r\"<STR_LIT>\" , file ) ) : <EOL> path = GetApplicationPath . dir + os . sep + file <EOL> if platform . system ( ) == \"<STR_LIT>\" : <EOL> path = re . sub ( r\"<STR_LIT>\" , re . escape ( os . sep ) , path ) <EOL> path = re . sub ( r\"<STR_LIT>\" , \"<STR_LIT>\" , path ) <EOL> return path <EOL> return str ( file ) <EOL> def ExceptHook ( excType , excValue , traceObject ) : <EOL> import traceback , os , time , codecs <EOL> errorMsg = \"<STR_LIT:\\n>\" . join ( traceback . format_exception ( excType , excValue , <EOL> traceObject ) ) <EOL> errorFile = GetApplicationPath ( \"<STR_LIT>\" ) <EOL> try : <EOL> appEncoding = cefpython . g_applicationSettings [ \"<STR_LIT>\" ] <EOL> except : <EOL> appEncoding = \"<STR_LIT:utf-8>\" <EOL> if type ( errorMsg ) == bytes : <EOL> errorMsg = errorMsg . decode ( encoding = appEncoding , errors = \"<STR_LIT:replace>\" ) <EOL> try : <EOL> with codecs . open ( errorFile , mode = \"<STR_LIT:a>\" , encoding = appEncoding ) as fp : <EOL> fp . write ( \"<STR_LIT>\" % ( <EOL> time . strftime ( \"<STR_LIT>\" ) , errorMsg ) ) <EOL> except : <EOL> print ( \"<STR_LIT>\" % ( <EOL> errorFile ) ) <EOL> errorMsg = errorMsg . encode ( \"<STR_LIT:ascii>\" , errors = \"<STR_LIT:replace>\" ) <EOL> errorMsg = errorMsg . decode ( \"<STR_LIT:ascii>\" , errors = \"<STR_LIT:replace>\" ) <EOL> print ( \"<STR_LIT:\\n>\" + errorMsg + \"<STR_LIT:\\n>\" ) <EOL> cefpython . QuitMessageLoop ( ) <EOL> cefpython . Shutdown ( ) <EOL> os . _exit ( <NUM_LIT:1> ) <EOL> class MainWindow ( QtGui . QMainWindow ) : <EOL> mainFrame = None <EOL> def __init__ ( self ) : <EOL> super ( MainWindow , self ) . __init__ ( None ) <EOL> self . createMenu ( ) <EOL> self . mainFrame = MainFrame ( self ) <EOL> self . setCentralWidget ( self . mainFrame ) <EOL> self . resize ( <NUM_LIT> , <NUM_LIT> ) <EOL> self . setWindowTitle ( '<STR_LIT>' ) <EOL> self . setFocusPolicy ( QtCore . Qt . StrongFocus ) <EOL> def createMenu ( self ) : <EOL>"}
{"rec_id": "3036", "recitation_code": "menu = QtGui . QMenu ( )", "input_code_id": 44393, "input": "<s> from PyQt4 import QtCore , QtGui , uic <EOL> from wallet import wallet <EOL> from tablemodel import TableModel , ProxyModel <EOL> class AddressTableModel ( TableModel ) : <EOL> _columns = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> _alignment = [ <EOL> QtCore . Qt . AlignLeft | QtCore . Qt . AlignVCenter , <EOL> QtCore . Qt . AlignCenter | QtCore . Qt . AlignVCenter , <EOL> QtCore . Qt . AlignRight | QtCore . Qt . AlignVCenter , <EOL> ] <EOL> class AddressProxyModel ( ProxyModel ) : <EOL> pass <EOL> class NewAddressDialog ( QtGui . QDialog ) : <EOL> def __init__ ( self , moniker , parent ) : <EOL> QtGui . QDialog . __init__ ( self , parent ) <EOL> uic . loadUi ( uic . getUiPath ( '<STR_LIT>' ) , self ) <EOL> monikers = wallet . get_all_monikers ( ) <EOL> self . cbMoniker . addItems ( monikers ) <EOL> if moniker in monikers : <EOL> self . cbMoniker . setCurrentIndex ( monikers . index ( moniker ) ) <EOL> def get_data ( self ) : <EOL> return { <EOL> '<STR_LIT>' : str ( self . cbMoniker . currentText ( ) ) , <EOL> } <EOL> class ReceivePage ( QtGui . QWidget ) : <EOL> def __init__ ( self , parent ) : <EOL> QtGui . QWidget . __init__ ( self , parent ) <EOL> uic . loadUi ( uic . getUiPath ( '<STR_LIT>' ) , self ) <EOL> self . model = AddressTableModel ( self ) <EOL> self . proxyModel = AddressProxyModel ( self ) <EOL> self . proxyModel . setSourceModel ( self . model ) <EOL> self . proxyModel . setDynamicSortFilter ( True ) <EOL> self . proxyModel . setSortCaseSensitivity ( QtCore . Qt . CaseInsensitive ) <EOL> self . proxyModel . setFilterCaseSensitivity ( QtCore . Qt . CaseInsensitive ) <EOL> self . tableView . setModel ( self . proxyModel ) <EOL> self . tableView . sortByColumn ( <NUM_LIT:0> , QtCore . Qt . AscendingOrder ) <EOL> self . tableView . horizontalHeader ( ) . setResizeMode ( <EOL> <NUM_LIT:0> , QtGui . QHeaderView . Stretch ) <EOL> self . tableView . horizontalHeader ( ) . setResizeMode ( <EOL> <NUM_LIT:1> , QtGui . QHeaderView . ResizeToContents ) <EOL> self . cbMoniker . activated . connect ( <EOL> lambda * args : self . setMonikerFilter ( self . cbMoniker . currentText ( ) ) ) <EOL> self . btnNew . clicked . connect ( self . btnNewClicked ) <EOL> self . btnCopy . clicked . connect ( self . btnCopyClicked ) <EOL> self . tableView . selectionModel ( ) . selectionChanged . connect ( <EOL> self . tableViewSelectionChanged ) <EOL> def update ( self ) : <EOL> self . model . removeRows ( <NUM_LIT:0> , self . model . rowCount ( ) ) <EOL> for moniker in wallet . get_all_monikers ( ) : <EOL> asset = wallet . get_asset_definition ( moniker ) <EOL> for row in wallet . get_received_by_address ( asset ) : <EOL> self . model . addRow ( [ moniker , row [ '<STR_LIT>' ] , asset . format_value ( row [ '<STR_LIT:value>' ] ) ] ) <EOL> moniker = self . cbMoniker . currentText ( ) <EOL> monikers = [ '<STR_LIT>' ] + wallet . get_all_monikers ( ) <EOL> self . cbMoniker . clear ( ) <EOL> self . cbMoniker . addItems ( monikers ) <EOL> if moniker in monikers : <EOL> self . cbMoniker . setCurrentIndex ( monikers . index ( moniker ) ) <EOL> self . setMonikerFilter ( self . cbMoniker . currentText ( ) ) <EOL> def contextMenuEvent ( self , event ) : <EOL>"}
{"rec_id": "3036", "recitation_code": "menu = QtGui . QMenu ( )", "input_code_id": 75175, "input": "<s> import ctypes , os , sys <EOL> libcef_so = os . path . join ( os . path . dirname ( os . path . abspath ( __file__ ) ) , '<STR_LIT>' ) <EOL> if os . path . exists ( libcef_so ) : <EOL> ctypes . CDLL ( libcef_so , ctypes . RTLD_GLOBAL ) <EOL> if <NUM_LIT> <= sys . hexversion < <NUM_LIT> : <EOL> import cefpython_py27 as cefpython <EOL> else : <EOL> raise Exception ( \"<STR_LIT>\" % sys . version ) <EOL> else : <EOL> from cefpython3 import cefpython <EOL> from PyQt4 import QtGui <EOL> from PyQt4 import QtCore <EOL> def GetApplicationPath ( file = None ) : <EOL> import re , os , platform <EOL> if not hasattr ( GetApplicationPath , \"<STR_LIT>\" ) : <EOL> if hasattr ( sys , \"<STR_LIT>\" ) : <EOL> dir = os . path . dirname ( sys . executable ) <EOL> elif \"<STR_LIT>\" in globals ( ) : <EOL> dir = os . path . dirname ( os . path . realpath ( __file__ ) ) <EOL> else : <EOL> dir = os . getcwd ( ) <EOL> GetApplicationPath . dir = dir <EOL> if file is None : <EOL> file = \"<STR_LIT>\" <EOL> if not file . startswith ( \"<STR_LIT:/>\" ) and not file . startswith ( \"<STR_LIT:\\\\>\" ) and ( <EOL> not re . search ( r\"<STR_LIT>\" , file ) ) : <EOL> path = GetApplicationPath . dir + os . sep + file <EOL> if platform . system ( ) == \"<STR_LIT>\" : <EOL> path = re . sub ( r\"<STR_LIT>\" , re . escape ( os . sep ) , path ) <EOL> path = re . sub ( r\"<STR_LIT>\" , \"<STR_LIT>\" , path ) <EOL> return path <EOL> return str ( file ) <EOL> def ExceptHook ( excType , excValue , traceObject ) : <EOL> import traceback , os , time , codecs <EOL> errorMsg = \"<STR_LIT:\\n>\" . join ( traceback . format_exception ( excType , excValue , <EOL> traceObject ) ) <EOL> errorFile = GetApplicationPath ( \"<STR_LIT>\" ) <EOL> try : <EOL> appEncoding = cefpython . g_applicationSettings [ \"<STR_LIT>\" ] <EOL> except : <EOL> appEncoding = \"<STR_LIT:utf-8>\" <EOL> if type ( errorMsg ) == bytes : <EOL> errorMsg = errorMsg . decode ( encoding = appEncoding , errors = \"<STR_LIT:replace>\" ) <EOL> try : <EOL> with codecs . open ( errorFile , mode = \"<STR_LIT:a>\" , encoding = appEncoding ) as fp : <EOL> fp . write ( \"<STR_LIT>\" % ( <EOL> time . strftime ( \"<STR_LIT>\" ) , errorMsg ) ) <EOL> except : <EOL> print ( \"<STR_LIT>\" % ( <EOL> errorFile ) ) <EOL> errorMsg = errorMsg . encode ( \"<STR_LIT:ascii>\" , errors = \"<STR_LIT:replace>\" ) <EOL> errorMsg = errorMsg . decode ( \"<STR_LIT:ascii>\" , errors = \"<STR_LIT:replace>\" ) <EOL> print ( \"<STR_LIT:\\n>\" + errorMsg + \"<STR_LIT:\\n>\" ) <EOL> cefpython . QuitMessageLoop ( ) <EOL> cefpython . Shutdown ( ) <EOL> os . _exit ( <NUM_LIT:1> ) <EOL> class MainWindow ( QtGui . QMainWindow ) : <EOL> mainFrame = None <EOL> def __init__ ( self ) : <EOL> super ( MainWindow , self ) . __init__ ( None ) <EOL> self . createMenu ( ) <EOL> self . mainFrame = MainFrame ( self ) <EOL> self . setCentralWidget ( self . mainFrame ) <EOL> self . resize ( <NUM_LIT> , <NUM_LIT> ) <EOL> self . setWindowTitle ( '<STR_LIT>' ) <EOL> self . setFocusPolicy ( QtCore . Qt . StrongFocus ) <EOL> def createMenu ( self ) : <EOL>"}
{"rec_id": "3070", "recitation_code": "gtk . POS BOTTOM )", "input_code_id": 3070, "input": "<s> import pygtk <EOL> pygtk . require ( '<STR_LIT>' ) <EOL> import gtk <EOL> def make_menu_item ( name , callback , data = None ) : <EOL> item = gtk . MenuItem ( name ) <EOL> item . connect ( \"<STR_LIT>\" , callback , data ) <EOL> item . show ( ) <EOL> return item <EOL> def scale_set_default_values ( scale ) : <EOL> scale . set_update_policy ( gtk . UPDATE_CONTINUOUS ) <EOL> scale . set_digits ( <NUM_LIT:1> ) <EOL> scale . set_value_pos ( gtk . POS_TOP ) <EOL> scale . set_draw_value ( True ) <EOL> class RangeWidgets : <EOL> def cb_pos_menu_select ( self , item , pos ) : <EOL> self . hscale . set_value_pos ( pos ) <EOL> self . vscale . set_value_pos ( pos ) <EOL> def cb_update_menu_select ( self , item , policy ) : <EOL> self . hscale . set_update_policy ( policy ) <EOL> self . vscale . set_update_policy ( policy ) <EOL> def cb_digits_scale ( self , adj ) : <EOL> self . hscale . set_digits ( adj . value ) <EOL> self . vscale . set_digits ( adj . value ) <EOL> def cb_page_size ( self , get , set ) : <EOL> set . page_size = get . value <EOL> set . page_incr = get . value <EOL> set . emit ( \"<STR_LIT>\" ) <EOL> def cb_draw_value ( self , button ) : <EOL> self . hscale . set_draw_value ( button . get_active ( ) ) <EOL> self . vscale . set_draw_value ( button . get_active ( ) ) <EOL> def __init__ ( self ) : <EOL> self . window = gtk . Window ( gtk . WINDOW_TOPLEVEL ) <EOL> self . window . connect ( \"<STR_LIT>\" , lambda w : gtk . main_quit ( ) ) <EOL> self . window . set_title ( \"<STR_LIT>\" ) <EOL> box1 = gtk . VBox ( False , <NUM_LIT:0> ) <EOL> self . window . add ( box1 ) <EOL> box1 . show ( ) <EOL> box2 = gtk . HBox ( False , <NUM_LIT:10> ) <EOL> box2 . set_border_width ( <NUM_LIT:10> ) <EOL> box1 . pack_start ( box2 , True , True , <NUM_LIT:0> ) <EOL> box2 . show ( ) <EOL> adj1 = gtk . Adjustment ( <NUM_LIT:0.0> , <NUM_LIT:0.0> , <NUM_LIT> , <NUM_LIT:0.1> , <NUM_LIT:1.0> , <NUM_LIT:1.0> ) <EOL> self . vscale = gtk . VScale ( adj1 ) <EOL> scale_set_default_values ( self . vscale ) <EOL> box2 . pack_start ( self . vscale , True , True , <NUM_LIT:0> ) <EOL> self . vscale . show ( ) <EOL> box3 = gtk . VBox ( False , <NUM_LIT:10> ) <EOL> box2 . pack_start ( box3 , True , True , <NUM_LIT:0> ) <EOL> box3 . show ( ) <EOL> self . hscale = gtk . HScale ( adj1 ) <EOL> self . hscale . set_size_request ( <NUM_LIT:200> , <NUM_LIT:30> ) <EOL> scale_set_default_values ( self . hscale ) <EOL> box3 . pack_start ( self . hscale , True , True , <NUM_LIT:0> ) <EOL> self . hscale . show ( ) <EOL> scrollbar = gtk . HScrollbar ( adj1 ) <EOL> scrollbar . set_update_policy ( gtk . UPDATE_CONTINUOUS ) <EOL> box3 . pack_start ( scrollbar , True , True , <NUM_LIT:0> ) <EOL> scrollbar . show ( ) <EOL> box2 = gtk . HBox ( False , <NUM_LIT:10> ) <EOL> box2 . set_border_width ( <NUM_LIT:10> ) <EOL> box1 . pack_start ( box2 , True , True , <NUM_LIT:0> ) <EOL> box2 . show ( ) <EOL> button = gtk . CheckButton ( \"<STR_LIT>\" ) <EOL> button . set_active ( True ) <EOL> button . connect ( \"<STR_LIT>\" , self . cb_draw_value ) <EOL> box2 . pack_start ( button , True , True , <NUM_LIT:0> ) <EOL> button . show ( ) <EOL> box2 = gtk . HBox ( False , <NUM_LIT:10> ) <EOL> box2 . set_border_width ( <NUM_LIT:10> ) <EOL> label = gtk . Label ( \"<STR_LIT>\" ) <EOL> box2 . pack_start ( label , False , False , <NUM_LIT:0> ) <EOL> label . show ( ) <EOL> opt = gtk . OptionMenu ( ) <EOL> menu = gtk . Menu ( ) <EOL> item = make_menu_item ( \"<STR_LIT>\" , self . cb_pos_menu_select , gtk . POS_TOP ) <EOL> menu . append ( item ) <EOL> item = make_menu_item ( \"<STR_LIT>\" , self . cb_pos_menu_select , <EOL>"}
{"rec_id": "3070", "recitation_code": "gtk . POS BOTTOM )", "input_code_id": 12325, "input": "<s> import pygtk <EOL> pygtk . require ( '<STR_LIT>' ) <EOL> import gtk <EOL> def make_menu_item ( name , callback , data = None ) : <EOL> item = gtk . MenuItem ( name ) <EOL> item . connect ( \"<STR_LIT>\" , callback , data ) <EOL> item . show ( ) <EOL> return item <EOL> def scale_set_default_values ( scale ) : <EOL> scale . set_update_policy ( gtk . UPDATE_CONTINUOUS ) <EOL> scale . set_digits ( <NUM_LIT:1> ) <EOL> scale . set_value_pos ( gtk . POS_TOP ) <EOL> scale . set_draw_value ( True ) <EOL> class RangeWidgets : <EOL> def cb_pos_menu_select ( self , item , pos ) : <EOL> self . hscale . set_value_pos ( pos ) <EOL> self . vscale . set_value_pos ( pos ) <EOL> def cb_update_menu_select ( self , item , policy ) : <EOL> self . hscale . set_update_policy ( policy ) <EOL> self . vscale . set_update_policy ( policy ) <EOL> def cb_digits_scale ( self , adj ) : <EOL> self . hscale . set_digits ( adj . value ) <EOL> self . vscale . set_digits ( adj . value ) <EOL> def cb_page_size ( self , get , set ) : <EOL> set . page_size = get . value <EOL> set . page_incr = get . value <EOL> set . emit ( \"<STR_LIT>\" ) <EOL> def cb_draw_value ( self , button ) : <EOL> self . hscale . set_draw_value ( button . get_active ( ) ) <EOL> self . vscale . set_draw_value ( button . get_active ( ) ) <EOL> def __init__ ( self ) : <EOL> self . window = gtk . Window ( gtk . WINDOW_TOPLEVEL ) <EOL> self . window . connect ( \"<STR_LIT>\" , lambda w : gtk . main_quit ( ) ) <EOL> self . window . set_title ( \"<STR_LIT>\" ) <EOL> box1 = gtk . VBox ( False , <NUM_LIT:0> ) <EOL> self . window . add ( box1 ) <EOL> box1 . show ( ) <EOL> box2 = gtk . HBox ( False , <NUM_LIT:10> ) <EOL> box2 . set_border_width ( <NUM_LIT:10> ) <EOL> box1 . pack_start ( box2 , True , True , <NUM_LIT:0> ) <EOL> box2 . show ( ) <EOL> adj1 = gtk . Adjustment ( <NUM_LIT:0.0> , <NUM_LIT:0.0> , <NUM_LIT> , <NUM_LIT:0.1> , <NUM_LIT:1.0> , <NUM_LIT:1.0> ) <EOL> self . vscale = gtk . VScale ( adj1 ) <EOL> scale_set_default_values ( self . vscale ) <EOL> box2 . pack_start ( self . vscale , True , True , <NUM_LIT:0> ) <EOL> self . vscale . show ( ) <EOL> box3 = gtk . VBox ( False , <NUM_LIT:10> ) <EOL> box2 . pack_start ( box3 , True , True , <NUM_LIT:0> ) <EOL> box3 . show ( ) <EOL> self . hscale = gtk . HScale ( adj1 ) <EOL> self . hscale . set_size_request ( <NUM_LIT:200> , <NUM_LIT:30> ) <EOL> scale_set_default_values ( self . hscale ) <EOL> box3 . pack_start ( self . hscale , True , True , <NUM_LIT:0> ) <EOL> self . hscale . show ( ) <EOL> scrollbar = gtk . HScrollbar ( adj1 ) <EOL> scrollbar . set_update_policy ( gtk . UPDATE_CONTINUOUS ) <EOL> box3 . pack_start ( scrollbar , True , True , <NUM_LIT:0> ) <EOL> scrollbar . show ( ) <EOL> box2 = gtk . HBox ( False , <NUM_LIT:10> ) <EOL> box2 . set_border_width ( <NUM_LIT:10> ) <EOL> box1 . pack_start ( box2 , True , True , <NUM_LIT:0> ) <EOL> box2 . show ( ) <EOL> button = gtk . CheckButton ( \"<STR_LIT>\" ) <EOL> button . set_active ( True ) <EOL> button . connect ( \"<STR_LIT>\" , self . cb_draw_value ) <EOL> box2 . pack_start ( button , True , True , <NUM_LIT:0> ) <EOL> button . show ( ) <EOL> box2 = gtk . HBox ( False , <NUM_LIT:10> ) <EOL> box2 . set_border_width ( <NUM_LIT:10> ) <EOL> label = gtk . Label ( \"<STR_LIT>\" ) <EOL> box2 . pack_start ( label , False , False , <NUM_LIT:0> ) <EOL> label . show ( ) <EOL> opt = gtk . OptionMenu ( ) <EOL> menu = gtk . Menu ( ) <EOL> item = make_menu_item ( \"<STR_LIT>\" , self . cb_pos_menu_select , gtk . POS_TOP ) <EOL> menu . append ( item ) <EOL> item = make_menu_item ( \"<STR_LIT>\" , self . cb_pos_menu_select , <EOL>"}
{"rec_id": "3139", "recitation_code": "return formats . localize input ( value )", "input_code_id": 3139, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import , unicode_literals <EOL> import copy <EOL> import datetime <EOL> from itertools import chain <EOL> try : <EOL> from urllib . parse import urljoin <EOL> except ImportError : <EOL> from urlparse import urljoin <EOL> from django . conf import settings <EOL> from django . forms . util import flatatt , to_current_timezone <EOL> from django . utils . datastructures import MultiValueDict , MergeDict <EOL> from django . utils . html import conditional_escape , format_html , format_html_join <EOL> from django . utils . translation import ugettext , ugettext_lazy <EOL> from django . utils . encoding import force_text , python_2_unicode_compatible <EOL> from django . utils . safestring import mark_safe <EOL> from django . utils import datetime_safe , formats , six <EOL> __all__ = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ) <EOL> MEDIA_TYPES = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> @ python_2_unicode_compatible <EOL> class Media ( object ) : <EOL> def __init__ ( self , media = None , ** kwargs ) : <EOL> if media : <EOL> media_attrs = media . __dict__ <EOL> else : <EOL> media_attrs = kwargs <EOL> self . _css = { } <EOL> self . _js = [ ] <EOL> for name in MEDIA_TYPES : <EOL> getattr ( self , '<STR_LIT>' + name ) ( media_attrs . get ( name , None ) ) <EOL> def __str__ ( self ) : <EOL> return self . render ( ) <EOL> def render ( self ) : <EOL> return mark_safe ( '<STR_LIT:\\n>' . join ( chain ( * [ getattr ( self , '<STR_LIT>' + name ) ( ) for name in MEDIA_TYPES ] ) ) ) <EOL> def render_js ( self ) : <EOL> return [ format_html ( '<STR_LIT>' , self . absolute_path ( path ) ) for path in self . _js ] <EOL> def render_css ( self ) : <EOL> media = sorted ( self . _css . keys ( ) ) <EOL> return chain ( * [ <EOL> [ format_html ( '<STR_LIT>' , self . absolute_path ( path ) , medium ) <EOL> for path in self . _css [ medium ] ] <EOL> for medium in media ] ) <EOL> def absolute_path ( self , path , prefix = None ) : <EOL> if path . startswith ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:/>' ) ) : <EOL> return path <EOL> if prefix is None : <EOL> if settings . STATIC_URL is None : <EOL> prefix = settings . MEDIA_URL <EOL> else : <EOL> prefix = settings . STATIC_URL <EOL> return urljoin ( prefix , path ) <EOL> def __getitem__ ( self , name ) : <EOL> \"<STR_LIT>\" <EOL> if name in MEDIA_TYPES : <EOL> return Media ( ** { str ( name ) : getattr ( self , '<STR_LIT:_>' + name ) } ) <EOL> raise KeyError ( '<STR_LIT>' % name ) <EOL> def add_js ( self , data ) : <EOL> if data : <EOL> for path in data : <EOL> if path not in self . _js : <EOL> self . _js . append ( path ) <EOL> def add_css ( self , data ) : <EOL> if data : <EOL> for medium , paths in data . items ( ) : <EOL> for path in paths : <EOL> if not self . _css . get ( medium ) or path not in self . _css [ medium ] : <EOL> self . _css . setdefault ( medium , [ ] ) . append ( path ) <EOL> def __add__ ( self , other ) : <EOL> combined = Media ( ) <EOL> for name in MEDIA_TYPES : <EOL> getattr ( combined , '<STR_LIT>' + name ) ( getattr ( self , '<STR_LIT:_>' + name , None ) ) <EOL> getattr ( combined , '<STR_LIT>' + name ) ( getattr ( other , '<STR_LIT:_>' + name , None ) ) <EOL> return combined <EOL> def media_property ( cls ) : <EOL> def _media ( self ) : <EOL> sup_cls = super ( cls , self ) <EOL> try : <EOL> base = sup_cls . media <EOL> except AttributeError : <EOL> base = Media ( ) <EOL> definition = getattr ( cls , '<STR_LIT>' , None ) <EOL> if definition : <EOL> extend = getattr ( definition , '<STR_LIT>' , True ) <EOL> if extend : <EOL> if extend == True : <EOL> m = base <EOL> else : <EOL> m = Media ( ) <EOL> for medium in extend : <EOL> m = m + base [ medium ] <EOL> return m + Media ( definition ) <EOL> else : <EOL> return Media ( definition ) <EOL> else : <EOL> return base <EOL> return property ( _media ) <EOL> class MediaDefiningClass ( type ) : <EOL> \"<STR_LIT>\" <EOL> def __new__ ( cls , name , bases , attrs ) : <EOL> new_class = super ( MediaDefiningClass , cls ) . __new__ ( cls , name , bases , <EOL> attrs ) <EOL> if '<STR_LIT>' not in attrs : <EOL> new_class . media = media_property ( new_class ) <EOL> return new_class <EOL> @ python_2_unicode_compatible <EOL> class SubWidget ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , parent_widget , name , value , attrs , choices ) : <EOL> self . parent_widget = parent_widget <EOL> self . name , self . value = name , value <EOL> self . attrs , self . choices = attrs , choices <EOL> def __str__ ( self ) : <EOL> args = [ self . name , self . value , self . attrs ] <EOL> if self . choices : <EOL> args . append ( self . choices ) <EOL> return self . parent_widget . render ( * args ) <EOL> class Widget ( six . with_metaclass ( MediaDefiningClass ) ) : <EOL> is_hidden = False <EOL> needs_multipart_form = False <EOL> is_localized = False <EOL> is_required = False <EOL> def __init__ ( self , attrs = None ) : <EOL> if attrs is not None : <EOL> self . attrs = attrs . copy ( ) <EOL> else : <EOL> self . attrs = { } <EOL> def __deepcopy__ ( self , memo ) : <EOL> obj = copy . copy ( self ) <EOL> obj . attrs = self . attrs . copy ( ) <EOL> memo [ id ( self ) ] = obj <EOL> return obj <EOL> def subwidgets ( self , name , value , attrs = None , choices = ( ) ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> yield SubWidget ( self , name , value , attrs , choices ) <EOL> def render ( self , name , value , attrs = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError <EOL> def build_attrs ( self , extra_attrs = None , ** kwargs ) : <EOL> \"<STR_LIT>\" <EOL> attrs = dict ( self . attrs , ** kwargs ) <EOL> if extra_attrs : <EOL> attrs . update ( extra_attrs ) <EOL> return attrs <EOL> def value_from_datadict ( self , data , files , name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return data . get ( name , None ) <EOL> def _has_changed ( self , initial , data ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if data is None : <EOL> data_value = '<STR_LIT>' <EOL> else : <EOL> data_value = data <EOL> if initial is None : <EOL> initial_value = '<STR_LIT>' <EOL> else : <EOL> initial_value = initial <EOL> if force_text ( initial_value ) != force_text ( data_value ) : <EOL> return True <EOL> return False <EOL> def id_for_label ( self , id_ ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return id_ <EOL> class Input ( Widget ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> input_type = None <EOL> def _format_value ( self , value ) : <EOL> if self . is_localized : <EOL> return formats . localize_input ( value ) <EOL> return value <EOL> def render ( self , name , value , attrs = None ) : <EOL> if value is None : <EOL> value = '<STR_LIT>' <EOL> final_attrs = self . build_attrs ( attrs , type = self . input_type , name = name ) <EOL> if value != '<STR_LIT>' : <EOL> final_attrs [ '<STR_LIT:value>' ] = force_text ( self . _format_value ( value ) ) <EOL> return format_html ( '<STR_LIT>' , flatatt ( final_attrs ) ) <EOL> class TextInput ( Input ) : <EOL> input_type = '<STR_LIT:text>' <EOL> def __init__ ( self , attrs = None ) : <EOL> if attrs is not None : <EOL> self . input_type = attrs . pop ( '<STR_LIT:type>' , self . input_type ) <EOL> super ( TextInput , self ) . __init__ ( attrs ) <EOL> class PasswordInput ( TextInput ) : <EOL> input_type = '<STR_LIT:password>' <EOL> def __init__ ( self , attrs = None , render_value = False ) : <EOL> super ( PasswordInput , self ) . __init__ ( attrs ) <EOL> self . render_value = render_value <EOL> def render ( self , name , value , attrs = None ) : <EOL> if not self . render_value : value = None <EOL> return super ( PasswordInput , self ) . render ( name , value , attrs ) <EOL> class HiddenInput ( Input ) : <EOL> input_type = '<STR_LIT>' <EOL> is_hidden = True <EOL> class MultipleHiddenInput ( HiddenInput ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , attrs = None , choices = ( ) ) : <EOL> super ( MultipleHiddenInput , self ) . __init__ ( attrs ) <EOL> self . choices = choices <EOL> def render ( self , name , value , attrs = None , choices = ( ) ) : <EOL> if value is None : value = [ ] <EOL> final_attrs = self . build_attrs ( attrs , type = self . input_type , name = name ) <EOL> id_ = final_attrs . get ( '<STR_LIT:id>' , None ) <EOL> inputs = [ ] <EOL> for i , v in enumerate ( value ) : <EOL> input_attrs = dict ( value = force_text ( v ) , ** final_attrs ) <EOL> if id_ : <EOL> input_attrs [ '<STR_LIT:id>' ] = '<STR_LIT>' % ( id_ , i ) <EOL> inputs . append ( format_html ( '<STR_LIT>' , flatatt ( input_attrs ) ) ) <EOL> return mark_safe ( '<STR_LIT:\\n>' . join ( inputs ) ) <EOL> def value_from_datadict ( self , data , files , name ) : <EOL> if isinstance ( data , ( MultiValueDict , MergeDict ) ) : <EOL> return data . getlist ( name ) <EOL> return data . get ( name , None ) <EOL> class FileInput ( Input ) : <EOL> input_type = '<STR_LIT:file>' <EOL> needs_multipart_form = True <EOL> def render ( self , name , value , attrs = None ) : <EOL> return super ( FileInput , self ) . render ( name , None , attrs = attrs ) <EOL> def value_from_datadict ( self , data , files , name ) : <EOL> \"<STR_LIT>\" <EOL> return files . get ( name , None ) <EOL> def _has_changed ( self , initial , data ) : <EOL> if data is None : <EOL> return False <EOL> return True <EOL> FILE_INPUT_CONTRADICTION = object ( ) <EOL> class ClearableFileInput ( FileInput ) : <EOL> initial_text = ugettext_lazy ( '<STR_LIT>' ) <EOL> input_text = ugettext_lazy ( '<STR_LIT>' ) <EOL> clear_checkbox_label = ugettext_lazy ( '<STR_LIT>' ) <EOL> template_with_initial = '<STR_LIT>' <EOL> template_with_clear = '<STR_LIT>' <EOL> def clear_checkbox_name ( self , name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return name + '<STR_LIT>' <EOL> def clear_checkbox_id ( self , name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return name + '<STR_LIT>' <EOL> def render ( self , name , value , attrs = None ) : <EOL> substitutions = { <EOL> '<STR_LIT>' : self . initial_text , <EOL> '<STR_LIT>' : self . input_text , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : self . clear_checkbox_label , <EOL> } <EOL> template = '<STR_LIT>' <EOL> substitutions [ '<STR_LIT:input>' ] = super ( ClearableFileInput , self ) . render ( name , value , attrs ) <EOL> if value and hasattr ( value , \"<STR_LIT:url>\" ) : <EOL> template = self . template_with_initial <EOL> substitutions [ '<STR_LIT>' ] = format_html ( '<STR_LIT>' , <EOL> value . url , <EOL> force_text ( value ) ) <EOL> if not self . is_required : <EOL> checkbox_name = self . clear_checkbox_name ( name ) <EOL> checkbox_id = self . clear_checkbox_id ( checkbox_name ) <EOL> substitutions [ '<STR_LIT>' ] = conditional_escape ( checkbox_name ) <EOL> substitutions [ '<STR_LIT>' ] = conditional_escape ( checkbox_id ) <EOL> substitutions [ '<STR_LIT>' ] = CheckboxInput ( ) . render ( checkbox_name , False , attrs = { '<STR_LIT:id>' : checkbox_id } ) <EOL> substitutions [ '<STR_LIT>' ] = self . template_with_clear % substitutions <EOL> return mark_safe ( template % substitutions ) <EOL> def value_from_datadict ( self , data , files , name ) : <EOL> upload = super ( ClearableFileInput , self ) . value_from_datadict ( data , files , name ) <EOL> if not self . is_required and CheckboxInput ( ) . value_from_datadict ( <EOL> data , files , self . clear_checkbox_name ( name ) ) : <EOL> if upload : <EOL> return FILE_INPUT_CONTRADICTION <EOL> return False <EOL> return upload <EOL> class Textarea ( Widget ) : <EOL> def __init__ ( self , attrs = None ) : <EOL> default_attrs = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } <EOL> if attrs : <EOL> default_attrs . update ( attrs ) <EOL> super ( Textarea , self ) . __init__ ( default_attrs ) <EOL> def render ( self , name , value , attrs = None ) : <EOL> if value is None : value = '<STR_LIT>' <EOL> final_attrs = self . build_attrs ( attrs , name = name ) <EOL> return format_html ( '<STR_LIT>' , <EOL> flatatt ( final_attrs ) , <EOL> force_text ( value ) ) <EOL> class DateInput ( TextInput ) : <EOL> def __init__ ( self , attrs = None , format = None ) : <EOL> super ( DateInput , self ) . __init__ ( attrs ) <EOL> if format : <EOL> self . format = format <EOL> self . manual_format = True <EOL> else : <EOL> self . format = formats . get_format ( '<STR_LIT>' ) [ <NUM_LIT:0> ] <EOL> self . manual_format = False <EOL> def _format_value ( self , value ) : <EOL> if self . is_localized and not self . manual_format : <EOL> return formats . localize_input ( value ) <EOL> elif hasattr ( value , '<STR_LIT>' ) : <EOL> value = datetime_safe . new_date ( value ) <EOL> return value . strftime ( self . format ) <EOL> return value <EOL> def _has_changed ( self , initial , data ) : <EOL> try : <EOL> input_format = formats . get_format ( '<STR_LIT>' ) [ <NUM_LIT:0> ] <EOL> initial = datetime . datetime . strptime ( initial , input_format ) . date ( ) <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return super ( DateInput , self ) . _has_changed ( self . _format_value ( initial ) , data ) <EOL> class DateTimeInput ( TextInput ) : <EOL> def __init__ ( self , attrs = None , format = None ) : <EOL> super ( DateTimeInput , self ) . __init__ ( attrs ) <EOL> if format : <EOL> self . format = format <EOL> self . manual_format = True <EOL> else : <EOL> self . format = formats . get_format ( '<STR_LIT>' ) [ <NUM_LIT:0> ] <EOL> self . manual_format = False <EOL> def _format_value ( self , value ) : <EOL> if self . is_localized and not self . manual_format : <EOL>"}
{"rec_id": "3139", "recitation_code": "return formats . localize input ( value )", "input_code_id": 41227, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import django . utils . copycompat as copy <EOL> from itertools import chain <EOL> from django . conf import settings <EOL> from django . utils . datastructures import MultiValueDict , MergeDict <EOL> from django . utils . html import escape , conditional_escape <EOL> from django . utils . translation import ugettext <EOL> from django . utils . encoding import StrAndUnicode , force_unicode <EOL> from django . utils . safestring import mark_safe <EOL> from django . utils import datetime_safe , formats <EOL> import time <EOL> import datetime <EOL> from util import flatatt <EOL> from urlparse import urljoin <EOL> __all__ = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ) <EOL> MEDIA_TYPES = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> class Media ( StrAndUnicode ) : <EOL> def __init__ ( self , media = None , ** kwargs ) : <EOL> if media : <EOL> media_attrs = media . __dict__ <EOL> else : <EOL> media_attrs = kwargs <EOL> self . _css = { } <EOL> self . _js = [ ] <EOL> for name in MEDIA_TYPES : <EOL> getattr ( self , '<STR_LIT>' + name ) ( media_attrs . get ( name , None ) ) <EOL> def __unicode__ ( self ) : <EOL> return self . render ( ) <EOL> def render ( self ) : <EOL> return mark_safe ( u'<STR_LIT:\\n>' . join ( chain ( * [ getattr ( self , '<STR_LIT>' + name ) ( ) for name in MEDIA_TYPES ] ) ) ) <EOL> def render_js ( self ) : <EOL> return [ u'<STR_LIT>' % self . absolute_path ( path ) for path in self . _js ] <EOL> def render_css ( self ) : <EOL> media = self . _css . keys ( ) <EOL> media . sort ( ) <EOL> return chain ( * [ <EOL> [ u'<STR_LIT>' % ( self . absolute_path ( path ) , medium ) <EOL> for path in self . _css [ medium ] ] <EOL> for medium in media ] ) <EOL> def absolute_path ( self , path ) : <EOL> if path . startswith ( u'<STR_LIT>' ) or path . startswith ( u'<STR_LIT>' ) or path . startswith ( u'<STR_LIT:/>' ) : <EOL> return path <EOL> return urljoin ( settings . MEDIA_URL , path ) <EOL> def __getitem__ ( self , name ) : <EOL> \"<STR_LIT>\" <EOL> if name in MEDIA_TYPES : <EOL> return Media ( ** { str ( name ) : getattr ( self , '<STR_LIT:_>' + name ) } ) <EOL> raise KeyError ( '<STR_LIT>' % name ) <EOL> def add_js ( self , data ) : <EOL> if data : <EOL> for path in data : <EOL> if path not in self . _js : <EOL> self . _js . append ( path ) <EOL> def add_css ( self , data ) : <EOL> if data : <EOL> for medium , paths in data . items ( ) : <EOL> for path in paths : <EOL> if not self . _css . get ( medium ) or path not in self . _css [ medium ] : <EOL> self . _css . setdefault ( medium , [ ] ) . append ( path ) <EOL> def __add__ ( self , other ) : <EOL> combined = Media ( ) <EOL> for name in MEDIA_TYPES : <EOL> getattr ( combined , '<STR_LIT>' + name ) ( getattr ( self , '<STR_LIT:_>' + name , None ) ) <EOL> getattr ( combined , '<STR_LIT>' + name ) ( getattr ( other , '<STR_LIT:_>' + name , None ) ) <EOL> return combined <EOL> def media_property ( cls ) : <EOL> def _media ( self ) : <EOL> if hasattr ( super ( cls , self ) , '<STR_LIT>' ) : <EOL> base = super ( cls , self ) . media <EOL> else : <EOL> base = Media ( ) <EOL> definition = getattr ( cls , '<STR_LIT>' , None ) <EOL> if definition : <EOL> extend = getattr ( definition , '<STR_LIT>' , True ) <EOL> if extend : <EOL> if extend == True : <EOL> m = base <EOL> else : <EOL> m = Media ( ) <EOL> for medium in extend : <EOL> m = m + base [ medium ] <EOL> return m + Media ( definition ) <EOL> else : <EOL> return Media ( definition ) <EOL> else : <EOL> return base <EOL> return property ( _media ) <EOL> class MediaDefiningClass ( type ) : <EOL> \"<STR_LIT>\" <EOL> def __new__ ( cls , name , bases , attrs ) : <EOL> new_class = super ( MediaDefiningClass , cls ) . __new__ ( cls , name , bases , <EOL> attrs ) <EOL> if '<STR_LIT>' not in attrs : <EOL> new_class . media = media_property ( new_class ) <EOL> return new_class <EOL> class Widget ( object ) : <EOL> __metaclass__ = MediaDefiningClass <EOL> is_hidden = False <EOL> needs_multipart_form = False <EOL> is_localized = False <EOL> def __init__ ( self , attrs = None ) : <EOL> if attrs is not None : <EOL> self . attrs = attrs . copy ( ) <EOL> else : <EOL> self . attrs = { } <EOL> def __deepcopy__ ( self , memo ) : <EOL> obj = copy . copy ( self ) <EOL> obj . attrs = self . attrs . copy ( ) <EOL> memo [ id ( self ) ] = obj <EOL> return obj <EOL> def render ( self , name , value , attrs = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError <EOL> def build_attrs ( self , extra_attrs = None , ** kwargs ) : <EOL> \"<STR_LIT>\" <EOL> attrs = dict ( self . attrs , ** kwargs ) <EOL> if extra_attrs : <EOL> attrs . update ( extra_attrs ) <EOL> return attrs <EOL> def value_from_datadict ( self , data , files , name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return data . get ( name , None ) <EOL> def _has_changed ( self , initial , data ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if data is None : <EOL> data_value = u'<STR_LIT>' <EOL> else : <EOL> data_value = data <EOL> if initial is None : <EOL> initial_value = u'<STR_LIT>' <EOL> else : <EOL> initial_value = initial <EOL> if force_unicode ( initial_value ) != force_unicode ( data_value ) : <EOL> return True <EOL> return False <EOL> def id_for_label ( self , id_ ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return id_ <EOL> id_for_label = classmethod ( id_for_label ) <EOL> class Input ( Widget ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> input_type = None <EOL> def _format_value ( self , value ) : <EOL> if self . is_localized : <EOL> return formats . localize_input ( value ) <EOL> return value <EOL> def render ( self , name , value , attrs = None ) : <EOL> if value is None : <EOL> value = '<STR_LIT>' <EOL> final_attrs = self . build_attrs ( attrs , type = self . input_type , name = name ) <EOL> if value != '<STR_LIT>' : <EOL> final_attrs [ '<STR_LIT:value>' ] = force_unicode ( self . _format_value ( value ) ) <EOL> return mark_safe ( u'<STR_LIT>' % flatatt ( final_attrs ) ) <EOL> class TextInput ( Input ) : <EOL> input_type = '<STR_LIT:text>' <EOL> class PasswordInput ( Input ) : <EOL> input_type = '<STR_LIT:password>' <EOL> def __init__ ( self , attrs = None , render_value = True ) : <EOL> super ( PasswordInput , self ) . __init__ ( attrs ) <EOL> self . render_value = render_value <EOL> def render ( self , name , value , attrs = None ) : <EOL> if not self . render_value : value = None <EOL> return super ( PasswordInput , self ) . render ( name , value , attrs ) <EOL> class HiddenInput ( Input ) : <EOL> input_type = '<STR_LIT>' <EOL> is_hidden = True <EOL> class MultipleHiddenInput ( HiddenInput ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , attrs = None , choices = ( ) ) : <EOL> super ( MultipleHiddenInput , self ) . __init__ ( attrs ) <EOL> self . choices = choices <EOL> def render ( self , name , value , attrs = None , choices = ( ) ) : <EOL> if value is None : value = [ ] <EOL> final_attrs = self . build_attrs ( attrs , type = self . input_type , name = name ) <EOL> id_ = final_attrs . get ( '<STR_LIT:id>' , None ) <EOL> inputs = [ ] <EOL> for i , v in enumerate ( value ) : <EOL> input_attrs = dict ( value = force_unicode ( v ) , ** final_attrs ) <EOL> if id_ : <EOL> input_attrs [ '<STR_LIT:id>' ] = '<STR_LIT>' % ( id_ , i ) <EOL> inputs . append ( u'<STR_LIT>' % flatatt ( input_attrs ) ) <EOL> return mark_safe ( u'<STR_LIT:\\n>' . join ( inputs ) ) <EOL> def value_from_datadict ( self , data , files , name ) : <EOL> if isinstance ( data , ( MultiValueDict , MergeDict ) ) : <EOL> return data . getlist ( name ) <EOL> return data . get ( name , None ) <EOL> class FileInput ( Input ) : <EOL> input_type = '<STR_LIT:file>' <EOL> needs_multipart_form = True <EOL> def render ( self , name , value , attrs = None ) : <EOL> return super ( FileInput , self ) . render ( name , None , attrs = attrs ) <EOL> def value_from_datadict ( self , data , files , name ) : <EOL> \"<STR_LIT>\" <EOL> return files . get ( name , None ) <EOL> def _has_changed ( self , initial , data ) : <EOL> if data is None : <EOL> return False <EOL> return True <EOL> class Textarea ( Widget ) : <EOL> def __init__ ( self , attrs = None ) : <EOL> default_attrs = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } <EOL> if attrs : <EOL> default_attrs . update ( attrs ) <EOL> super ( Textarea , self ) . __init__ ( default_attrs ) <EOL> def render ( self , name , value , attrs = None ) : <EOL> if value is None : value = '<STR_LIT>' <EOL> final_attrs = self . build_attrs ( attrs , name = name ) <EOL> return mark_safe ( u'<STR_LIT>' % ( flatatt ( final_attrs ) , <EOL> conditional_escape ( force_unicode ( value ) ) ) ) <EOL> class DateInput ( Input ) : <EOL> input_type = '<STR_LIT:text>' <EOL> format = '<STR_LIT>' <EOL> def __init__ ( self , attrs = None , format = None ) : <EOL> super ( DateInput , self ) . __init__ ( attrs ) <EOL> if format : <EOL> self . format = format <EOL> self . manual_format = True <EOL> else : <EOL> self . format = formats . get_format ( '<STR_LIT>' ) [ <NUM_LIT:0> ] <EOL> self . manual_format = False <EOL> def _format_value ( self , value ) : <EOL> if self . is_localized and not self . manual_format : <EOL> return formats . localize_input ( value ) <EOL> elif hasattr ( value , '<STR_LIT>' ) : <EOL> value = datetime_safe . new_date ( value ) <EOL> return value . strftime ( self . format ) <EOL> return value <EOL> def _has_changed ( self , initial , data ) : <EOL> try : <EOL> input_format = formats . get_format ( '<STR_LIT>' ) [ <NUM_LIT:0> ] <EOL> initial = datetime . date ( * time . strptime ( initial , input_format ) [ : <NUM_LIT:3> ] ) <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return super ( DateInput , self ) . _has_changed ( self . _format_value ( initial ) , data ) <EOL> class DateTimeInput ( Input ) : <EOL> input_type = '<STR_LIT:text>' <EOL> format = '<STR_LIT>' <EOL> def __init__ ( self , attrs = None , format = None ) : <EOL> super ( DateTimeInput , self ) . __init__ ( attrs ) <EOL> if format : <EOL> self . format = format <EOL> self . manual_format = True <EOL> else : <EOL> self . format = formats . get_format ( '<STR_LIT>' ) [ <NUM_LIT:0> ] <EOL> self . manual_format = False <EOL> def _format_value ( self , value ) : <EOL> if self . is_localized and not self . manual_format : <EOL> return formats . localize_input ( value ) <EOL> elif hasattr ( value , '<STR_LIT>' ) : <EOL> value = datetime_safe . new_datetime ( value ) <EOL> return value . strftime ( self . format ) <EOL> return value <EOL> def _has_changed ( self , initial , data ) : <EOL> try : <EOL> input_format = formats . get_format ( '<STR_LIT>' ) [ <NUM_LIT:0> ] <EOL> initial = datetime . datetime ( * time . strptime ( initial , input_format ) [ : <NUM_LIT:6> ] ) <EOL> except ( TypeError , ValueError ) : <EOL> pass <EOL> return super ( DateTimeInput , self ) . _has_changed ( self . _format_value ( initial ) , data ) <EOL> class TimeInput ( Input ) : <EOL> input_type = '<STR_LIT:text>' <EOL> format = '<STR_LIT>' <EOL> def __init__ ( self , attrs = None , format = None ) : <EOL> super ( TimeInput , self ) . __init__ ( attrs ) <EOL> if format : <EOL> self . format = format <EOL> self . manual_format = True <EOL> else : <EOL> self . format = formats . get_format ( '<STR_LIT>' ) [ <NUM_LIT:0> ] <EOL> self . manual_format = False <EOL> def _format_value ( self , value ) : <EOL> if self . is_localized and not self . manual_format : <EOL>"}
{"rec_id": "3141", "recitation_code": "return user . has perm ( ' ' )", "input_code_id": 3141, "input": "<s> from . . utils . access_permissions import BaseAccessPermissions <EOL> class MotionAccessPermissions ( BaseAccessPermissions ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def can_retrieve ( self , user ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return user . has_perm ( '<STR_LIT>' ) <EOL> def get_serializer_class ( self , user = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from . serializers import MotionSerializer <EOL> return MotionSerializer <EOL> class CategoryAccessPermissions ( BaseAccessPermissions ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def can_retrieve ( self , user ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>"}
{"rec_id": "3141", "recitation_code": "return user . has perm ( ' ' )", "input_code_id": 3734, "input": "<s> from . . utils . access_permissions import BaseAccessPermissions <EOL> class ProjectorAccessPermissions ( BaseAccessPermissions ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def can_retrieve ( self , user ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return user . has_perm ( '<STR_LIT>' ) <EOL> def get_serializer_class ( self , user = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from . serializers import ProjectorSerializer <EOL> return ProjectorSerializer <EOL> class CustomSlideAccessPermissions ( BaseAccessPermissions ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def can_retrieve ( self , user ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return user . has_perm ( '<STR_LIT>' ) <EOL> def get_serializer_class ( self , user = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from . serializers import CustomSlideSerializer <EOL> return CustomSlideSerializer <EOL> class TagAccessPermissions ( BaseAccessPermissions ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def can_retrieve ( self , user ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from . config import config <EOL>"}
{"rec_id": "3147", "recitation_code": "self . check sequence ( 3 , ' ' )", "input_code_id": 3147, "input": "<s> import unittest <EOL> from pyglet import window <EOL> import base_event_sequence <EOL> __noninteractive = True <EOL> class TEST_CLASS ( base_event_sequence . BaseEventSequence ) : <EOL> last_sequence = <NUM_LIT:2> <EOL> def on_resize ( self , width , height ) : <EOL> self . check_sequence ( <NUM_LIT:1> , '<STR_LIT>' ) <EOL> def on_expose ( self ) : <EOL> self . check_sequence ( <NUM_LIT:2> , '<STR_LIT>' ) <EOL> def test_method ( self ) : <EOL>"}
{"rec_id": "3147", "recitation_code": "self . check sequence ( 3 , ' ' )", "input_code_id": 12990, "input": "<s> import unittest <EOL> from pyglet import window <EOL> import base_event_sequence <EOL> __noninteractive = True <EOL> class TEST_CLASS ( base_event_sequence . BaseEventSequence ) : <EOL> last_sequence = <NUM_LIT:2> <EOL> def on_resize ( self , width , height ) : <EOL> self . check_sequence ( <NUM_LIT:1> , '<STR_LIT>' ) <EOL> def on_expose ( self ) : <EOL> self . check_sequence ( <NUM_LIT:2> , '<STR_LIT>' ) <EOL> def test_method ( self ) : <EOL>"}
{"rec_id": "3154", "recitation_code": "class Certificate ( object ) :", "input_code_id": 3154, "input": "<s> '''<STR_LIT>''' <EOL> import re <EOL> __version__ = '<STR_LIT>' <EOL> class CertificateError ( ValueError ) : <EOL> pass <EOL> def _dnsname_match ( dn , hostname , max_wildcards = <NUM_LIT:1> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pats = [ ] <EOL> if not dn : <EOL> return False <EOL> parts = dn . split ( r'<STR_LIT:.>' ) <EOL> leftmost = parts [ <NUM_LIT:0> ] <EOL> remainder = parts [ <NUM_LIT:1> : ] <EOL> wildcards = leftmost . count ( '<STR_LIT:*>' ) <EOL> if wildcards > max_wildcards : <EOL> raise CertificateError ( <EOL> \"<STR_LIT>\" + repr ( dn ) ) <EOL> if not wildcards : <EOL> return dn . lower ( ) == hostname . lower ( ) <EOL> if leftmost == '<STR_LIT:*>' : <EOL> pats . append ( '<STR_LIT>' ) <EOL> elif leftmost . startswith ( '<STR_LIT>' ) or hostname . startswith ( '<STR_LIT>' ) : <EOL> pats . append ( re . escape ( leftmost ) ) <EOL> else : <EOL> pats . append ( re . escape ( leftmost ) . replace ( r'<STR_LIT>' , '<STR_LIT>' ) ) <EOL> for frag in remainder : <EOL> pats . append ( re . escape ( frag ) ) <EOL> pat = re . compile ( r'<STR_LIT>' + r'<STR_LIT>' . join ( pats ) + r'<STR_LIT>' , re . IGNORECASE ) <EOL> return pat . match ( hostname ) <EOL>"}
{"rec_id": "3154", "recitation_code": "class Certificate ( object ) :", "input_code_id": 362, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import re <EOL> __version__ = '<STR_LIT>' <EOL> class CertificateError ( ValueError ) : <EOL> pass <EOL> def _dnsname_match ( dn , hostname , max_wildcards = <NUM_LIT:1> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pats = [ ] <EOL> if not dn : <EOL> return False <EOL> parts = dn . split ( r'<STR_LIT:.>' ) <EOL> leftmost = parts [ <NUM_LIT:0> ] <EOL> remainder = parts [ <NUM_LIT:1> : ] <EOL> wildcards = leftmost . count ( '<STR_LIT:*>' ) <EOL> if wildcards > max_wildcards : <EOL> raise CertificateError ( <EOL> \"<STR_LIT>\" + repr ( dn ) ) <EOL> if not wildcards : <EOL> return dn . lower ( ) == hostname . lower ( ) <EOL> if leftmost == '<STR_LIT:*>' : <EOL> pats . append ( '<STR_LIT>' ) <EOL> elif leftmost . startswith ( '<STR_LIT>' ) or hostname . startswith ( '<STR_LIT>' ) : <EOL> pats . append ( re . escape ( leftmost ) ) <EOL> else : <EOL> pats . append ( re . escape ( leftmost ) . replace ( r'<STR_LIT>' , '<STR_LIT>' ) ) <EOL> for frag in remainder : <EOL> pats . append ( re . escape ( frag ) ) <EOL> pat = re . compile ( r'<STR_LIT>' + r'<STR_LIT>' . join ( pats ) + r'<STR_LIT>' , re . IGNORECASE ) <EOL> return pat . match ( hostname ) <EOL>"}
{"rec_id": "3175", "recitation_code": "sys . path . insert ( 0 , PYTHON DIR )", "input_code_id": 3175, "input": "<s> import os <EOL> import sys <EOL> import uuid , random <EOL> from os . path import dirname , join <EOL> PYTHON_DIR = join ( dirname ( __file__ ) , '<STR_LIT>' ) <EOL> sys . stdout = sys . stderr <EOL> os . environ [ '<STR_LIT>' ] = '<STR_LIT>' <EOL>"}
{"rec_id": "3175", "recitation_code": "sys . path . insert ( 0 , PYTHON DIR )", "input_code_id": 35617, "input": "<s> import os <EOL> import sys <EOL> from os . path import dirname , join <EOL> PYTHON_DIR = join ( dirname ( __file__ ) , '<STR_LIT>' ) <EOL> sys . stdout = sys . stderr <EOL>"}
{"rec_id": "3210", "recitation_code": "url ( r ' ' , views . index , name = ' index ' ) ,", "input_code_id": 3210, "input": "<s> from django . conf . urls import patterns , url , include <EOL> from root import views <EOL> urlpatterns = patterns ( '<STR_LIT>' , <EOL>"}
{"rec_id": "3210", "recitation_code": "url ( r ' ' , views . index , name = ' index ' ) ,", "input_code_id": 10494, "input": "<s> from __future__ import absolute_import <EOL> from django . conf . urls import patterns , url <EOL> from . import views <EOL> urlpatterns = patterns ( '<STR_LIT>' , <EOL>"}
{"rec_id": "3210", "recitation_code": "url ( r ' ' , views . index , name = ' index ' ) ,", "input_code_id": 18165, "input": "<s> from django . conf . urls import patterns , url <EOL> import views <EOL> urlpatterns = patterns ( '<STR_LIT>' , <EOL>"}
{"rec_id": "3210", "recitation_code": "url ( r ' ' , views . index , name = ' index ' ) ,", "input_code_id": 30855, "input": "<s> from django . conf . urls import patterns , include , url <EOL> from . import views <EOL> urlpatterns = patterns ( '<STR_LIT>' , <EOL>"}
{"rec_id": "3210", "recitation_code": "url ( r ' ' , views . index , name = ' index ' ) ,", "input_code_id": 78088, "input": "<s> from django . conf . urls . defaults import patterns , url <EOL> import views <EOL> urlpatterns = patterns ( '<STR_LIT>' , <EOL>"}
{"rec_id": "3210", "recitation_code": "url ( r ' ' , views . index , name = ' index ' ) ,", "input_code_id": 81907, "input": "<s> from __future__ import absolute_import <EOL> from django . conf . urls import patterns , url <EOL> from . import views <EOL> urlpatterns = patterns ( '<STR_LIT>' , <EOL>"}
{"rec_id": "3242", "recitation_code": "from . . toolkit import toolkit object", "input_code_id": 3242, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import <EOL> from . . ui_traits import Image <EOL> from . . editor_factory import EditorFactory <EOL>"}
{"rec_id": "3242", "recitation_code": "from . . toolkit import toolkit object", "input_code_id": 4986, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import <EOL> from traits . api import Range <EOL> from . . editor_factory import EditorWithListFactory <EOL>"}
{"rec_id": "3325", "recitation_code": "assert isinstance ( sub , subnet . Subnet )", "input_code_id": 3325, "input": "<s> import uuid <EOL> from openstack . network . v2 import network <EOL> from openstack . network . v2 import subnet <EOL> from openstack . tests . functional import base <EOL> class TestSubnet ( base . BaseFunctionalTest ) : <EOL> NET_NAME = uuid . uuid4 ( ) . hex <EOL> SUB_NAME = uuid . uuid4 ( ) . hex <EOL> UPDATE_NAME = uuid . uuid4 ( ) . hex <EOL> IPV4 = <NUM_LIT:4> <EOL> CIDR = \"<STR_LIT>\" <EOL> DNS_SERVERS = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> POOL = [ { \"<STR_LIT:start>\" : \"<STR_LIT>\" , \"<STR_LIT:end>\" : \"<STR_LIT>\" } ] <EOL> ROUTES = [ { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : \"<STR_LIT>\" } ] <EOL> NET_ID = None <EOL> SUB_ID = None <EOL> @ classmethod <EOL> def setUpClass ( cls ) : <EOL> super ( TestSubnet , cls ) . setUpClass ( ) <EOL> net = cls . conn . network . create_network ( name = cls . NET_NAME ) <EOL> assert isinstance ( net , network . Network ) <EOL> cls . assertIs ( cls . NET_NAME , net . name ) <EOL> cls . NET_ID = net . id <EOL> sub = cls . conn . network . create_subnet ( name = cls . SUB_NAME , <EOL> ip_version = cls . IPV4 , <EOL> network_id = cls . NET_ID , <EOL> cidr = cls . CIDR , <EOL> dns_nameservers = cls . DNS_SERVERS , <EOL> allocation_pools = cls . POOL , <EOL> host_routes = cls . ROUTES ) <EOL>"}
{"rec_id": "3325", "recitation_code": "assert isinstance ( sub , subnet . Subnet )", "input_code_id": 17903, "input": "<s> import uuid <EOL> from openstack . network . v2 import network <EOL> from openstack . network . v2 import port <EOL> from openstack . network . v2 import subnet <EOL> from openstack . tests . functional import base <EOL> class TestNetworkIPAvailability ( base . BaseFunctionalTest ) : <EOL> NET_NAME = uuid . uuid4 ( ) . hex <EOL> SUB_NAME = uuid . uuid4 ( ) . hex <EOL> PORT_NAME = uuid . uuid4 ( ) . hex <EOL> UPDATE_NAME = uuid . uuid4 ( ) . hex <EOL> IPV4 = <NUM_LIT:4> <EOL> CIDR = \"<STR_LIT>\" <EOL> NET_ID = None <EOL> SUB_ID = None <EOL> PORT_ID = None <EOL> @ classmethod <EOL> def setUpClass ( cls ) : <EOL> super ( TestNetworkIPAvailability , cls ) . setUpClass ( ) <EOL> net = cls . conn . network . create_network ( name = cls . NET_NAME ) <EOL> assert isinstance ( net , network . Network ) <EOL> cls . assertIs ( cls . NET_NAME , net . name ) <EOL> cls . NET_ID = net . id <EOL> sub = cls . conn . network . create_subnet ( name = cls . SUB_NAME , <EOL> ip_version = cls . IPV4 , <EOL> network_id = cls . NET_ID , <EOL> cidr = cls . CIDR ) <EOL>"}
{"rec_id": "3329", "recitation_code": "resp = AUTH ACCEPTED", "input_code_id": 3329, "input": "<s> from twisted . internet . protocol import Factory <EOL> from twisted . protocols import basic <EOL> from twisted . internet import reactor <EOL> import sys , time <EOL> USER = \"<STR_LIT:test>\" <EOL> PASS = \"<STR_LIT>\" <EOL> PORT = <NUM_LIT> <EOL> SSL_SUPPORT = True <EOL> UIDL_SUPPORT = True <EOL> INVALID_SERVER_RESPONSE = False <EOL> INVALID_CAPABILITY_RESPONSE = False <EOL> INVALID_LOGIN_RESPONSE = False <EOL> DENY_CONNECTION = False <EOL> DROP_CONNECTION = False <EOL> BAD_TLS_RESPONSE = False <EOL> TIMEOUT_RESPONSE = False <EOL> TIMEOUT_DEFERRED = False <EOL> SLOW_GREETING = False <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> CONNECTION_MADE = \"<STR_LIT>\" <EOL> CAPABILITIES = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" <EOL> ] <EOL> CAPABILITIES_SSL = \"<STR_LIT>\" <EOL> CAPABILITIES_UIDL = \"<STR_LIT>\" <EOL> INVALID_RESPONSE = \"<STR_LIT>\" <EOL> VALID_RESPONSE = \"<STR_LIT>\" <EOL> AUTH_DECLINED = \"<STR_LIT>\" <EOL> AUTH_ACCEPTED = \"<STR_LIT>\" <EOL> TLS_ERROR = \"<STR_LIT>\" <EOL> LOGOUT_COMPLETE = \"<STR_LIT>\" <EOL> NOT_LOGGED_IN = \"<STR_LIT>\" <EOL> STAT = \"<STR_LIT>\" <EOL> UIDL = \"<STR_LIT>\" <EOL> LIST = \"<STR_LIT>\" <EOL> CAP_START = \"<STR_LIT>\" <EOL> class POP3TestServer ( basic . LineReceiver ) : <EOL> def __init__ ( self , contextFactory = None ) : <EOL> self . loggedIn = False <EOL> self . caps = None <EOL> self . tmpUser = None <EOL> self . ctx = contextFactory <EOL> def sendSTATResp ( self , req ) : <EOL> self . sendLine ( STAT ) <EOL> def sendUIDLResp ( self , req ) : <EOL> self . sendLine ( UIDL ) <EOL> def sendLISTResp ( self , req ) : <EOL> self . sendLine ( LIST ) <EOL> def sendCapabilities ( self ) : <EOL> if self . caps is None : <EOL> self . caps = [ CAP_START ] <EOL> if UIDL_SUPPORT : <EOL> self . caps . append ( CAPABILITIES_UIDL ) <EOL> if SSL_SUPPORT : <EOL> self . caps . append ( CAPABILITIES_SSL ) <EOL> for cap in CAPABILITIES : <EOL> self . caps . append ( cap ) <EOL> resp = '<STR_LIT:\\r\\n>' . join ( self . caps ) <EOL> resp += \"<STR_LIT>\" <EOL> self . sendLine ( resp ) <EOL> def connectionMade ( self ) : <EOL> if DENY_CONNECTION : <EOL> self . disconnect ( ) <EOL> return <EOL> if SLOW_GREETING : <EOL> reactor . callLater ( <NUM_LIT:20> , self . sendGreeting ) <EOL> else : <EOL> self . sendGreeting ( ) <EOL> def sendGreeting ( self ) : <EOL> self . sendLine ( CONNECTION_MADE ) <EOL> def lineReceived ( self , line ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> uline = line . upper ( ) <EOL> find = lambda s : uline . find ( s ) != - <NUM_LIT:1> <EOL> if TIMEOUT_RESPONSE : <EOL> return <EOL> if DROP_CONNECTION : <EOL> self . disconnect ( ) <EOL> return <EOL> elif find ( \"<STR_LIT>\" ) : <EOL> if INVALID_CAPABILITY_RESPONSE : <EOL> self . sendLine ( INVALID_RESPONSE ) <EOL> else : <EOL> self . sendCapabilities ( ) <EOL> elif find ( \"<STR_LIT>\" ) and SSL_SUPPORT : <EOL> self . startTLS ( ) <EOL> elif find ( \"<STR_LIT>\" ) : <EOL> if INVALID_LOGIN_RESPONSE : <EOL> self . sendLine ( INVALID_RESPONSE ) <EOL> return <EOL> resp = None <EOL> try : <EOL> self . tmpUser = line . split ( \"<STR_LIT:U+0020>\" ) [ <NUM_LIT:1> ] <EOL> resp = VALID_RESPONSE <EOL> except : <EOL> resp = AUTH_DECLINED <EOL> self . sendLine ( resp ) <EOL> elif find ( \"<STR_LIT>\" ) : <EOL> resp = None <EOL> try : <EOL> pwd = line . split ( \"<STR_LIT:U+0020>\" ) [ <NUM_LIT:1> ] <EOL> if self . tmpUser is None or pwd is None : <EOL> resp = AUTH_DECLINED <EOL> elif self . tmpUser == USER and pwd == PASS : <EOL> resp = AUTH_ACCEPTED <EOL> self . loggedIn = True <EOL> else : <EOL> resp = AUTH_DECLINED <EOL> except : <EOL>"}
{"rec_id": "3329", "recitation_code": "resp = AUTH ACCEPTED", "input_code_id": 37949, "input": "<s> from twisted . internet . protocol import Factory <EOL> from twisted . protocols import basic <EOL> from twisted . internet import reactor <EOL> import sys , time <EOL> USER = \"<STR_LIT:test>\" <EOL> PASS = \"<STR_LIT>\" <EOL> PORT = <NUM_LIT> <EOL> SSL_SUPPORT = True <EOL> UIDL_SUPPORT = True <EOL> INVALID_SERVER_RESPONSE = False <EOL> INVALID_CAPABILITY_RESPONSE = False <EOL> INVALID_LOGIN_RESPONSE = False <EOL> DENY_CONNECTION = False <EOL> DROP_CONNECTION = False <EOL> BAD_TLS_RESPONSE = False <EOL> TIMEOUT_RESPONSE = False <EOL> TIMEOUT_DEFERRED = False <EOL> SLOW_GREETING = False <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> CONNECTION_MADE = \"<STR_LIT>\" <EOL> CAPABILITIES = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" <EOL> ] <EOL> CAPABILITIES_SSL = \"<STR_LIT>\" <EOL> CAPABILITIES_UIDL = \"<STR_LIT>\" <EOL> INVALID_RESPONSE = \"<STR_LIT>\" <EOL> VALID_RESPONSE = \"<STR_LIT>\" <EOL> AUTH_DECLINED = \"<STR_LIT>\" <EOL> AUTH_ACCEPTED = \"<STR_LIT>\" <EOL> TLS_ERROR = \"<STR_LIT>\" <EOL> LOGOUT_COMPLETE = \"<STR_LIT>\" <EOL> NOT_LOGGED_IN = \"<STR_LIT>\" <EOL> STAT = \"<STR_LIT>\" <EOL> UIDL = \"<STR_LIT>\" <EOL> LIST = \"<STR_LIT>\" <EOL> CAP_START = \"<STR_LIT>\" <EOL> class POP3TestServer ( basic . LineReceiver ) : <EOL> def __init__ ( self , contextFactory = None ) : <EOL> self . loggedIn = False <EOL> self . caps = None <EOL> self . tmpUser = None <EOL> self . ctx = contextFactory <EOL> def sendSTATResp ( self , req ) : <EOL> self . sendLine ( STAT ) <EOL> def sendUIDLResp ( self , req ) : <EOL> self . sendLine ( UIDL ) <EOL> def sendLISTResp ( self , req ) : <EOL> self . sendLine ( LIST ) <EOL> def sendCapabilities ( self ) : <EOL> if self . caps is None : <EOL> self . caps = [ CAP_START ] <EOL> if UIDL_SUPPORT : <EOL> self . caps . append ( CAPABILITIES_UIDL ) <EOL> if SSL_SUPPORT : <EOL> self . caps . append ( CAPABILITIES_SSL ) <EOL> for cap in CAPABILITIES : <EOL> self . caps . append ( cap ) <EOL> resp = '<STR_LIT:\\r\\n>' . join ( self . caps ) <EOL> resp += \"<STR_LIT>\" <EOL> self . sendLine ( resp ) <EOL> def connectionMade ( self ) : <EOL> if DENY_CONNECTION : <EOL> self . disconnect ( ) <EOL> return <EOL> if SLOW_GREETING : <EOL> reactor . callLater ( <NUM_LIT:20> , self . sendGreeting ) <EOL> else : <EOL> self . sendGreeting ( ) <EOL> def sendGreeting ( self ) : <EOL> self . sendLine ( CONNECTION_MADE ) <EOL> def lineReceived ( self , line ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> uline = line . upper ( ) <EOL> find = lambda s : uline . find ( s ) != - <NUM_LIT:1> <EOL> if TIMEOUT_RESPONSE : <EOL> return <EOL> if DROP_CONNECTION : <EOL> self . disconnect ( ) <EOL> return <EOL> elif find ( \"<STR_LIT>\" ) : <EOL> if INVALID_CAPABILITY_RESPONSE : <EOL> self . sendLine ( INVALID_RESPONSE ) <EOL> else : <EOL> self . sendCapabilities ( ) <EOL> elif find ( \"<STR_LIT>\" ) and SSL_SUPPORT : <EOL> self . startTLS ( ) <EOL> elif find ( \"<STR_LIT>\" ) : <EOL> if INVALID_LOGIN_RESPONSE : <EOL> self . sendLine ( INVALID_RESPONSE ) <EOL> return <EOL> resp = None <EOL> try : <EOL> self . tmpUser = line . split ( \"<STR_LIT:U+0020>\" ) [ <NUM_LIT:1> ] <EOL> resp = VALID_RESPONSE <EOL> except : <EOL> resp = AUTH_DECLINED <EOL> self . sendLine ( resp ) <EOL> elif find ( \"<STR_LIT>\" ) : <EOL> resp = None <EOL> try : <EOL> pwd = line . split ( \"<STR_LIT:U+0020>\" ) [ <NUM_LIT:1> ] <EOL> if self . tmpUser is None or pwd is None : <EOL> resp = AUTH_DECLINED <EOL> elif self . tmpUser == USER and pwd == PASS : <EOL> resp = AUTH_ACCEPTED <EOL> self . loggedIn = True <EOL> else : <EOL> resp = AUTH_DECLINED <EOL> except : <EOL>"}
{"rec_id": "3337", "recitation_code": "plugin id = Column ( Integer , ForeignKey ( ' ' ) )", "input_code_id": 3337, "input": "<s> from sqlalchemy import Boolean <EOL> from sqlalchemy import Column <EOL> from sqlalchemy import ForeignKey <EOL> from sqlalchemy import Integer <EOL> from sqlalchemy import Text <EOL> from nailgun . db . sqlalchemy . models . base import Base <EOL> class ClusterPluginLink ( Base ) : <EOL> __tablename__ = '<STR_LIT>' <EOL> id = Column ( Integer , primary_key = True ) <EOL>"}
{"rec_id": "3337", "recitation_code": "plugin id = Column ( Integer , ForeignKey ( ' ' ) )", "input_code_id": 7428, "input": "<s> from sqlalchemy import Boolean <EOL> from sqlalchemy import Column <EOL> from sqlalchemy import ForeignKey <EOL> from sqlalchemy import Integer <EOL> from sqlalchemy import Text <EOL> from nailgun . db . sqlalchemy . models . base import Base <EOL> class PluginLink ( Base ) : <EOL> __tablename__ = '<STR_LIT>' <EOL> id = Column ( Integer , primary_key = True ) <EOL>"}
{"rec_id": "3342", "recitation_code": "noerror = getattr ( options , ' ' , False )", "input_code_id": 3342, "input": "<s> import sys <EOL> from paver . easy import * <EOL> from paver import doctools <EOL> from paver . setuputils import setup <EOL> PYCOMPILE_CACHES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> options ( <EOL> sphinx = Bunch ( builddir = '<STR_LIT>' ) , <EOL> ) <EOL> def sphinx_builddir ( options ) : <EOL> return path ( '<STR_LIT>' ) / options . sphinx . builddir / '<STR_LIT:html>' <EOL> @ task <EOL> def clean_docs ( options ) : <EOL> sphinx_builddir ( options ) . rmtree ( ) <EOL> @ task <EOL> @ needs ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def html ( options ) : <EOL> destdir = path ( '<STR_LIT>' ) <EOL> destdir . rmtree ( ) <EOL> builtdocs = sphinx_builddir ( options ) <EOL> builtdocs . move ( destdir ) <EOL> @ task <EOL> @ needs ( '<STR_LIT>' ) <EOL> def qhtml ( options ) : <EOL> destdir = path ( '<STR_LIT>' ) <EOL> builtdocs = sphinx_builddir ( options ) <EOL> sh ( '<STR_LIT>' . format ( builtdocs , destdir ) ) <EOL> @ task <EOL> @ needs ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def ghdocs ( options ) : <EOL> builtdocs = sphinx_builddir ( options ) <EOL> sh ( \"<STR_LIT>\" . format ( builtdocs ) ) <EOL> @ task <EOL> @ needs ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def upload_pypi_docs ( options ) : <EOL> builtdocs = path ( '<STR_LIT>' ) / options . builddir / '<STR_LIT:html>' <EOL> sh ( \"<STR_LIT>\" . format ( <EOL> sys . executable , builtdocs ) ) <EOL> @ task <EOL> @ needs ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def upload_docs ( options ) : <EOL> pass <EOL> @ task <EOL> def autodoc ( options ) : <EOL> sh ( '<STR_LIT>' ) <EOL> @ task <EOL> def verifyindex ( options ) : <EOL> sh ( '<STR_LIT>' ) <EOL> @ task <EOL> def verifyconfigref ( options ) : <EOL> sh ( '<STR_LIT>' . format ( sys . executable ) ) <EOL> @ task <EOL> @ cmdopts ( [ <EOL> ( '<STR_LIT>' , '<STR_LIT:E>' , '<STR_LIT>' ) , <EOL> ] ) <EOL> def flake8 ( options ) : <EOL> noerror = getattr ( options , '<STR_LIT>' , False ) <EOL> complexity = getattr ( options , '<STR_LIT>' , <NUM_LIT> ) <EOL> sh ( \"\"\"<STR_LIT>\"\"\" . format ( complexity ) , ignore_error = noerror ) <EOL> @ task <EOL> @ cmdopts ( [ <EOL> ( '<STR_LIT>' , '<STR_LIT:E>' , '<STR_LIT>' ) , <EOL> ] ) <EOL> def flakeplus ( options ) : <EOL>"}
{"rec_id": "3342", "recitation_code": "noerror = getattr ( options , ' ' , False )", "input_code_id": 37448, "input": "<s> import sys <EOL> from paver . easy import * <EOL> from paver import doctools <EOL> from paver . setuputils import setup <EOL> PYCOMPILE_CACHES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> options ( <EOL> sphinx = Bunch ( builddir = '<STR_LIT>' ) , <EOL> ) <EOL> def sphinx_builddir ( options ) : <EOL> return path ( '<STR_LIT>' ) / options . sphinx . builddir / '<STR_LIT:html>' <EOL> @ task <EOL> def clean_docs ( options ) : <EOL> sphinx_builddir ( options ) . rmtree ( ) <EOL> @ task <EOL> @ needs ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def html ( options ) : <EOL> destdir = path ( '<STR_LIT>' ) <EOL> destdir . rmtree ( ) <EOL> builtdocs = sphinx_builddir ( options ) <EOL> builtdocs . move ( destdir ) <EOL> @ task <EOL> @ needs ( '<STR_LIT>' ) <EOL> def qhtml ( options ) : <EOL> destdir = path ( '<STR_LIT>' ) <EOL> builtdocs = sphinx_builddir ( options ) <EOL> sh ( '<STR_LIT>' . format ( builtdocs , destdir ) ) <EOL> @ task <EOL> @ needs ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def ghdocs ( options ) : <EOL> builtdocs = sphinx_builddir ( options ) <EOL> sh ( \"<STR_LIT>\" . format ( builtdocs ) ) <EOL> @ task <EOL> @ needs ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def upload_pypi_docs ( options ) : <EOL> builtdocs = path ( '<STR_LIT>' ) / options . builddir / '<STR_LIT:html>' <EOL> sh ( \"<STR_LIT>\" . format ( <EOL> sys . executable , builtdocs ) ) <EOL> @ task <EOL> @ needs ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def upload_docs ( options ) : <EOL> pass <EOL> @ task <EOL> def autodoc ( options ) : <EOL> sh ( '<STR_LIT>' ) <EOL> @ task <EOL> def verifyindex ( options ) : <EOL> sh ( '<STR_LIT>' ) <EOL> @ task <EOL> def verifyconfigref ( options ) : <EOL> sh ( '<STR_LIT>' . format ( sys . executable ) ) <EOL> @ task <EOL> @ cmdopts ( [ <EOL> ( '<STR_LIT>' , '<STR_LIT:E>' , '<STR_LIT>' ) , <EOL> ] ) <EOL> def flake8 ( options ) : <EOL> noerror = getattr ( options , '<STR_LIT>' , False ) <EOL> complexity = getattr ( options , '<STR_LIT>' , <NUM_LIT> ) <EOL> sh ( \"\"\"<STR_LIT>\"\"\" . format ( complexity ) , ignore_error = noerror ) <EOL> @ task <EOL> @ cmdopts ( [ <EOL> ( '<STR_LIT>' , '<STR_LIT:E>' , '<STR_LIT>' ) , <EOL> ] ) <EOL> def flakeplus ( options ) : <EOL>"}
{"rec_id": "3372", "recitation_code": "with self . assertSameURL ( ) :", "input_code_id": 3372, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import unicode_literals <EOL> from el_pagination . tests . integration import SeleniumTestCase <EOL> class TwitterPaginationTest ( SeleniumTestCase ) : <EOL> view_name = '<STR_LIT>' <EOL> def test_new_elements_loaded ( self ) : <EOL> self . get ( ) <EOL> with self . assertNewElements ( '<STR_LIT:object>' , range ( <NUM_LIT:1> , <NUM_LIT:11> ) ) : <EOL> self . click_link ( self . MORE ) <EOL> def test_url_not_changed ( self ) : <EOL> self . get ( ) <EOL> with self . assertSameURL ( ) : <EOL> self . click_link ( self . MORE ) <EOL> def test_direct_link ( self ) : <EOL> self . get ( page = <NUM_LIT:4> ) <EOL>"}
{"rec_id": "3372", "recitation_code": "with self . assertSameURL ( ) :", "input_code_id": 25344, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import unicode_literals <EOL> from endless_pagination . tests . integration import SeleniumTestCase <EOL> class OnScrollPaginationTest ( SeleniumTestCase ) : <EOL> view_name = '<STR_LIT>' <EOL> def test_new_elements_loaded ( self ) : <EOL> self . get ( ) <EOL> with self . assertNewElements ( '<STR_LIT:object>' , range ( <NUM_LIT:1> , <NUM_LIT> ) ) : <EOL> self . scroll_down ( ) <EOL> def test_url_not_changed ( self ) : <EOL> self . get ( ) <EOL> with self . assertSameURL ( ) : <EOL> self . scroll_down ( ) <EOL> def test_direct_link ( self ) : <EOL> self . get ( page = <NUM_LIT:3> ) <EOL> self . assertElements ( '<STR_LIT:object>' , range ( <NUM_LIT> , <NUM_LIT> ) ) <EOL>"}
{"rec_id": "3372", "recitation_code": "with self . assertSameURL ( ) :", "input_code_id": 80476, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import unicode_literals <EOL> from el_pagination . tests . integration import SeleniumTestCase <EOL> class DiggPaginationTest ( SeleniumTestCase ) : <EOL> view_name = '<STR_LIT>' <EOL> def test_new_elements_loaded ( self ) : <EOL> self . get ( ) <EOL> with self . assertNewElements ( '<STR_LIT:object>' , range ( <NUM_LIT:6> , <NUM_LIT:11> ) ) : <EOL> self . click_link ( <NUM_LIT:2> ) <EOL> def test_url_not_changed ( self ) : <EOL> self . get ( ) <EOL> with self . assertSameURL ( ) : <EOL> self . click_link ( <NUM_LIT:2> ) <EOL> def test_direct_link ( self ) : <EOL> self . get ( page = <NUM_LIT:4> ) <EOL> self . assertElements ( '<STR_LIT:object>' , range ( <NUM_LIT:16> , <NUM_LIT> ) ) <EOL>"}
{"rec_id": "3372", "recitation_code": "with self . assertSameURL ( ) :", "input_code_id": 86525, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import unicode_literals <EOL> from endless_pagination . tests . integration import SeleniumTestCase <EOL> class TwitterPaginationTest ( SeleniumTestCase ) : <EOL> view_name = '<STR_LIT>' <EOL> def test_new_elements_loaded ( self ) : <EOL> self . get ( ) <EOL> with self . assertNewElements ( '<STR_LIT:object>' , range ( <NUM_LIT:1> , <NUM_LIT:11> ) ) : <EOL> self . click_link ( self . MORE ) <EOL> def test_url_not_changed ( self ) : <EOL> self . get ( ) <EOL> with self . assertSameURL ( ) : <EOL> self . click_link ( self . MORE ) <EOL> def test_direct_link ( self ) : <EOL> self . get ( page = <NUM_LIT:4> ) <EOL>"}
{"rec_id": "3487", "recitation_code": "def cli ( ctx ) :", "input_code_id": 3487, "input": "<s> import click <EOL> from complex . cli import pass_context <EOL> @ click . command ( '<STR_LIT:status>' , short_help = '<STR_LIT>' ) <EOL> @ pass_context <EOL>"}
{"rec_id": "3487", "recitation_code": "def cli ( ctx ) :", "input_code_id": 9746, "input": "<s> import click <EOL> import inspector <EOL> import googleanalytics as ga <EOL> @ click . group ( invoke_without_command = True ) <EOL> @ click . option ( '<STR_LIT>' ) <EOL> @ click . option ( '<STR_LIT>' ) <EOL> @ click . option ( '<STR_LIT>' ) <EOL> @ click . option ( '<STR_LIT>' ) <EOL> @ click . option ( '<STR_LIT>' , is_flag = True ) <EOL> @ click . pass_context <EOL>"}
{"rec_id": "3617", "recitation_code": "with open ( file path , ' rb ' ) as f :", "input_code_id": 3617, "input": "<s> import unittest <EOL> import numpy as np <EOL> import deltasigma as ds <EOL> import pkg_resources <EOL> import scipy . io <EOL> from os . path import join <EOL> class TestDSOptZeros ( unittest . TestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def setUp ( self ) : <EOL> file_path = join ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> fname = pkg_resources . resource_filename ( __name__ , file_path ) <EOL>"}
{"rec_id": "3617", "recitation_code": "with open ( file path , ' rb ' ) as f :", "input_code_id": 83189, "input": "<s> from django . shortcuts import render <EOL> from django . http import HttpResponse <EOL> import os . path <EOL> SITE_ROOT = os . path . dirname ( os . path . realpath ( __file__ ) ) <EOL> def respond_proxy_js ( request ) : <EOL> file_path = \"<STR_LIT>\" % SITE_ROOT <EOL>"}
{"rec_id": "3694", "recitation_code": "if sock in rlist :", "input_code_id": 3694, "input": "<s> import select <EOL> import socket <EOL> from Rpyc . Utils . Serving import ( <EOL> log , <EOL> create_listener_socket , <EOL> DEFAULT_PORT , <EOL> SocketStream , <EOL> Channel , <EOL> Connection ) <EOL> def main ( port = DEFAULT_PORT ) : <EOL> sock = create_listener_socket ( port ) <EOL> connections = [ ] <EOL> while True : <EOL> rlist , wlist , xlist = select . select ( [ sock ] + connections , [ ] , [ ] ) <EOL>"}
{"rec_id": "3694", "recitation_code": "if sock in rlist :", "input_code_id": 7936, "input": "<s> import select <EOL> import socket <EOL> from Rpyc . Utils . Serving import ( <EOL> log , <EOL> create_listener_socket , <EOL> DEFAULT_PORT , <EOL> SocketStream , <EOL> Channel , <EOL> Connection ) <EOL> def main ( port = DEFAULT_PORT ) : <EOL> sock = create_listener_socket ( port ) <EOL> connections = [ ] <EOL> while True : <EOL> rlist , wlist , xlist = select . select ( [ sock ] + connections , [ ] , [ ] ) <EOL>"}
{"rec_id": "3734", "recitation_code": "return user . has perm ( ' ' )", "input_code_id": 3141, "input": "<s> from . . utils . access_permissions import BaseAccessPermissions <EOL> class MotionAccessPermissions ( BaseAccessPermissions ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def can_retrieve ( self , user ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return user . has_perm ( '<STR_LIT>' ) <EOL> def get_serializer_class ( self , user = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from . serializers import MotionSerializer <EOL> return MotionSerializer <EOL> class CategoryAccessPermissions ( BaseAccessPermissions ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def can_retrieve ( self , user ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>"}
{"rec_id": "3734", "recitation_code": "return user . has perm ( ' ' )", "input_code_id": 3734, "input": "<s> from . . utils . access_permissions import BaseAccessPermissions <EOL> class ProjectorAccessPermissions ( BaseAccessPermissions ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def can_retrieve ( self , user ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return user . has_perm ( '<STR_LIT>' ) <EOL> def get_serializer_class ( self , user = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from . serializers import ProjectorSerializer <EOL> return ProjectorSerializer <EOL> class CustomSlideAccessPermissions ( BaseAccessPermissions ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def can_retrieve ( self , user ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return user . has_perm ( '<STR_LIT>' ) <EOL> def get_serializer_class ( self , user = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from . serializers import CustomSlideSerializer <EOL> return CustomSlideSerializer <EOL> class TagAccessPermissions ( BaseAccessPermissions ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def can_retrieve ( self , user ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from . config import config <EOL>"}
{"rec_id": "3786", "recitation_code": "GetResourceFeed = get resource feed", "input_code_id": 3786, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __author__ = '<STR_LIT>' <EOL> import gdata . calendar_resource . data <EOL> import gdata . client <EOL> import urllib <EOL> RESOURCE_FEED_TEMPLATE = '<STR_LIT>' <EOL> class CalendarResourceClient ( gdata . client . GDClient ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> host = '<STR_LIT>' <EOL> api_version = '<STR_LIT>' <EOL> auth_service = '<STR_LIT>' <EOL> auth_scopes = gdata . gauth . AUTH_SCOPES [ '<STR_LIT>' ] <EOL> ssl = True <EOL> def __init__ ( self , domain , auth_token = None , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> gdata . client . GDClient . __init__ ( self , auth_token = auth_token , ** kwargs ) <EOL> self . domain = domain <EOL> def make_resource_feed_uri ( self , resource_id = None , params = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> uri = RESOURCE_FEED_TEMPLATE % ( self . api_version , self . domain ) <EOL> if resource_id : <EOL> uri += resource_id <EOL> if params : <EOL> uri += '<STR_LIT:?>' + urllib . urlencode ( params ) <EOL> return uri <EOL> MakeResourceFeedUri = make_resource_feed_uri <EOL> def get_resource_feed ( self , uri = None , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if uri is None : <EOL> uri = self . MakeResourceFeedUri ( ) <EOL> return self . get_feed ( <EOL> uri , <EOL> desired_class = gdata . calendar_resource . data . CalendarResourceFeed , <EOL> ** kwargs ) <EOL>"}
{"rec_id": "3786", "recitation_code": "GetResourceFeed = get resource feed", "input_code_id": 47204, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __author__ = '<STR_LIT>' <EOL> import gdata . calendar_resource . data <EOL> import gdata . client <EOL> import urllib . request , urllib . parse , urllib . error <EOL> RESOURCE_FEED_TEMPLATE = '<STR_LIT>' <EOL> class CalendarResourceClient ( gdata . client . GDClient ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> host = '<STR_LIT>' <EOL> api_version = '<STR_LIT>' <EOL> auth_service = '<STR_LIT>' <EOL> auth_scopes = gdata . gauth . AUTH_SCOPES [ '<STR_LIT>' ] <EOL> ssl = True <EOL> def __init__ ( self , domain , auth_token = None , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> gdata . client . GDClient . __init__ ( self , auth_token = auth_token , ** kwargs ) <EOL> self . domain = domain <EOL> def make_resource_feed_uri ( self , resource_id = None , params = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> uri = RESOURCE_FEED_TEMPLATE % ( self . api_version , self . domain ) <EOL> if resource_id : <EOL> uri += resource_id <EOL> if params : <EOL> uri += '<STR_LIT:?>' + urllib . parse . urlencode ( params ) <EOL> return uri <EOL> MakeResourceFeedUri = make_resource_feed_uri <EOL> def get_resource_feed ( self , uri = None , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if uri is None : <EOL> uri = self . MakeResourceFeedUri ( ) <EOL> return self . get_feed ( <EOL> uri , <EOL> desired_class = gdata . calendar_resource . data . CalendarResourceFeed , <EOL> ** kwargs ) <EOL>"}
{"rec_id": "3819", "recitation_code": "initExp [ ' args ' ] [ ' ' ] = ' '", "input_code_id": 3819, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os , sys <EOL> sys . path . append ( \"<STR_LIT>\" ) <EOL> from launch_experiment import * <EOL> curr_dir = os . path . dirname ( os . path . abspath ( __file__ ) ) <EOL> experiment_list = [ ] <EOL> supported_alg_ids = [ '<STR_LIT>' ] <EOL> alg_list = [ ] <EOL> for alg_id in supported_alg_ids : <EOL> alg_item = { } <EOL> alg_item [ '<STR_LIT>' ] = alg_id <EOL> alg_item [ '<STR_LIT>' ] = alg_id <EOL> alg_item [ '<STR_LIT>' ] = { } <EOL> alg_list . append ( alg_item ) <EOL> algorithm_management_settings = { } <EOL> params = { } <EOL> params [ '<STR_LIT>' ] = [ ] <EOL> for algorithm in alg_list : <EOL> params [ '<STR_LIT>' ] . append ( { '<STR_LIT>' : algorithm [ '<STR_LIT>' ] , '<STR_LIT>' : <NUM_LIT:1.> / len ( alg_list ) } ) <EOL> algorithm_management_settings [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> algorithm_management_settings [ '<STR_LIT>' ] = params <EOL> cap_list = [ '<STR_LIT>' ] <EOL> for cap in cap_list : <EOL> initExp = { } <EOL> initExp [ '<STR_LIT:args>' ] = { } <EOL> initExp [ '<STR_LIT:args>' ] [ '<STR_LIT:n>' ] = <NUM_LIT> <EOL> initExp [ '<STR_LIT:args>' ] [ '<STR_LIT:k>' ] = <NUM_LIT:8> <EOL>"}
{"rec_id": "3819", "recitation_code": "initExp [ ' args ' ] [ ' ' ] = ' '", "input_code_id": 17336, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os , sys <EOL> sys . path . append ( \"<STR_LIT>\" ) <EOL> from launch_experiment import * <EOL> curr_dir = os . path . dirname ( os . path . abspath ( __file__ ) ) <EOL> experiment_list = [ ] <EOL> supported_alg_ids = [ '<STR_LIT>' ] <EOL> alg_list = [ ] <EOL> for alg_id in supported_alg_ids : <EOL> alg_item = { } <EOL> alg_item [ '<STR_LIT>' ] = alg_id <EOL> alg_item [ '<STR_LIT>' ] = alg_id <EOL> alg_item [ '<STR_LIT>' ] = { } <EOL> alg_list . append ( alg_item ) <EOL> algorithm_management_settings = { } <EOL> params = { } <EOL> params [ '<STR_LIT>' ] = [ ] <EOL> for algorithm in alg_list : <EOL> params [ '<STR_LIT>' ] . append ( { '<STR_LIT>' : algorithm [ '<STR_LIT>' ] , '<STR_LIT>' : <NUM_LIT:1.> / len ( alg_list ) } ) <EOL> algorithm_management_settings [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> algorithm_management_settings [ '<STR_LIT>' ] = params <EOL> cap_list = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> for cap in cap_list : <EOL> initExp = { } <EOL> initExp [ '<STR_LIT:args>' ] = { } <EOL> initExp [ '<STR_LIT:args>' ] [ '<STR_LIT:n>' ] = <NUM_LIT:8> <EOL> initExp [ '<STR_LIT:args>' ] [ '<STR_LIT:k>' ] = <NUM_LIT:8> <EOL>"}
{"rec_id": "3819", "recitation_code": "initExp [ ' args ' ] [ ' ' ] = ' '", "input_code_id": 78499, "input": "<s> import os , sys <EOL> sys . path . append ( \"<STR_LIT>\" ) <EOL> from launch_experiment import * <EOL> experiment_list = [ ] <EOL> alg_ids = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> alg_list = [ ] <EOL> for idx , alg_id in enumerate ( alg_ids ) : <EOL> alg_item = { } <EOL> alg_item [ '<STR_LIT>' ] = alg_id <EOL> if idx == <NUM_LIT:0> : <EOL> alg_item [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> else : <EOL> alg_item [ '<STR_LIT>' ] = alg_id <EOL> alg_item [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> alg_item [ '<STR_LIT>' ] = { } <EOL> alg_list . append ( alg_item ) <EOL> params = { } <EOL> params [ '<STR_LIT>' ] = [ ] <EOL> for algorithm in alg_list : <EOL> params [ '<STR_LIT>' ] . append ( { '<STR_LIT>' : algorithm [ '<STR_LIT>' ] , '<STR_LIT>' : <NUM_LIT:1.> / len ( alg_list ) } ) <EOL> algorithm_management_settings = { } <EOL> algorithm_management_settings [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> algorithm_management_settings [ '<STR_LIT>' ] = params <EOL> initExp = { } <EOL> initExp [ '<STR_LIT:args>' ] = { } <EOL> initExp [ '<STR_LIT:args>' ] [ '<STR_LIT:n>' ] = <NUM_LIT:30> <EOL> initExp [ '<STR_LIT:args>' ] [ '<STR_LIT:d>' ] = <NUM_LIT:2> <EOL>"}
{"rec_id": "3833", "recitation_code": "func ( * args , * * kargs )", "input_code_id": 3833, "input": "<s> try : <EOL> import sys <EOL> import inspect <EOL> from Queue import Queue <EOL> from threading import Thread <EOL> except ImportError , err : <EOL> import sys <EOL> sys . stderr . write ( \"<STR_LIT>\" % ( err , __file__ , inspect . currentframe ( ) . f_lineno ) ) <EOL> sys . exit ( <NUM_LIT:1> ) <EOL> class Worker ( Thread ) : <EOL> def __init__ ( self , tasks ) : <EOL> Thread . __init__ ( self ) <EOL> self . tasks = tasks <EOL> self . daemon = True <EOL> self . start ( ) <EOL> def run ( self ) : <EOL> while True : <EOL> func , args , kargs = self . tasks . get ( True , None ) <EOL> if not func : <EOL> break <EOL> try : <EOL>"}
{"rec_id": "3833", "recitation_code": "func ( * args , * * kargs )", "input_code_id": 4926, "input": "<s> try : <EOL> import sys <EOL> from Queue import Queue <EOL> from threading import Thread <EOL> from lib . core . exceptions import CrowbarExceptions <EOL> except Exception , err : <EOL> from lib . core . exceptions import CrowbarExceptions <EOL> raise CrowbarExceptions ( str ( err ) ) <EOL> class Worker ( Thread ) : <EOL> def __init__ ( self , tasks ) : <EOL> Thread . __init__ ( self ) <EOL> self . tasks = tasks <EOL> self . daemon = True <EOL> self . start ( ) <EOL> def run ( self ) : <EOL> while True : <EOL> func , args , kargs = self . tasks . get ( True , None ) <EOL> if not func : <EOL> break <EOL> try : <EOL>"}
{"rec_id": "3868", "recitation_code": "yield word", "input_code_id": 3868, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from mrjob . job import MRJob <EOL> class MREntityTypeCounter ( MRJob ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def get_etypes ( self , key , line ) : <EOL> for word in line . split ( ) : <EOL>"}
{"rec_id": "3868", "recitation_code": "yield word", "input_code_id": 71040, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from pycascading . helpers import * <EOL> @ udf_map ( produces = [ '<STR_LIT>' ] ) <EOL> def split_words ( tuple ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for word in tuple . get ( <NUM_LIT:1> ) . split ( ) : <EOL>"}
{"rec_id": "3882", "recitation_code": "url ( r ' ' , ArticleListView . as view ( ) , name = ' ' ) ,", "input_code_id": 3882, "input": "<s> from django . conf . urls import url <EOL> from . views import ArticleListView , ArticleDetailView <EOL> urlpatterns = [ <EOL>"}
{"rec_id": "3882", "recitation_code": "url ( r ' ' , ArticleListView . as view ( ) , name = ' ' ) ,", "input_code_id": 75914, "input": "<s> from django . conf . urls import url <EOL> from article . views import ArticleListView , ArticleFullListView , ArticleDetailView <EOL> urlpatterns = [ <EOL>"}
{"rec_id": "3884", "recitation_code": "coordinates . append ( self . format altitude ( altitude ) )", "input_code_id": 3884, "input": "<s> import re <EOL> from itertools import islice <EOL> from geopy import util , units , format <EOL> class Point ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> UTIL_PATTERNS = dict ( <EOL> FLOAT = r'<STR_LIT>' , <EOL> DEGREE = format . DEGREE , <EOL> PRIME = format . PRIME , <EOL> DOUBLE_PRIME = format . DOUBLE_PRIME , <EOL> SEP = r'<STR_LIT>' <EOL> ) <EOL> POINT_PATTERN = re . compile ( r\"\"\"<STR_LIT>\"\"\" % UTIL_PATTERNS , re . X ) <EOL> def __new__ ( cls , latitude = None , longitude = None , altitude = None ) : <EOL> single_arg = longitude is None and altitude is None <EOL> if single_arg and not isinstance ( latitude , util . NUMBER_TYPES ) : <EOL> arg = latitude <EOL> if arg is None : <EOL> pass <EOL> elif isinstance ( arg , Point ) : <EOL> return cls . from_point ( arg ) <EOL> elif isinstance ( arg , basestring ) : <EOL> return cls . from_string ( arg ) <EOL> else : <EOL> try : <EOL> seq = iter ( arg ) <EOL> except TypeError : <EOL> raise TypeError ( <EOL> \"<STR_LIT>\" % ( arg , ) <EOL> ) <EOL> else : <EOL> return cls . from_sequence ( seq ) <EOL> latitude = float ( latitude or <NUM_LIT:0> ) <EOL> if abs ( latitude ) > <NUM_LIT> : <EOL> raise ValueError ( \"<STR_LIT>\" % latitude ) <EOL> longitude = float ( longitude or <NUM_LIT:0> ) <EOL> if abs ( longitude ) > <NUM_LIT> : <EOL> raise ValueError ( \"<STR_LIT>\" % longitude ) <EOL> altitude = float ( altitude or <NUM_LIT:0> ) <EOL> self = super ( Point , cls ) . __new__ ( cls ) <EOL> self . latitude = latitude <EOL> self . longitude = longitude <EOL> self . altitude = altitude <EOL> return self <EOL> def __getitem__ ( self , index ) : <EOL> return ( self . latitude , self . longitude , self . altitude ) [ index ] <EOL> def __setitem__ ( self , index , value ) : <EOL> point = [ self . latitude , self . longitude , self . altitude ] <EOL> point [ index ] = value <EOL> self . latitude , self . longitude , self . altitude = point <EOL> def __iter__ ( self ) : <EOL> return iter ( ( self . latitude , self . longitude , self . altitude ) ) <EOL> def __repr__ ( self ) : <EOL> return \"<STR_LIT>\" % ( <EOL> self . latitude , self . longitude , self . altitude <EOL> ) <EOL> def format ( self , altitude = None , deg_char = '<STR_LIT>' , min_char = '<STR_LIT:m>' , sec_char = '<STR_LIT:s>' ) : <EOL> latitude = \"<STR_LIT>\" % ( <EOL> format . angle ( abs ( self . latitude ) , deg_char , min_char , sec_char ) , <EOL> self . latitude >= <NUM_LIT:0> and '<STR_LIT:N>' or '<STR_LIT:S>' <EOL> ) <EOL> longitude = \"<STR_LIT>\" % ( <EOL> format . angle ( abs ( self . longitude ) , deg_char , min_char , sec_char ) , <EOL> self . longitude >= <NUM_LIT:0> and '<STR_LIT:E>' or '<STR_LIT>' <EOL> ) <EOL> coordinates = [ latitude , longitude ] <EOL> if altitude is None : <EOL> altitude = bool ( self . altitude ) <EOL> if altitude : <EOL> if not isinstance ( altitude , basestring ) : <EOL> altitude = '<STR_LIT>' <EOL> coordinates . append ( self . format_altitude ( altitude ) ) <EOL> return \"<STR_LIT:U+002CU+0020>\" . join ( coordinates ) <EOL> def format_decimal ( self , altitude = None ) : <EOL> latitude = \"<STR_LIT:%s>\" % self . latitude <EOL> longitude = \"<STR_LIT:%s>\" % self . longitude <EOL> coordinates = [ latitude , longitude ] <EOL> if altitude is None : <EOL> altitude = bool ( self . altitude ) <EOL> if altitude : <EOL> if not isinstance ( altitude , basestring ) : <EOL> altitude = '<STR_LIT>' <EOL>"}
{"rec_id": "3884", "recitation_code": "coordinates . append ( self . format altitude ( altitude ) )", "input_code_id": 49432, "input": "<s> import re <EOL> from itertools import islice <EOL> import util , units , format <EOL> class Point ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> UTIL_PATTERNS = dict ( <EOL> FLOAT = r'<STR_LIT>' , <EOL> DEGREE = format . DEGREE , <EOL> PRIME = format . PRIME , <EOL> DOUBLE_PRIME = format . DOUBLE_PRIME , <EOL> SEP = r'<STR_LIT>' <EOL> ) <EOL> POINT_PATTERN = re . compile ( r\"\"\"<STR_LIT>\"\"\" % UTIL_PATTERNS , re . X ) <EOL> def __new__ ( cls , latitude = None , longitude = None , altitude = None ) : <EOL> single_arg = longitude is None and altitude is None <EOL> if single_arg and not isinstance ( latitude , util . NUMBER_TYPES ) : <EOL> arg = latitude <EOL> if arg is None : <EOL> pass <EOL> elif isinstance ( arg , Point ) : <EOL> return cls . from_point ( arg ) <EOL> elif isinstance ( arg , basestring ) : <EOL> return cls . from_string ( arg ) <EOL> else : <EOL> try : <EOL> seq = iter ( arg ) <EOL> except TypeError : <EOL> raise TypeError ( <EOL> \"<STR_LIT>\" % ( arg , ) <EOL> ) <EOL> else : <EOL> return cls . from_sequence ( seq ) <EOL> latitude = float ( latitude or <NUM_LIT:0> ) <EOL> if abs ( latitude ) > <NUM_LIT> : <EOL> latitude = ( ( latitude + <NUM_LIT> ) % <NUM_LIT> ) - <NUM_LIT> <EOL> longitude = float ( longitude or <NUM_LIT:0> ) <EOL> if abs ( longitude ) > <NUM_LIT> : <EOL> longitude = ( ( longitude + <NUM_LIT> ) % <NUM_LIT> ) - <NUM_LIT> <EOL> altitude = float ( altitude or <NUM_LIT:0> ) <EOL> self = super ( Point , cls ) . __new__ ( cls ) <EOL> self . latitude = latitude <EOL> self . longitude = longitude <EOL> self . altitude = altitude <EOL> return self <EOL> def __getitem__ ( self , index ) : <EOL> return ( self . latitude , self . longitude , self . altitude ) [ index ] <EOL> def __setitem__ ( self , index , value ) : <EOL> point = [ self . latitude , self . longitude , self . altitude ] <EOL> point [ index ] = value <EOL> self . latitude , self . longitude , self . altitude = point <EOL> def __iter__ ( self ) : <EOL> return iter ( ( self . latitude , self . longitude , self . altitude ) ) <EOL> def __repr__ ( self ) : <EOL> return \"<STR_LIT>\" % ( <EOL> self . latitude , self . longitude , self . altitude <EOL> ) <EOL> def format ( self , altitude = None , deg_char = '<STR_LIT>' , min_char = '<STR_LIT:m>' , sec_char = '<STR_LIT:s>' ) : <EOL> latitude = \"<STR_LIT>\" % ( <EOL> format . format_degrees ( abs ( self . latitude ) , symbols = { '<STR_LIT>' : deg_char , '<STR_LIT>' : min_char , '<STR_LIT>' : sec_char } ) , <EOL> self . latitude >= <NUM_LIT:0> and '<STR_LIT:N>' or '<STR_LIT:S>' <EOL> ) <EOL> longitude = \"<STR_LIT>\" % ( <EOL> format . format_degrees ( abs ( self . longitude ) , symbols = { '<STR_LIT>' : deg_char , '<STR_LIT>' : min_char , '<STR_LIT>' : sec_char } ) , <EOL> self . longitude >= <NUM_LIT:0> and '<STR_LIT:E>' or '<STR_LIT>' <EOL> ) <EOL> coordinates = [ latitude , longitude ] <EOL> if altitude is None : <EOL> altitude = bool ( self . altitude ) <EOL> if altitude : <EOL> if not isinstance ( altitude , basestring ) : <EOL> altitude = '<STR_LIT>' <EOL> coordinates . append ( self . format_altitude ( altitude ) ) <EOL> return \"<STR_LIT:U+002CU+0020>\" . join ( coordinates ) <EOL> def format_decimal ( self , altitude = None ) : <EOL> latitude = \"<STR_LIT:%s>\" % self . latitude <EOL> longitude = \"<STR_LIT:%s>\" % self . longitude <EOL> coordinates = [ latitude , longitude ] <EOL> if altitude is None : <EOL> altitude = bool ( self . altitude ) <EOL> if altitude : <EOL> if not isinstance ( altitude , basestring ) : <EOL> altitude = '<STR_LIT>' <EOL>"}
{"rec_id": "4014", "recitation_code": "def Decode ( self , encoded data ) :", "input_code_id": 4014, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import base64 <EOL> import binascii <EOL> from dfvfs . encoding import decoder <EOL> from dfvfs . encoding import manager <EOL> from dfvfs . lib import definitions <EOL> from dfvfs . lib import errors <EOL> class Base16Decoder ( decoder . Decoder ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ENCODING_METHOD = definitions . ENCODING_METHOD_BASE16 <EOL>"}
{"rec_id": "4014", "recitation_code": "def Decode ( self , encoded data ) :", "input_code_id": 37146, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import base64 <EOL> import binascii <EOL> from dfvfs . encoding import decoder <EOL> from dfvfs . encoding import manager <EOL> from dfvfs . lib import definitions <EOL> from dfvfs . lib import errors <EOL> class Base32Decoder ( decoder . Decoder ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ENCODING_METHOD = definitions . ENCODING_METHOD_BASE32 <EOL>"}
{"rec_id": "4048", "recitation_code": "context [ self . var name ] = message count", "input_code_id": 4048, "input": "<s> from django import template <EOL> from userena . contrib . umessages . models import MessageRecipient <EOL> import re <EOL> register = template . Library ( ) <EOL> class MessageCount ( template . Node ) : <EOL> def __init__ ( self , um_from_user , var_name , um_to_user = None ) : <EOL> self . user = template . Variable ( um_from_user ) <EOL> self . var_name = var_name <EOL> if um_to_user : <EOL> self . um_to_user = template . Variable ( um_to_user ) <EOL> else : self . um_to_user = um_to_user <EOL> def render ( self , context ) : <EOL> try : <EOL> user = self . user . resolve ( context ) <EOL> except template . VariableDoesNotExist : <EOL> return '<STR_LIT>' <EOL> if not self . um_to_user : <EOL> message_count = MessageRecipient . objects . count_unread_messages_for ( user ) <EOL> else : <EOL> try : <EOL> um_to_user = self . um_to_user . resolve ( context ) <EOL> except template . VariableDoesNotExist : <EOL> return '<STR_LIT>' <EOL> message_count = MessageRecipient . objects . count_unread_messages_between ( user , <EOL> um_to_user ) <EOL>"}
{"rec_id": "4048", "recitation_code": "context [ self . var name ] = message count", "input_code_id": 85115, "input": "<s> from django import template <EOL> from userena . contrib . umessages . models import MessageRecipient <EOL> import re <EOL> register = template . Library ( ) <EOL> class MessageCount ( template . Node ) : <EOL> def __init__ ( self , from_user , var_name , to_user = None ) : <EOL> self . user = template . Variable ( from_user ) <EOL> self . var_name = var_name <EOL> if to_user : <EOL> self . to_user = template . Variable ( to_user ) <EOL> else : self . to_user = to_user <EOL> def render ( self , context ) : <EOL> try : <EOL> user = self . user . resolve ( context ) <EOL> except template . VariableDoesNotExist : <EOL> return '<STR_LIT>' <EOL> if not self . to_user : <EOL> message_count = MessageRecipient . objects . count_unread_messages_for ( user ) <EOL> else : <EOL> try : <EOL> to_user = self . to_user . resolve ( context ) <EOL> except template . VariableDoesNotExist : <EOL> return '<STR_LIT>' <EOL> message_count = MessageRecipient . objects . count_unread_messages_between ( user , <EOL> to_user ) <EOL>"}
{"rec_id": "4132", "recitation_code": "pair2 = SocketPair ( TcpClient ( 0 ) , TlsServer ( ' ' , ' ' , 0 ) )", "input_code_id": 4132, "input": "<s> from subprocess import Popen <EOL> from test_common import * <EOL> import socket , ssl , time , os , signal <EOL> if __name__ == \"<STR_LIT:__main__>\" : <EOL> ghostunnel = None <EOL> try : <EOL> root1 = RootCert ( '<STR_LIT>' ) <EOL> root1 . create_signed_cert ( '<STR_LIT>' ) <EOL> root1 . create_signed_cert ( '<STR_LIT>' ) <EOL> ghostunnel = run_ghostunnel ( [ '<STR_LIT>' , '<STR_LIT>' . format ( LOCALHOST ) , <EOL> '<STR_LIT>' . format ( LOCALHOST ) , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' . format ( LOCALHOST , STATUS_PORT ) ] ) <EOL> pair1 = SocketPair ( TcpClient ( <NUM_LIT> ) , TlsServer ( '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> ) ) <EOL> pair1 . validate_can_send_from_client ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> pair1 . validate_client_cert ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>"}
{"rec_id": "4132", "recitation_code": "pair2 = SocketPair ( TcpClient ( 0 ) , TlsServer ( ' ' , ' ' , 0 ) )", "input_code_id": 49975, "input": "<s> from subprocess import Popen <EOL> from test_common import * <EOL> import socket , ssl , time , os , signal <EOL> if __name__ == \"<STR_LIT:__main__>\" : <EOL> ghostunnel = None <EOL> try : <EOL> root1 = RootCert ( '<STR_LIT>' ) <EOL> root1 . create_signed_cert ( '<STR_LIT>' ) <EOL> root1 . create_signed_cert ( '<STR_LIT>' ) <EOL> root1 . create_signed_cert ( '<STR_LIT>' ) <EOL> root2 = RootCert ( '<STR_LIT>' ) <EOL> root2 . create_signed_cert ( '<STR_LIT>' ) <EOL> ghostunnel = run_ghostunnel ( [ '<STR_LIT>' , '<STR_LIT>' . format ( LOCALHOST ) , <EOL> '<STR_LIT>' . format ( LOCALHOST ) , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' . format ( LOCALHOST , STATUS_PORT ) ] ) <EOL> pair1 = SocketPair ( TcpClient ( <NUM_LIT> ) , TlsServer ( '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> ) ) <EOL> pair1 . validate_can_send_from_client ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> pair1 . validate_client_cert ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> TlsClient ( None , '<STR_LIT>' , STATUS_PORT ) . connect ( <NUM_LIT:20> , '<STR_LIT>' ) <EOL>"}
{"rec_id": "4137", "recitation_code": "if leftover :", "input_code_id": 4137, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import struct <EOL> import binascii <EOL> __all__ = [ <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> ] <EOL> _translation = [ chr ( _x ) for _x in range ( <NUM_LIT> ) ] <EOL> EMPTYSTRING = '<STR_LIT>' <EOL> def _translate ( s , altchars ) : <EOL> translation = _translation [ : ] <EOL> for k , v in altchars . items ( ) : <EOL> translation [ ord ( k ) ] = v <EOL> t = '<STR_LIT>' <EOL> for c in s : <EOL> t += translation [ ord ( c ) ] <EOL> return t <EOL> def b64encode ( s , altchars = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> encoded = binascii . b2a_base64 ( s ) [ : - <NUM_LIT:1> ] <EOL> if altchars is not None : <EOL> return _translate ( encoded , { '<STR_LIT:+>' : altchars [ <NUM_LIT:0> ] , '<STR_LIT:/>' : altchars [ <NUM_LIT:1> ] } ) <EOL> return encoded <EOL> def b64decode ( s , altchars = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if altchars is not None : <EOL> s = _translate ( s , { altchars [ <NUM_LIT:0> ] : '<STR_LIT:+>' , altchars [ <NUM_LIT:1> ] : '<STR_LIT:/>' } ) <EOL> try : <EOL> return binascii . a2b_base64 ( s ) <EOL> except binascii . Error , msg : <EOL> raise TypeError ( msg ) <EOL> def standard_b64encode ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return b64encode ( s ) <EOL> def standard_b64decode ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return b64decode ( s ) <EOL> def urlsafe_b64encode ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return b64encode ( s , '<STR_LIT>' ) <EOL> def urlsafe_b64decode ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return b64decode ( s , '<STR_LIT>' ) <EOL> _b32alphabet = { <EOL> <NUM_LIT:0> : '<STR_LIT:A>' , <NUM_LIT:9> : '<STR_LIT>' , <NUM_LIT> : '<STR_LIT:S>' , <NUM_LIT> : '<STR_LIT:3>' , <EOL> <NUM_LIT:1> : '<STR_LIT:B>' , <NUM_LIT:10> : '<STR_LIT>' , <NUM_LIT> : '<STR_LIT:T>' , <NUM_LIT> : '<STR_LIT:4>' , <EOL> <NUM_LIT:2> : '<STR_LIT:C>' , <NUM_LIT:11> : '<STR_LIT:L>' , <NUM_LIT:20> : '<STR_LIT>' , <NUM_LIT> : '<STR_LIT:5>' , <EOL> <NUM_LIT:3> : '<STR_LIT:D>' , <NUM_LIT:12> : '<STR_LIT:M>' , <NUM_LIT> : '<STR_LIT>' , <NUM_LIT:30> : '<STR_LIT>' , <EOL> <NUM_LIT:4> : '<STR_LIT:E>' , <NUM_LIT> : '<STR_LIT:N>' , <NUM_LIT> : '<STR_LIT>' , <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT:5> : '<STR_LIT:F>' , <NUM_LIT> : '<STR_LIT:O>' , <NUM_LIT> : '<STR_LIT:X>' , <EOL> <NUM_LIT:6> : '<STR_LIT>' , <NUM_LIT:15> : '<STR_LIT:P>' , <NUM_LIT> : '<STR_LIT:Y>' , <EOL> <NUM_LIT:7> : '<STR_LIT:H>' , <NUM_LIT:16> : '<STR_LIT>' , <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT:8> : '<STR_LIT:I>' , <NUM_LIT> : '<STR_LIT:R>' , <NUM_LIT> : '<STR_LIT:2>' , <EOL> } <EOL> _b32tab = _b32alphabet . items ( ) <EOL> _b32tab . sort ( ) <EOL> _b32tab = [ v for k , v in _b32tab ] <EOL> _b32rev = dict ( [ ( v , k ) for k , v in _b32alphabet . items ( ) ] ) <EOL> def b32encode ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> parts = [ ] <EOL> quanta , leftover = divmod ( len ( s ) , <NUM_LIT:5> ) <EOL> if leftover : <EOL> s += ( \"<STR_LIT>\" . ljust ( <NUM_LIT:5> - leftover , '<STR_LIT>' ) ) <EOL> quanta += <NUM_LIT:1> <EOL> for i in range ( quanta ) : <EOL> c1 , c2 , c3 = struct . unpack ( '<STR_LIT>' , s [ i * <NUM_LIT:5> : ( i + <NUM_LIT:1> ) * <NUM_LIT:5> ] ) <EOL> c2 += ( c1 & <NUM_LIT:1> ) << <NUM_LIT:16> <EOL> c3 += ( c2 & <NUM_LIT:3> ) << <NUM_LIT:8> <EOL> parts . extend ( [ _b32tab [ c1 >> <NUM_LIT:11> ] , <EOL> _b32tab [ ( c1 >> <NUM_LIT:6> ) & <NUM_LIT> ] , <EOL> _b32tab [ ( c1 >> <NUM_LIT:1> ) & <NUM_LIT> ] , <EOL> _b32tab [ c2 >> <NUM_LIT:12> ] , <EOL> _b32tab [ ( c2 >> <NUM_LIT:7> ) & <NUM_LIT> ] , <EOL> _b32tab [ ( c2 >> <NUM_LIT:2> ) & <NUM_LIT> ] , <EOL> _b32tab [ c3 >> <NUM_LIT:5> ] , <EOL> _b32tab [ c3 & <NUM_LIT> ] , <EOL> ] ) <EOL> encoded = EMPTYSTRING . join ( parts ) <EOL> if leftover == <NUM_LIT:1> : <EOL> return encoded [ : - <NUM_LIT:6> ] + '<STR_LIT>' <EOL> elif leftover == <NUM_LIT:2> : <EOL> return encoded [ : - <NUM_LIT:4> ] + '<STR_LIT>' <EOL> elif leftover == <NUM_LIT:3> : <EOL> return encoded [ : - <NUM_LIT:3> ] + '<STR_LIT>' <EOL> elif leftover == <NUM_LIT:4> : <EOL> return encoded [ : - <NUM_LIT:1> ] + '<STR_LIT:=>' <EOL> return encoded <EOL> def b32decode ( s , casefold = False , map01 = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> quanta , leftover = divmod ( len ( s ) , <NUM_LIT:8> ) <EOL>"}
{"rec_id": "4137", "recitation_code": "if leftover :", "input_code_id": 22554, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import struct <EOL> import binascii <EOL> __all__ = [ <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> ] <EOL> _translation = [ chr ( _x ) for _x in range ( <NUM_LIT> ) ] <EOL> EMPTYSTRING = '<STR_LIT>' <EOL> def _translate ( s , altchars ) : <EOL> translation = _translation [ : ] <EOL> for k , v in altchars . items ( ) : <EOL> translation [ ord ( k ) ] = v <EOL> t = '<STR_LIT>' <EOL> for c in s : <EOL> t += translation [ ord ( c ) ] <EOL> return t <EOL> def b64encode ( s , altchars = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> encoded = binascii . b2a_base64 ( s ) [ : - <NUM_LIT:1> ] <EOL> if altchars is not None : <EOL> return _translate ( encoded , { '<STR_LIT:+>' : altchars [ <NUM_LIT:0> ] , '<STR_LIT:/>' : altchars [ <NUM_LIT:1> ] } ) <EOL> return encoded <EOL> def b64decode ( s , altchars = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if altchars is not None : <EOL> s = _translate ( s , { altchars [ <NUM_LIT:0> ] : '<STR_LIT:+>' , altchars [ <NUM_LIT:1> ] : '<STR_LIT:/>' } ) <EOL> try : <EOL> return binascii . a2b_base64 ( s ) <EOL> except binascii . Error , msg : <EOL> raise TypeError ( msg ) <EOL> def standard_b64encode ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return b64encode ( s ) <EOL> def standard_b64decode ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return b64decode ( s ) <EOL> def urlsafe_b64encode ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return b64encode ( s , '<STR_LIT>' ) <EOL> def urlsafe_b64decode ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return b64decode ( s , '<STR_LIT>' ) <EOL> _b32alphabet = { <EOL> <NUM_LIT:0> : '<STR_LIT:A>' , <NUM_LIT:9> : '<STR_LIT>' , <NUM_LIT> : '<STR_LIT:S>' , <NUM_LIT> : '<STR_LIT:3>' , <EOL> <NUM_LIT:1> : '<STR_LIT:B>' , <NUM_LIT:10> : '<STR_LIT>' , <NUM_LIT> : '<STR_LIT:T>' , <NUM_LIT> : '<STR_LIT:4>' , <EOL> <NUM_LIT:2> : '<STR_LIT:C>' , <NUM_LIT:11> : '<STR_LIT:L>' , <NUM_LIT:20> : '<STR_LIT>' , <NUM_LIT> : '<STR_LIT:5>' , <EOL> <NUM_LIT:3> : '<STR_LIT:D>' , <NUM_LIT:12> : '<STR_LIT:M>' , <NUM_LIT> : '<STR_LIT>' , <NUM_LIT:30> : '<STR_LIT>' , <EOL> <NUM_LIT:4> : '<STR_LIT:E>' , <NUM_LIT> : '<STR_LIT:N>' , <NUM_LIT> : '<STR_LIT>' , <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT:5> : '<STR_LIT:F>' , <NUM_LIT> : '<STR_LIT:O>' , <NUM_LIT> : '<STR_LIT:X>' , <EOL> <NUM_LIT:6> : '<STR_LIT>' , <NUM_LIT:15> : '<STR_LIT:P>' , <NUM_LIT> : '<STR_LIT:Y>' , <EOL> <NUM_LIT:7> : '<STR_LIT:H>' , <NUM_LIT:16> : '<STR_LIT>' , <NUM_LIT> : '<STR_LIT>' , <EOL> <NUM_LIT:8> : '<STR_LIT:I>' , <NUM_LIT> : '<STR_LIT:R>' , <NUM_LIT> : '<STR_LIT:2>' , <EOL> } <EOL> _b32tab = _b32alphabet . items ( ) <EOL> _b32tab . sort ( ) <EOL> _b32tab = [ v for k , v in _b32tab ] <EOL> _b32rev = dict ( [ ( v , k ) for k , v in _b32alphabet . items ( ) ] ) <EOL> def b32encode ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> parts = [ ] <EOL> quanta , leftover = divmod ( len ( s ) , <NUM_LIT:5> ) <EOL> if leftover : <EOL> s += ( \"<STR_LIT>\" . ljust ( <NUM_LIT:5> - leftover , '<STR_LIT>' ) ) <EOL> quanta += <NUM_LIT:1> <EOL> for i in range ( quanta ) : <EOL> c1 , c2 , c3 = struct . unpack ( '<STR_LIT>' , s [ i * <NUM_LIT:5> : ( i + <NUM_LIT:1> ) * <NUM_LIT:5> ] ) <EOL> c2 += ( c1 & <NUM_LIT:1> ) << <NUM_LIT:16> <EOL> c3 += ( c2 & <NUM_LIT:3> ) << <NUM_LIT:8> <EOL> parts . extend ( [ _b32tab [ c1 >> <NUM_LIT:11> ] , <EOL> _b32tab [ ( c1 >> <NUM_LIT:6> ) & <NUM_LIT> ] , <EOL> _b32tab [ ( c1 >> <NUM_LIT:1> ) & <NUM_LIT> ] , <EOL> _b32tab [ c2 >> <NUM_LIT:12> ] , <EOL> _b32tab [ ( c2 >> <NUM_LIT:7> ) & <NUM_LIT> ] , <EOL> _b32tab [ ( c2 >> <NUM_LIT:2> ) & <NUM_LIT> ] , <EOL> _b32tab [ c3 >> <NUM_LIT:5> ] , <EOL> _b32tab [ c3 & <NUM_LIT> ] , <EOL> ] ) <EOL> encoded = EMPTYSTRING . join ( parts ) <EOL> if leftover == <NUM_LIT:1> : <EOL> return encoded [ : - <NUM_LIT:6> ] + '<STR_LIT>' <EOL> elif leftover == <NUM_LIT:2> : <EOL> return encoded [ : - <NUM_LIT:4> ] + '<STR_LIT>' <EOL> elif leftover == <NUM_LIT:3> : <EOL> return encoded [ : - <NUM_LIT:3> ] + '<STR_LIT>' <EOL> elif leftover == <NUM_LIT:4> : <EOL> return encoded [ : - <NUM_LIT:1> ] + '<STR_LIT:=>' <EOL> return encoded <EOL> def b32decode ( s , casefold = False , map01 = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> quanta , leftover = divmod ( len ( s ) , <NUM_LIT:8> ) <EOL>"}
{"rec_id": "4149", "recitation_code": "if self . install dir is None :", "input_code_id": 4149, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __revision__ = \"<STR_LIT>\" <EOL> import os <EOL> from distutils . core import Command <EOL> from distutils import log <EOL> from stat import ST_MODE <EOL> class install_scripts ( Command ) : <EOL> description = \"<STR_LIT>\" <EOL> user_options = [ <EOL> ( '<STR_LIT>' , '<STR_LIT:d>' , \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , '<STR_LIT:b>' , \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , '<STR_LIT:f>' , \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , None , \"<STR_LIT>\" ) , <EOL> ] <EOL> boolean_options = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def initialize_options ( self ) : <EOL> self . install_dir = None <EOL> self . force = <NUM_LIT:0> <EOL> self . build_dir = None <EOL> self . skip_build = None <EOL> def finalize_options ( self ) : <EOL>"}
{"rec_id": "4149", "recitation_code": "if self . install dir is None :", "input_code_id": 64055, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __revision__ = \"<STR_LIT>\" <EOL> import os <EOL> from distutils . core import Command <EOL> from distutils import log <EOL> from stat import ST_MODE <EOL> class install_scripts ( Command ) : <EOL> description = \"<STR_LIT>\" <EOL> user_options = [ <EOL> ( '<STR_LIT>' , '<STR_LIT:d>' , \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , '<STR_LIT:b>' , \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , '<STR_LIT:f>' , \"<STR_LIT>\" ) , <EOL> ( '<STR_LIT>' , None , \"<STR_LIT>\" ) , <EOL> ] <EOL> boolean_options = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def initialize_options ( self ) : <EOL> self . install_dir = None <EOL> self . force = <NUM_LIT:0> <EOL> self . build_dir = None <EOL> self . skip_build = None <EOL> def finalize_options ( self ) : <EOL>"}
{"rec_id": "4188", "recitation_code": "editor = CodeEdit ( )", "input_code_id": 4188, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import logging <EOL> logging . basicConfig ( level = logging . DEBUG ) <EOL> import sys <EOL> from pyqode . qt import QtWidgets <EOL> from pyqode . core . api import CodeEdit <EOL> from pyqode . core . backend import server <EOL> from pyqode . core . modes import AutoCompleteMode <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> app = QtWidgets . QApplication ( sys . argv ) <EOL>"}
{"rec_id": "4188", "recitation_code": "editor = CodeEdit ( )", "input_code_id": 8073, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import logging <EOL> logging . basicConfig ( level = logging . DEBUG ) <EOL> import sys <EOL> from pyqode . qt import QtWidgets <EOL> from pyqode . core . api import CodeEdit <EOL> from pyqode . core . backend import server <EOL> from pyqode . core . modes import AutoIndentMode <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> app = QtWidgets . QApplication ( sys . argv ) <EOL>"}
{"rec_id": "4188", "recitation_code": "editor = CodeEdit ( )", "input_code_id": 18381, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import logging <EOL> logging . basicConfig ( level = logging . DEBUG ) <EOL> import sys <EOL> from pyqode . qt import QtWidgets <EOL> from pyqode . core . api import CodeEdit , ColorScheme <EOL> from pyqode . core . backend import server <EOL> from pyqode . core . modes import PygmentsSH <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> app = QtWidgets . QApplication ( sys . argv ) <EOL>"}
{"rec_id": "4188", "recitation_code": "editor = CodeEdit ( )", "input_code_id": 49100, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import logging <EOL> logging . basicConfig ( level = logging . DEBUG ) <EOL> import sys <EOL> from pyqode . qt import QtWidgets <EOL> from pyqode . core . api import CodeEdit <EOL> from pyqode . core . backend import server <EOL> from pyqode . core . modes import CaretLineHighlighterMode <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> app = QtWidgets . QApplication ( sys . argv ) <EOL>"}
{"rec_id": "4188", "recitation_code": "editor = CodeEdit ( )", "input_code_id": 49101, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import logging <EOL> logging . basicConfig ( level = logging . DEBUG ) <EOL> import sys <EOL> from pyqode . qt import QtWidgets <EOL> from pyqode . core . api import CodeEdit <EOL> from pyqode . core . backend import server <EOL> from pyqode . core . panels import LineNumberPanel <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> app = QtWidgets . QApplication ( sys . argv ) <EOL>"}
{"rec_id": "4188", "recitation_code": "editor = CodeEdit ( )", "input_code_id": 69390, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import logging <EOL> logging . basicConfig ( level = logging . DEBUG ) <EOL> import sys <EOL> from pyqode . qt import QtWidgets <EOL> from pyqode . core . api import CodeEdit <EOL> from pyqode . core . backend import server <EOL> from pyqode . core . modes import CaretLineHighlighterMode <EOL> from pyqode . core . modes import PygmentsSyntaxHighlighter <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> app = QtWidgets . QApplication ( sys . argv ) <EOL>"}
{"rec_id": "4222", "recitation_code": "options . username , options . password )", "input_code_id": 4222, "input": "<s> from __future__ import print_function <EOL> import aerospike <EOL> import re <EOL> import sys <EOL> import os . path <EOL> from optparse import OptionParser <EOL> from aerospike import predicates as p <EOL> usage = \"<STR_LIT>\" <EOL> optparser = OptionParser ( usage = usage , add_help_option = False ) <EOL> optparser . add_option ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , dest = \"<STR_LIT:username>\" , type = \"<STR_LIT:string>\" , metavar = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" ) <EOL> optparser . add_option ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , dest = \"<STR_LIT:password>\" , type = \"<STR_LIT:string>\" , metavar = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" ) <EOL> optparser . add_option ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , dest = \"<STR_LIT:host>\" , type = \"<STR_LIT:string>\" , default = \"<STR_LIT:127.0.0.1>\" , metavar = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" ) <EOL> optparser . add_option ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , dest = \"<STR_LIT:port>\" , type = \"<STR_LIT:int>\" , default = <NUM_LIT> , metavar = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" ) <EOL> optparser . add_option ( <EOL> \"<STR_LIT>\" , dest = \"<STR_LIT>\" , action = \"<STR_LIT:store_true>\" , <EOL> help = \"<STR_LIT>\" ) <EOL> optparser . add_option ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , dest = \"<STR_LIT>\" , type = \"<STR_LIT:string>\" , default = \"<STR_LIT:test>\" , metavar = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" ) <EOL> optparser . add_option ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , dest = \"<STR_LIT>\" , type = \"<STR_LIT:string>\" , default = \"<STR_LIT>\" , metavar = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" ) <EOL> optparser . add_option ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , dest = \"<STR_LIT>\" , type = \"<STR_LIT:string>\" , <EOL> help = \"<STR_LIT>\" ) <EOL> optparser . add_option ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , dest = \"<STR_LIT>\" , type = \"<STR_LIT:string>\" , <EOL> help = \"<STR_LIT>\" ) <EOL> optparser . add_option ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , dest = \"<STR_LIT>\" , action = \"<STR_LIT>\" , type = \"<STR_LIT:string>\" , <EOL> help = \"<STR_LIT>\" ) <EOL> optparser . add_option ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , dest = \"<STR_LIT>\" , type = \"<STR_LIT:string>\" , action = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" ) <EOL> optparser . add_option ( <EOL> \"<STR_LIT>\" , dest = \"<STR_LIT>\" , action = \"<STR_LIT:store_true>\" , <EOL> help = \"<STR_LIT>\" ) <EOL> optparser . add_option ( <EOL> \"<STR_LIT>\" , dest = \"<STR_LIT>\" , action = \"<STR_LIT:store_true>\" , <EOL> help = \"<STR_LIT>\" ) <EOL> ( options , args ) = optparser . parse_args ( ) <EOL> if options . help : <EOL> optparser . print_help ( ) <EOL> print ( ) <EOL> sys . exit ( <NUM_LIT:1> ) <EOL> if len ( args ) > <NUM_LIT:1> : <EOL> optparser . print_help ( ) <EOL> print ( ) <EOL> sys . exit ( <NUM_LIT:1> ) <EOL> config = { <EOL> '<STR_LIT>' : [ ( options . host , options . port ) ] , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : os . path . dirname ( __file__ ) <EOL> } <EOL> } <EOL> exitCode = <NUM_LIT:0> <EOL> try : <EOL> client = aerospike . client ( config ) . connect ( <EOL>"}
{"rec_id": "4222", "recitation_code": "options . username , options . password )", "input_code_id": 63052, "input": "<s> from __future__ import print_function <EOL> import aerospike <EOL> import json <EOL> import re <EOL> import sys <EOL> import os . path <EOL> from optparse import OptionParser <EOL> from aerospike import predicates as p <EOL> usage = \"<STR_LIT>\" <EOL> optparser = OptionParser ( usage = usage , add_help_option = False ) <EOL> optparser . add_option ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , dest = \"<STR_LIT:username>\" , type = \"<STR_LIT:string>\" , metavar = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" ) <EOL> optparser . add_option ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , dest = \"<STR_LIT:password>\" , type = \"<STR_LIT:string>\" , metavar = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" ) <EOL> optparser . add_option ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , dest = \"<STR_LIT:host>\" , type = \"<STR_LIT:string>\" , default = \"<STR_LIT:127.0.0.1>\" , metavar = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" ) <EOL> optparser . add_option ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , dest = \"<STR_LIT:port>\" , type = \"<STR_LIT:int>\" , default = <NUM_LIT> , metavar = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" ) <EOL> optparser . add_option ( <EOL> \"<STR_LIT>\" , dest = \"<STR_LIT>\" , action = \"<STR_LIT:store_true>\" , <EOL> help = \"<STR_LIT>\" ) <EOL> optparser . add_option ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , dest = \"<STR_LIT>\" , type = \"<STR_LIT:string>\" , default = \"<STR_LIT:test>\" , metavar = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" ) <EOL> optparser . add_option ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , dest = \"<STR_LIT>\" , type = \"<STR_LIT:string>\" , default = \"<STR_LIT>\" , metavar = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" ) <EOL> optparser . add_option ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , dest = \"<STR_LIT>\" , type = \"<STR_LIT:string>\" , action = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" ) <EOL> ( options , args ) = optparser . parse_args ( ) <EOL> if options . help : <EOL> optparser . print_help ( ) <EOL> print ( ) <EOL> sys . exit ( <NUM_LIT:1> ) <EOL> if len ( args ) < <NUM_LIT:3> : <EOL> optparser . print_help ( ) <EOL> print ( ) <EOL> sys . exit ( <NUM_LIT:1> ) <EOL> config = { <EOL> '<STR_LIT>' : [ ( options . host , options . port ) ] , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : os . path . dirname ( __file__ ) <EOL> } <EOL> } <EOL> exitCode = <NUM_LIT:0> <EOL> def parse_arg ( s ) : <EOL> try : <EOL> return json . loads ( s ) <EOL> except ValueError : <EOL> return s <EOL> try : <EOL> client = aerospike . client ( config ) . connect ( <EOL>"}
{"rec_id": "4336", "recitation_code": "self . cert reqs = ssl . CERT NONE", "input_code_id": 4336, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> from rpyc . lib import safe_import <EOL> ssl = safe_import ( \"<STR_LIT>\" ) <EOL> class AuthenticationError ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> class SSLAuthenticator ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , keyfile , certfile , ca_certs = None , cert_reqs = None , <EOL> ssl_version = None , ciphers = None ) : <EOL> self . keyfile = keyfile <EOL> self . certfile = certfile <EOL> self . ca_certs = ca_certs <EOL> self . ciphers = ciphers <EOL> if cert_reqs is None : <EOL> if ca_certs : <EOL> self . cert_reqs = ssl . CERT_REQUIRED <EOL> else : <EOL>"}
{"rec_id": "4336", "recitation_code": "self . cert reqs = ssl . CERT NONE", "input_code_id": 9609, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> from rpyc . lib import safe_import <EOL> ssl = safe_import ( \"<STR_LIT>\" ) <EOL> class AuthenticationError ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> class SSLAuthenticator ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , keyfile , certfile , ca_certs = None , cert_reqs = None , <EOL> ssl_version = None , ciphers = None ) : <EOL> self . keyfile = str ( keyfile ) <EOL> self . certfile = str ( certfile ) <EOL> self . ca_certs = str ( ca_certs ) if ca_certs else None <EOL> self . ciphers = ciphers <EOL> if cert_reqs is None : <EOL> if ca_certs : <EOL> self . cert_reqs = ssl . CERT_REQUIRED <EOL> else : <EOL>"}
{"rec_id": "4430", "recitation_code": "def from config ( cls , config ) :", "input_code_id": 4430, "input": "<s> from app . util . network import Network <EOL> from app . util . shell . local_shell_client import LocalShellClient <EOL> from app . util . shell . remote_shell_client import RemoteShellClient <EOL> class ShellClientFactory ( object ) : <EOL> @ classmethod <EOL>"}
{"rec_id": "4430", "recitation_code": "def from config ( cls , config ) :", "input_code_id": 72536, "input": "<s> from __future__ import division <EOL> import base64 <EOL> import json <EOL> import logging <EOL> import os <EOL> import requests <EOL> from . _base import BaseClient <EOL> from . . bencode import bencode <EOL> logger = logging . getLogger ( __name__ ) <EOL> class UnableToLoginException ( Exception ) : <EOL> pass <EOL> class RPCCallFailedException ( Exception ) : <EOL> pass <EOL> class TransmissionVersionTooLowException ( Exception ) : <EOL> pass <EOL> class TransmissionClient ( BaseClient ) : <EOL> identifier = '<STR_LIT>' <EOL> _session_id = '<STR_LIT>' <EOL> def __init__ ( self , url ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . url = url <EOL> def _call ( self , method , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> logger . debug ( '<STR_LIT>' % ( method , kwargs ) ) <EOL> return requests . post ( self . url , data = json . dumps ( { '<STR_LIT>' : method , '<STR_LIT>' : kwargs } ) , headers = { '<STR_LIT>' : self . _session_id } ) <EOL> def call ( self , method , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> r = self . _call ( method , ** kwargs ) <EOL> if r . status_code == <NUM_LIT> : <EOL> self . _session_id = r . headers [ '<STR_LIT>' ] <EOL> r = self . _call ( method , ** kwargs ) <EOL> if r . status_code != <NUM_LIT:200> : <EOL> raise UnableToLoginException ( ) <EOL> r = r . json ( ) <EOL> logger . debug ( '<STR_LIT>' % r ) <EOL> if r [ '<STR_LIT:result>' ] != '<STR_LIT:success>' : <EOL> raise RPCCallFailedException ( ) <EOL> return r [ '<STR_LIT>' ] <EOL> def get_config ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return { <EOL> '<STR_LIT:url>' : self . url , <EOL> } <EOL> @ classmethod <EOL>"}
{"rec_id": "4491", "recitation_code": "class NotFound ( Exception ) :", "input_code_id": 4491, "input": "<s> class NoMatch ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL>"}
{"rec_id": "4491", "recitation_code": "class NotFound ( Exception ) :", "input_code_id": 82265, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from inspect import cleandoc <EOL> from eliot import register_exception_extractor <EOL> from twisted . web . http import BAD_REQUEST , FORBIDDEN , NOT_FOUND <EOL> __all__ = [ <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> UNPROCESSABLE_REQUEST = <NUM_LIT> <EOL> class BadRequest ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , code , result ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> Exception . __init__ ( self , code , result ) <EOL> self . code = code <EOL> self . result = result <EOL> register_exception_extractor ( BadRequest , lambda e : { u\"<STR_LIT:code>\" : e . code } ) <EOL>"}
{"rec_id": "4517", "recitation_code": "passesSelectionTest = lambda x : True", "input_code_id": 4517, "input": "<s> '''<STR_LIT>''' <EOL> import re <EOL> from pyfbsdk import FBSystem <EOL> from pyfbsdk import FBProgress <EOL> kAllSceneComponents = FBSystem ( ) . Scene . Components <EOL> def deselect ( pattern = None , ** kwargs ) : <EOL> '''<STR_LIT>''' <EOL> kwargs [ '<STR_LIT>' ] = True <EOL> if not hasattr ( pattern , '<STR_LIT>' ) : <EOL> pattern = [ pattern ] <EOL> for item in pattern : <EOL> matched = ls ( pattern = item , ** kwargs ) <EOL> for obj in matched : <EOL> try : <EOL> obj . component . Selected = False <EOL> except : <EOL> obj . Selected = False <EOL> def select ( pattern = None , add = False , toggle = False , ** kwargs ) : <EOL> '''<STR_LIT>''' <EOL> if not hasattr ( pattern , \"<STR_LIT>\" ) : <EOL> pattern = [ pattern ] <EOL> kwargs . pop ( '<STR_LIT>' , None ) <EOL> if not add and not toggle : <EOL> deselect ( pattern = None , ** kwargs ) <EOL> if toggle : <EOL> def selectFunc ( x ) : <EOL> try : <EOL> x . component . Selected = not x . component . Selected <EOL> except : <EOL> x . Selected = not x . Selected <EOL> else : <EOL> def selectFunc ( x ) : <EOL> try : <EOL> x . component . Selected = True <EOL> except : <EOL> x . Selected = True <EOL> for item in pattern : <EOL> matched = ls ( pattern = item , ** kwargs ) <EOL> map ( selectFunc , matched ) <EOL> def delete ( pattern = None , ** kwargs ) : <EOL> '''<STR_LIT>''' <EOL> if not hasattr ( pattern , \"<STR_LIT>\" ) : <EOL> pattern = [ pattern ] <EOL> for item in pattern : <EOL> matched = ls ( pattern = item , ** kwargs ) <EOL> for obj in matched : <EOL> try : <EOL> obj . component . FBDelete ( ) <EOL> except : <EOL> obj . FBDelete ( ) <EOL> def ls ( pattern = None , _type = None , selected = None , visible = None , includeNamespace = True ) : <EOL> '''<STR_LIT>''' <EOL> if pattern : <EOL> if includeNamespace : <EOL> getName = lambda x : getattr ( x , '<STR_LIT>' , x . Name ) <EOL> else : <EOL> getName = lambda x : x . Name <EOL> if '<STR_LIT:*>' in pattern : <EOL> pattern = pattern . replace ( '<STR_LIT:*>' , '<STR_LIT>' ) <EOL> passesNameTest = lambda x : re . match ( pattern , getName ( x ) ) <EOL> else : <EOL> passesNameTest = lambda x : pattern == getName ( x ) <EOL> else : <EOL> passesNameTest = lambda x : True <EOL> if selected is not None : <EOL> passesSelectionTest = lambda x : x . Selected == selected <EOL> else : <EOL>"}
{"rec_id": "4517", "recitation_code": "passesSelectionTest = lambda x : True", "input_code_id": 21141, "input": "<s> '''<STR_LIT>''' <EOL> import re <EOL> from pyfbsdk import FBSystem <EOL> from pyfbsdk import FBProgress <EOL> kAllSceneComponents = FBSystem ( ) . Scene . Components <EOL> def deselect ( pattern = None , ** kwargs ) : <EOL> '''<STR_LIT>''' <EOL> kwargs [ '<STR_LIT>' ] = True <EOL> if not hasattr ( pattern , '<STR_LIT>' ) : <EOL> pattern = [ pattern ] <EOL> for item in pattern : <EOL> matched = ls ( pattern = item , ** kwargs ) <EOL> for obj in matched : <EOL> try : <EOL> obj . component . Selected = False <EOL> except : <EOL> obj . Selected = False <EOL> def select ( pattern = None , add = False , toggle = False , ** kwargs ) : <EOL> '''<STR_LIT>''' <EOL> if not hasattr ( pattern , \"<STR_LIT>\" ) : <EOL> pattern = [ pattern ] <EOL> kwargs . pop ( '<STR_LIT>' , None ) <EOL> if not add and not toggle : <EOL> deselect ( pattern = None , ** kwargs ) <EOL> if toggle : <EOL> def selectFunc ( x ) : <EOL> try : <EOL> x . component . Selected = not x . component . Selected <EOL> except : <EOL> x . Selected = not x . Selected <EOL> else : <EOL> def selectFunc ( x ) : <EOL> try : <EOL> x . component . Selected = True <EOL> except : <EOL> x . Selected = True <EOL> for item in pattern : <EOL> matched = ls ( pattern = item , ** kwargs ) <EOL> map ( selectFunc , matched ) <EOL> def delete ( pattern = None , ** kwargs ) : <EOL> '''<STR_LIT>''' <EOL> if not hasattr ( pattern , \"<STR_LIT>\" ) : <EOL> pattern = [ pattern ] <EOL> for item in pattern : <EOL> matched = ls ( pattern = item , ** kwargs ) <EOL> for obj in matched : <EOL> try : <EOL> obj . component . FBDelete ( ) <EOL> except : <EOL> obj . FBDelete ( ) <EOL> def ls ( pattern = None , _type = None , selected = None , visible = None , includeNamespace = True ) : <EOL> '''<STR_LIT>''' <EOL> if pattern : <EOL> if includeNamespace : <EOL> getName = lambda x : getattr ( x , '<STR_LIT>' , x . Name ) <EOL> else : <EOL> getName = lambda x : x . Name <EOL> if '<STR_LIT:*>' in pattern : <EOL> pattern = pattern . replace ( '<STR_LIT:*>' , '<STR_LIT>' ) <EOL> passesNameTest = lambda x : re . match ( pattern , getName ( x ) ) <EOL> else : <EOL> passesNameTest = lambda x : pattern == getName ( x ) <EOL> else : <EOL> passesNameTest = lambda x : True <EOL> if selected is not None : <EOL> passesSelectionTest = lambda x : x . Selected == selected <EOL> else : <EOL>"}
{"rec_id": "4592", "recitation_code": "u2 = random ( )", "input_code_id": 4592, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from warnings import warn as _warn <EOL> from types import MethodType as _MethodType , BuiltinMethodType as _BuiltinMethodType <EOL> from math import log as _log , exp as _exp , pi as _pi , e as _e <EOL> from math import sqrt as _sqrt , acos as _acos , cos as _cos , sin as _sin <EOL> from os import urandom as _urandom <EOL> from binascii import hexlify as _hexlify <EOL> __all__ = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ] <EOL> NV_MAGICCONST = <NUM_LIT:4> * _exp ( - <NUM_LIT:0.5> ) / _sqrt ( <NUM_LIT> ) <EOL> TWOPI = <NUM_LIT> * _pi <EOL> LOG4 = _log ( <NUM_LIT> ) <EOL> SG_MAGICCONST = <NUM_LIT:1.0> + _log ( <NUM_LIT> ) <EOL> BPF = <NUM_LIT> <EOL> RECIP_BPF = <NUM_LIT:2> ** - BPF <EOL> import _random <EOL> class Random ( _random . Random ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> VERSION = <NUM_LIT:2> <EOL> def __init__ ( self , x = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . seed ( x ) <EOL> self . gauss_next = None <EOL> def seed ( self , a = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if a is None : <EOL> try : <EOL> a = long ( _hexlify ( _urandom ( <NUM_LIT:16> ) ) , <NUM_LIT:16> ) <EOL> except NotImplementedError : <EOL> import time <EOL> a = long ( time . time ( ) * <NUM_LIT> ) <EOL> super ( Random , self ) . seed ( a ) <EOL> self . gauss_next = None <EOL> def getstate ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . VERSION , super ( Random , self ) . getstate ( ) , self . gauss_next <EOL> def setstate ( self , state ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> version = state [ <NUM_LIT:0> ] <EOL> if version == <NUM_LIT:2> : <EOL> version , internalstate , self . gauss_next = state <EOL> super ( Random , self ) . setstate ( internalstate ) <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % <EOL> ( version , self . VERSION ) ) <EOL> def __getstate__ ( self ) : <EOL> return self . getstate ( ) <EOL> def __setstate__ ( self , state ) : <EOL> self . setstate ( state ) <EOL> def __reduce__ ( self ) : <EOL> return self . __class__ , ( ) , self . getstate ( ) <EOL> def randrange ( self , start , stop = None , step = <NUM_LIT:1> , int = int , default = None , <EOL> maxwidth = <NUM_LIT:1> L << BPF ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> istart = int ( start ) <EOL> if istart != start : <EOL> raise ValueError , \"<STR_LIT>\" <EOL> if stop is default : <EOL> if istart > <NUM_LIT:0> : <EOL> if istart >= maxwidth : <EOL> return self . _randbelow ( istart ) <EOL> return int ( self . random ( ) * istart ) <EOL> raise ValueError , \"<STR_LIT>\" <EOL> istop = int ( stop ) <EOL> if istop != stop : <EOL> raise ValueError , \"<STR_LIT>\" <EOL> width = istop - istart <EOL> if step == <NUM_LIT:1> and width > <NUM_LIT:0> : <EOL> if width >= maxwidth : <EOL> return int ( istart + self . _randbelow ( width ) ) <EOL> return int ( istart + int ( self . random ( ) * width ) ) <EOL> if step == <NUM_LIT:1> : <EOL> raise ValueError , \"<STR_LIT>\" % ( istart , istop , width ) <EOL> istep = int ( step ) <EOL> if istep != step : <EOL> raise ValueError , \"<STR_LIT>\" <EOL> if istep > <NUM_LIT:0> : <EOL> n = ( width + istep - <NUM_LIT:1> ) // istep <EOL> elif istep < <NUM_LIT:0> : <EOL> n = ( width + istep + <NUM_LIT:1> ) // istep <EOL> else : <EOL> raise ValueError , \"<STR_LIT>\" <EOL> if n <= <NUM_LIT:0> : <EOL> raise ValueError , \"<STR_LIT>\" <EOL> if n >= maxwidth : <EOL> return istart + self . _randbelow ( n ) <EOL> return istart + istep * int ( self . random ( ) * n ) <EOL> def randint ( self , a , b ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . randrange ( a , b + <NUM_LIT:1> ) <EOL> def _randbelow ( self , n , _log = _log , int = int , _maxwidth = <NUM_LIT:1> L << BPF , <EOL> _Method = _MethodType , _BuiltinMethod = _BuiltinMethodType ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> getrandbits = self . getrandbits <EOL> except AttributeError : <EOL> pass <EOL> else : <EOL> if type ( self . random ) is _BuiltinMethod or type ( getrandbits ) is _Method : <EOL> k = int ( <NUM_LIT> + _log ( n - <NUM_LIT:1> , <NUM_LIT> ) ) <EOL> r = getrandbits ( k ) <EOL> while r >= n : <EOL> r = getrandbits ( k ) <EOL> return r <EOL> if n >= _maxwidth : <EOL> _warn ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> return int ( self . random ( ) * n ) <EOL> def choice ( self , seq ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return seq [ int ( self . random ( ) * len ( seq ) ) ] <EOL> def shuffle ( self , x , random = None , int = int ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if random is None : <EOL> random = self . random <EOL> for i in reversed ( xrange ( <NUM_LIT:1> , len ( x ) ) ) : <EOL> j = int ( random ( ) * ( i + <NUM_LIT:1> ) ) <EOL> x [ i ] , x [ j ] = x [ j ] , x [ i ] <EOL> def sample ( self , population , k ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> n = len ( population ) <EOL> if not <NUM_LIT:0> <= k <= n : <EOL> raise ValueError , \"<STR_LIT>\" <EOL> random = self . random <EOL> _int = int <EOL> result = [ None ] * k <EOL> if n < <NUM_LIT:6> * k : <EOL> pool = list ( population ) <EOL> for i in xrange ( k ) : <EOL> j = _int ( random ( ) * ( n - i ) ) <EOL> result [ i ] = pool [ j ] <EOL> pool [ j ] = pool [ n - i - <NUM_LIT:1> ] <EOL> else : <EOL> try : <EOL> n > <NUM_LIT:0> and ( population [ <NUM_LIT:0> ] , population [ n // <NUM_LIT:2> ] , population [ n - <NUM_LIT:1> ] ) <EOL> except ( TypeError , KeyError ) : <EOL> population = tuple ( population ) <EOL> selected = { } <EOL> for i in xrange ( k ) : <EOL> j = _int ( random ( ) * n ) <EOL> while j in selected : <EOL> j = _int ( random ( ) * n ) <EOL> result [ i ] = selected [ j ] = population [ j ] <EOL> return result <EOL> def uniform ( self , a , b ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return a + ( b - a ) * self . random ( ) <EOL> def normalvariate ( self , mu , sigma ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> random = self . random <EOL> while <NUM_LIT:1> : <EOL> u1 = random ( ) <EOL> u2 = <NUM_LIT:1.0> - random ( ) <EOL> z = NV_MAGICCONST * ( u1 - <NUM_LIT:0.5> ) / u2 <EOL> zz = z * z / <NUM_LIT> <EOL> if zz <= - _log ( u2 ) : <EOL> break <EOL> return mu + z * sigma <EOL> def lognormvariate ( self , mu , sigma ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return _exp ( self . normalvariate ( mu , sigma ) ) <EOL> def expovariate ( self , lambd ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> random = self . random <EOL> u = random ( ) <EOL> while u <= <NUM_LIT> : <EOL> u = random ( ) <EOL> return - _log ( u ) / lambd <EOL> def vonmisesvariate ( self , mu , kappa ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> random = self . random <EOL> if kappa <= <NUM_LIT> : <EOL> return TWOPI * random ( ) <EOL> a = <NUM_LIT:1.0> + _sqrt ( <NUM_LIT:1.0> + <NUM_LIT> * kappa * kappa ) <EOL> b = ( a - _sqrt ( <NUM_LIT> * a ) ) / ( <NUM_LIT> * kappa ) <EOL> r = ( <NUM_LIT:1.0> + b * b ) / ( <NUM_LIT> * b ) <EOL> while <NUM_LIT:1> : <EOL> u1 = random ( ) <EOL> z = _cos ( _pi * u1 ) <EOL> f = ( <NUM_LIT:1.0> + r * z ) / ( r + z ) <EOL> c = kappa * ( r - f ) <EOL> u2 = random ( ) <EOL> if u2 < c * ( <NUM_LIT> - c ) or u2 <= c * _exp ( <NUM_LIT:1.0> - c ) : <EOL> break <EOL> u3 = random ( ) <EOL> if u3 > <NUM_LIT:0.5> : <EOL> theta = ( mu % TWOPI ) + _acos ( f ) <EOL> else : <EOL> theta = ( mu % TWOPI ) - _acos ( f ) <EOL> return theta <EOL> def gammavariate ( self , alpha , beta ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if alpha <= <NUM_LIT:0.0> or beta <= <NUM_LIT:0.0> : <EOL> raise ValueError , '<STR_LIT>' <EOL> random = self . random <EOL> if alpha > <NUM_LIT:1.0> : <EOL> ainv = _sqrt ( <NUM_LIT> * alpha - <NUM_LIT:1.0> ) <EOL> bbb = alpha - LOG4 <EOL> ccc = alpha + ainv <EOL> while <NUM_LIT:1> : <EOL> u1 = random ( ) <EOL> if not <NUM_LIT> < u1 < <NUM_LIT> : <EOL> continue <EOL>"}
{"rec_id": "4592", "recitation_code": "u2 = random ( )", "input_code_id": 60447, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from warnings import warn as _warn <EOL> from math import log as _log , exp as _exp , pi as _pi , e as _e , ceil as _ceil <EOL> from math import sqrt as _sqrt , acos as _acos , cos as _cos , sin as _sin <EOL> from os import urandom as _urandom <EOL> from binascii import hexlify as _hexlify <EOL> __all__ = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ] <EOL> NV_MAGICCONST = <NUM_LIT:4> * _exp ( - <NUM_LIT:0.5> ) / _sqrt ( <NUM_LIT> ) <EOL> TWOPI = <NUM_LIT> * _pi <EOL> LOG4 = _log ( <NUM_LIT> ) <EOL> SG_MAGICCONST = <NUM_LIT:1.0> + _log ( <NUM_LIT> ) <EOL> BPF = <NUM_LIT> <EOL> RECIP_BPF = <NUM_LIT:2> ** - BPF <EOL> import _random <EOL> class Random ( _random . Random ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> VERSION = <NUM_LIT:2> <EOL> def __init__ ( self , x = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . seed ( x ) <EOL> self . gauss_next = None <EOL> def seed ( self , a = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if a is None : <EOL> try : <EOL> a = long ( _hexlify ( _urandom ( <NUM_LIT:16> ) ) , <NUM_LIT:16> ) <EOL> except NotImplementedError : <EOL> import time <EOL> a = long ( time . time ( ) * <NUM_LIT> ) <EOL> super ( Random , self ) . seed ( a ) <EOL> self . gauss_next = None <EOL> def getstate ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . VERSION , super ( Random , self ) . getstate ( ) , self . gauss_next <EOL> def setstate ( self , state ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> version = state [ <NUM_LIT:0> ] <EOL> if version == <NUM_LIT:2> : <EOL> version , internalstate , self . gauss_next = state <EOL> super ( Random , self ) . setstate ( internalstate ) <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % <EOL> ( version , self . VERSION ) ) <EOL> def __getstate__ ( self ) : <EOL> return self . getstate ( ) <EOL> def __setstate__ ( self , state ) : <EOL> self . setstate ( state ) <EOL> def __reduce__ ( self ) : <EOL> return self . __class__ , ( ) , self . getstate ( ) <EOL> def randrange ( self , start , stop = None , step = <NUM_LIT:1> , int = int , default = None , <EOL> maxwidth = <NUM_LIT:1> L << BPF ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> istart = int ( start ) <EOL> if istart != start : <EOL> raise ValueError , \"<STR_LIT>\" <EOL> if stop is default : <EOL> if istart > <NUM_LIT:0> : <EOL> if istart >= maxwidth : <EOL> return self . _randbelow ( istart ) <EOL> return int ( self . random ( ) * istart ) <EOL> raise ValueError , \"<STR_LIT>\" <EOL> istop = int ( stop ) <EOL> if istop != stop : <EOL> raise ValueError , \"<STR_LIT>\" <EOL> width = istop - istart <EOL> if step == <NUM_LIT:1> and width > <NUM_LIT:0> : <EOL> if width >= maxwidth : <EOL> return int ( istart + self . _randbelow ( width ) ) <EOL> return int ( istart + int ( self . random ( ) * width ) ) <EOL> if step == <NUM_LIT:1> : <EOL> raise ValueError , \"<STR_LIT>\" % ( istart , istop , width ) <EOL> istep = int ( step ) <EOL> if istep != step : <EOL> raise ValueError , \"<STR_LIT>\" <EOL> if istep > <NUM_LIT:0> : <EOL> n = ( width + istep - <NUM_LIT:1> ) // istep <EOL> elif istep < <NUM_LIT:0> : <EOL> n = ( width + istep + <NUM_LIT:1> ) // istep <EOL> else : <EOL> raise ValueError , \"<STR_LIT>\" <EOL> if n <= <NUM_LIT:0> : <EOL> raise ValueError , \"<STR_LIT>\" <EOL> if n >= maxwidth : <EOL> return istart + istep * self . _randbelow ( n ) <EOL> return istart + istep * int ( self . random ( ) * n ) <EOL> def randint ( self , a , b ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . randrange ( a , b + <NUM_LIT:1> ) <EOL> def _randbelow ( self , n , _log = _log , int = int , _maxwidth = <NUM_LIT:1> L << BPF ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if ( type ( self ) . random == Random . random or <EOL> type ( self ) . getrandbits != Random . getrandbits ) : <EOL> getrandbits = self . getrandbits <EOL> k = int ( <NUM_LIT> + _log ( n - <NUM_LIT:1> , <NUM_LIT> ) ) <EOL> r = getrandbits ( k ) <EOL> while r >= n : <EOL> r = getrandbits ( k ) <EOL> return r <EOL> if n >= _maxwidth : <EOL> _warn ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> return int ( self . random ( ) * n ) <EOL> def choice ( self , seq ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return seq [ int ( self . random ( ) * len ( seq ) ) ] <EOL> def shuffle ( self , x , random = None , int = int ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if random is None : <EOL> random = self . random <EOL> for i in reversed ( xrange ( <NUM_LIT:1> , len ( x ) ) ) : <EOL> j = int ( random ( ) * ( i + <NUM_LIT:1> ) ) <EOL> x [ i ] , x [ j ] = x [ j ] , x [ i ] <EOL> def sample ( self , population , k ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> n = len ( population ) <EOL> if not <NUM_LIT:0> <= k <= n : <EOL> raise ValueError , \"<STR_LIT>\" <EOL> random = self . random <EOL> _int = int <EOL> result = [ None ] * k <EOL> setsize = <NUM_LIT> <EOL> if k > <NUM_LIT:5> : <EOL> setsize += <NUM_LIT:4> ** _ceil ( _log ( k * <NUM_LIT:3> , <NUM_LIT:4> ) ) <EOL> if n <= setsize or hasattr ( population , \"<STR_LIT>\" ) : <EOL> pool = list ( population ) <EOL> for i in xrange ( k ) : <EOL> j = _int ( random ( ) * ( n - i ) ) <EOL> result [ i ] = pool [ j ] <EOL> pool [ j ] = pool [ n - i - <NUM_LIT:1> ] <EOL> else : <EOL> try : <EOL> selected = set ( ) <EOL> selected_add = selected . add <EOL> for i in xrange ( k ) : <EOL> j = _int ( random ( ) * n ) <EOL> while j in selected : <EOL> j = _int ( random ( ) * n ) <EOL> selected_add ( j ) <EOL> result [ i ] = population [ j ] <EOL> except ( TypeError , KeyError ) : <EOL> if isinstance ( population , list ) : <EOL> raise <EOL> return self . sample ( tuple ( population ) , k ) <EOL> return result <EOL> def uniform ( self , a , b ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return a + ( b - a ) * self . random ( ) <EOL> def normalvariate ( self , mu , sigma ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> random = self . random <EOL> while <NUM_LIT:1> : <EOL> u1 = random ( ) <EOL> u2 = <NUM_LIT:1.0> - random ( ) <EOL> z = NV_MAGICCONST * ( u1 - <NUM_LIT:0.5> ) / u2 <EOL> zz = z * z / <NUM_LIT> <EOL> if zz <= - _log ( u2 ) : <EOL> break <EOL> return mu + z * sigma <EOL> def lognormvariate ( self , mu , sigma ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return _exp ( self . normalvariate ( mu , sigma ) ) <EOL> def expovariate ( self , lambd ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> random = self . random <EOL> u = random ( ) <EOL> while u <= <NUM_LIT> : <EOL> u = random ( ) <EOL> return - _log ( u ) / lambd <EOL> def vonmisesvariate ( self , mu , kappa ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> random = self . random <EOL> if kappa <= <NUM_LIT> : <EOL> return TWOPI * random ( ) <EOL> a = <NUM_LIT:1.0> + _sqrt ( <NUM_LIT:1.0> + <NUM_LIT> * kappa * kappa ) <EOL> b = ( a - _sqrt ( <NUM_LIT> * a ) ) / ( <NUM_LIT> * kappa ) <EOL> r = ( <NUM_LIT:1.0> + b * b ) / ( <NUM_LIT> * b ) <EOL> while <NUM_LIT:1> : <EOL> u1 = random ( ) <EOL> z = _cos ( _pi * u1 ) <EOL> f = ( <NUM_LIT:1.0> + r * z ) / ( r + z ) <EOL> c = kappa * ( r - f ) <EOL> u2 = random ( ) <EOL> if u2 < c * ( <NUM_LIT> - c ) or u2 <= c * _exp ( <NUM_LIT:1.0> - c ) : <EOL> break <EOL> u3 = random ( ) <EOL> if u3 > <NUM_LIT:0.5> : <EOL> theta = ( mu % TWOPI ) + _acos ( f ) <EOL> else : <EOL> theta = ( mu % TWOPI ) - _acos ( f ) <EOL> return theta <EOL> def gammavariate ( self , alpha , beta ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if alpha <= <NUM_LIT:0.0> or beta <= <NUM_LIT:0.0> : <EOL> raise ValueError , '<STR_LIT>' <EOL> random = self . random <EOL> if alpha > <NUM_LIT:1.0> : <EOL> ainv = _sqrt ( <NUM_LIT> * alpha - <NUM_LIT:1.0> ) <EOL> bbb = alpha - LOG4 <EOL> ccc = alpha + ainv <EOL> while <NUM_LIT:1> : <EOL> u1 = random ( ) <EOL> if not <NUM_LIT> < u1 < <NUM_LIT> : <EOL> continue <EOL>"}
{"rec_id": "4710", "recitation_code": "if passwd :", "input_code_id": 4710, "input": "<s> import os <EOL> import subprocess <EOL> from django . core . files . temp import NamedTemporaryFile <EOL> from django . db . backends . base . client import BaseDatabaseClient <EOL> from django . utils . six import print_ <EOL> def _escape_pgpass ( txt ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return txt . replace ( '<STR_LIT:\\\\>' , '<STR_LIT>' ) . replace ( '<STR_LIT::>' , '<STR_LIT>' ) <EOL> class DatabaseClient ( BaseDatabaseClient ) : <EOL> executable_name = '<STR_LIT>' <EOL> @ classmethod <EOL> def runshell_db ( cls , settings_dict ) : <EOL> args = [ cls . executable_name ] <EOL> host = settings_dict . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> port = settings_dict . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> name = settings_dict . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> user = settings_dict . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> passwd = settings_dict . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if user : <EOL> args += [ '<STR_LIT>' , user ] <EOL> if host : <EOL> args += [ '<STR_LIT>' , host ] <EOL> if port : <EOL> args += [ '<STR_LIT>' , str ( port ) ] <EOL> args += [ name ] <EOL>"}
{"rec_id": "4710", "recitation_code": "if passwd :", "input_code_id": 16892, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import hashlib <EOL> import random <EOL> from utils import Storage , to36 , valid_email , ALPHANUMERICS as ALPHAS <EOL> username_regex = r'<STR_LIT>' <EOL> passwd_regex = r'<STR_LIT>' <EOL> class Account ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ classmethod <EOL> def authenticate ( cls , username , passwd , salt , uhash ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return cls . _roast ( username + salt + passwd ) == uhash <EOL> @ classmethod <EOL> def register ( cls , username , passwd , passwd2 = None , salt = '<STR_LIT>' , email = '<STR_LIT>' , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not passwd : raise ValueError ( '<STR_LIT>' ) <EOL> if email and not valid_email ( email ) : <EOL> raise ValueError ( \"<STR_LIT>\" \"<STR_LIT>\" % email ) <EOL>"}
{"rec_id": "4770", "recitation_code": "self . max url len = max url len", "input_code_id": 4770, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from oslo . config import cfg <EOL> from rack import exception <EOL> from rack . openstack . common . gettextutils import _ <EOL> from rack . openstack . common import importutils <EOL> from rack . openstack . common import log as logging <EOL> from rack . openstack . common import service <EOL> from rack import utils <EOL> from rack import wsgi <EOL> LOG = logging . getLogger ( __name__ ) <EOL> service_opts = [ <EOL> cfg . StrOpt ( '<STR_LIT>' , <EOL> default = \"<STR_LIT>\" , <EOL> help = '<STR_LIT>' ) , <EOL> cfg . IntOpt ( '<STR_LIT>' , <EOL> default = <NUM_LIT> , <EOL> help = '<STR_LIT>' ) , <EOL> cfg . IntOpt ( '<STR_LIT>' , <EOL> help = '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> ] <EOL> CONF = cfg . CONF <EOL> CONF . register_opts ( service_opts ) <EOL> CONF . import_opt ( '<STR_LIT:host>' , '<STR_LIT>' ) <EOL> class WSGIService ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , name , loader = None , use_ssl = False , max_url_len = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . name = name <EOL> self . manager = self . _get_manager ( ) <EOL> self . loader = loader or wsgi . Loader ( ) <EOL> self . app = self . loader . load_app ( name ) <EOL> self . host = getattr ( CONF , '<STR_LIT>' % name , \"<STR_LIT>\" ) <EOL> self . port = getattr ( CONF , '<STR_LIT>' % name , <NUM_LIT:0> ) <EOL> self . workers = ( getattr ( CONF , '<STR_LIT>' % name , None ) or <EOL> utils . cpu_count ( ) ) <EOL> if self . workers and self . workers < <NUM_LIT:1> : <EOL> worker_name = '<STR_LIT>' % name <EOL> msg = ( _ ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) % <EOL> { '<STR_LIT>' : worker_name , <EOL> '<STR_LIT>' : str ( self . workers ) } ) <EOL> raise exception . InvalidInput ( msg ) <EOL> self . use_ssl = use_ssl <EOL>"}
{"rec_id": "4770", "recitation_code": "self . max url len = max url len", "input_code_id": 17725, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from oslo_concurrency import processutils <EOL> from oslo_config import cfg <EOL> from oslo_log import log as logging <EOL> from oslo_service import service <EOL> from oslo_utils import importutils <EOL> from ec2api import exception <EOL> from ec2api . i18n import _ <EOL> from ec2api import wsgi <EOL> LOG = logging . getLogger ( __name__ ) <EOL> service_opts = [ <EOL> cfg . StrOpt ( '<STR_LIT>' , <EOL> default = \"<STR_LIT>\" , <EOL> help = '<STR_LIT>' ) , <EOL> cfg . IntOpt ( '<STR_LIT>' , <EOL> default = <NUM_LIT> , <EOL> help = '<STR_LIT>' ) , <EOL> cfg . BoolOpt ( '<STR_LIT>' , <EOL> default = False , <EOL> help = '<STR_LIT>' ) , <EOL> cfg . IntOpt ( '<STR_LIT>' , <EOL> help = '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> cfg . StrOpt ( '<STR_LIT>' , <EOL> default = \"<STR_LIT>\" , <EOL> help = '<STR_LIT>' ) , <EOL> cfg . IntOpt ( '<STR_LIT>' , <EOL> default = <NUM_LIT> , <EOL> help = '<STR_LIT>' ) , <EOL> cfg . BoolOpt ( '<STR_LIT>' , <EOL> default = False , <EOL> help = '<STR_LIT>' ) , <EOL> cfg . IntOpt ( '<STR_LIT>' , <EOL> help = '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> cfg . IntOpt ( '<STR_LIT>' , <EOL> default = <NUM_LIT> , <EOL> help = '<STR_LIT>' ) , <EOL> ] <EOL> CONF = cfg . CONF <EOL> CONF . register_opts ( service_opts ) <EOL> class WSGIService ( service . ServiceBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , name , loader = None , max_url_len = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . name = name <EOL> self . manager = self . _get_manager ( ) <EOL> self . loader = loader or wsgi . Loader ( ) <EOL> self . app = self . loader . load_app ( name ) <EOL> self . host = getattr ( CONF , '<STR_LIT>' % name , \"<STR_LIT>\" ) <EOL> self . port = getattr ( CONF , '<STR_LIT>' % name , <NUM_LIT:0> ) <EOL>"}
{"rec_id": "4804", "recitation_code": "view . set scratch ( True )", "input_code_id": 4804, "input": "<s> import os , sys <EOL> from sublime import * <EOL> def get_selection ( view = None ) : <EOL> if not view : <EOL> view = active_window ( ) . active_view ( ) <EOL> return view . sel ( ) <EOL> def set_selection ( view , region ) : <EOL> sel = view . sel ( ) <EOL> sel . clear ( ) <EOL> sel . add ( region ) <EOL> def redraw_view ( view = None ) : <EOL> if not view : <EOL> view = active_window ( ) . active_view ( ) <EOL> pos = view . viewport_position ( ) <EOL> pos = ( pos [ <NUM_LIT:0> ] , pos [ <NUM_LIT:1> ] + <NUM_LIT:1> ) <EOL> view . set_viewport_position ( pos ) <EOL> pos = ( pos [ <NUM_LIT:0> ] , pos [ <NUM_LIT:1> ] - <NUM_LIT:1> ) <EOL> view . set_viewport_position ( pos ) <EOL> def select_line ( view , line ) : <EOL> pt = view . text_point ( line - <NUM_LIT:1> , <NUM_LIT:0> ) <EOL> ln = view . line ( pt ) <EOL> sel = view . sel ( ) <EOL> sel . clear ( ) <EOL> sel . add ( ln ) <EOL> view . show_at_center ( ln ) <EOL> def select_all ( view ) : <EOL> size = view . size ( ) <EOL> sel = view . sel ( ) <EOL> sel . clear ( ) <EOL> sel . add ( Region ( <NUM_LIT:0> , size ) ) <EOL> def get_view_text ( view ) : <EOL> region = Region ( <NUM_LIT:0> , view . size ( ) ) <EOL> return view . substr ( region ) <EOL> def set_view_text ( view , text ) : <EOL> if not isinstance ( text , unicode ) : <EOL> text = unicode ( text ) <EOL>"}
{"rec_id": "4804", "recitation_code": "view . set scratch ( True )", "input_code_id": 33496, "input": "<s> import re <EOL> from . browser_integration import * <EOL> get_css_hrefs_js = \"\"\"<STR_LIT>\"\"\" <EOL> get_embedded_css_text = \"\"\"<STR_LIT>\"\"\" <EOL> class BrowserIntegrationStylesheetsCommand ( sublime_plugin . WindowCommand ) : <EOL> plugin_name = \"<STR_LIT>\" <EOL> plugin_description = \"<STR_LIT>\" <EOL> @ staticmethod <EOL> def visible ( ) : <EOL> return browser . connected ( ) <EOL> @ require_browser <EOL> @ async <EOL> def run ( self ) : <EOL> def load_css ( i ) : <EOL> if i >= <NUM_LIT:0> : <EOL> if ( results [ i ] [ <NUM_LIT:0> ] . startswith ( '<STR_LIT>' ) ) : <EOL> text = browser . execute ( get_embedded_css_text % ( i , i ) ) <EOL> name = '<STR_LIT>' % i <EOL> else : <EOL> from urllib . request import urlopen <EOL> from urllib . parse import urlparse <EOL> path = results [ i ] [ <NUM_LIT:1> ] <EOL> url = urlparse ( path ) <EOL> if url . netloc : <EOL> response = urlopen ( results [ i ] [ <NUM_LIT:1> ] ) <EOL> text = response . read ( ) . decode ( '<STR_LIT:utf8>' ) <EOL> name = results [ i ] [ <NUM_LIT:0> ] <EOL> else : <EOL> self . window . open_file ( path , sublime . TRANSIENT ) <EOL> return <EOL> view = sublime . active_window ( ) . new_file ( ) <EOL> view . set_name ( name ) <EOL>"}
{"rec_id": "4888", "recitation_code": "t LPAREN = r ' '", "input_code_id": 4888, "input": "<s> tokens = [ <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> t_PLUS = r'<STR_LIT>' <EOL> t_MINUS = r'<STR_LIT:->' <EOL> t_TIMES = r'<STR_LIT>' <EOL> t_DIVIDE = r'<STR_LIT:/>' <EOL> t_MODULO = r'<STR_LIT:%>' <EOL> t_OR = r'<STR_LIT>' <EOL> t_AND = r'<STR_LIT:&>' <EOL> t_NOT = r'<STR_LIT>' <EOL> t_XOR = r'<STR_LIT>' <EOL> t_LSHIFT = r'<STR_LIT>' <EOL> t_RSHIFT = r'<STR_LIT>' <EOL> t_LOR = r'<STR_LIT>' <EOL> t_LAND = r'<STR_LIT>' <EOL> t_LNOT = r'<STR_LIT:!>' <EOL> t_LT = r'<STR_LIT:<>' <EOL> t_GT = r'<STR_LIT:>>' <EOL> t_LE = r'<STR_LIT>' <EOL> t_GE = r'<STR_LIT>' <EOL> t_EQ = r'<STR_LIT>' <EOL> t_NE = r'<STR_LIT>' <EOL> t_EQUALS = r'<STR_LIT:=>' <EOL>"}
{"rec_id": "4888", "recitation_code": "t LPAREN = r ' '", "input_code_id": 14015, "input": "<s> tokens = [ <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> t_PLUS = r'<STR_LIT>' <EOL> t_MINUS = r'<STR_LIT:->' <EOL> t_TIMES = r'<STR_LIT>' <EOL> t_DIVIDE = r'<STR_LIT:/>' <EOL> t_MODULO = r'<STR_LIT:%>' <EOL> t_OR = r'<STR_LIT>' <EOL> t_AND = r'<STR_LIT:&>' <EOL> t_NOT = r'<STR_LIT>' <EOL> t_XOR = r'<STR_LIT>' <EOL> t_LSHIFT = r'<STR_LIT>' <EOL> t_RSHIFT = r'<STR_LIT>' <EOL> t_LOR = r'<STR_LIT>' <EOL> t_LAND = r'<STR_LIT>' <EOL> t_LNOT = r'<STR_LIT:!>' <EOL> t_LT = r'<STR_LIT:<>' <EOL> t_GT = r'<STR_LIT:>>' <EOL> t_LE = r'<STR_LIT>' <EOL> t_GE = r'<STR_LIT>' <EOL> t_EQ = r'<STR_LIT>' <EOL> t_NE = r'<STR_LIT>' <EOL> t_EQUALS = r'<STR_LIT:=>' <EOL>"}
{"rec_id": "4986", "recitation_code": "from . . toolkit import toolkit object", "input_code_id": 3242, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import <EOL> from . . ui_traits import Image <EOL> from . . editor_factory import EditorFactory <EOL>"}
{"rec_id": "4986", "recitation_code": "from . . toolkit import toolkit object", "input_code_id": 4986, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import <EOL> from traits . api import Range <EOL> from . . editor_factory import EditorWithListFactory <EOL>"}
{"rec_id": "4999", "recitation_code": "gl . glColor4ub ( 255 , 255 , 255 , 255 )", "input_code_id": 4999, "input": "<s> import pyglet <EOL> class Camera ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , position = None , angle = None , zoom = None , relative = False ) : <EOL> self . position = position <EOL> self . angle = angle <EOL> self . zoom = zoom <EOL> self . relative = relative <EOL> def draw ( self , gl = pyglet . gl ) : <EOL>"}
{"rec_id": "4999", "recitation_code": "gl . glColor4ub ( 255 , 255 , 255 , 255 )", "input_code_id": 6358, "input": "<s> from __future__ import division , print_function , unicode_literals <EOL> import sys <EOL> import os <EOL> sys . path . insert ( <NUM_LIT:0> , os . path . join ( os . path . dirname ( __file__ ) , '<STR_LIT:..>' ) ) <EOL> testinfo = \"<STR_LIT>\" <EOL> tags = \"<STR_LIT>\" <EOL> import pyglet <EOL> import cocos <EOL> from cocos . director import director <EOL> from cocos . actions import * <EOL> from cocos . layer import * <EOL> from pyglet import gl <EOL> class BackgroundLayer ( cocos . layer . Layer ) : <EOL> def __init__ ( self ) : <EOL> super ( BackgroundLayer , self ) . __init__ ( ) <EOL> self . img = pyglet . resource . image ( '<STR_LIT>' ) <EOL> def draw ( self ) : <EOL>"}
{"rec_id": "5143", "recitation_code": "start = timeit . default timer ( )", "input_code_id": 5143, "input": "<s> import gc <EOL> import timeit <EOL> import random <EOL> def measure_best ( repeat , iters , <EOL> common_setup = '<STR_LIT>' , <EOL> common_cleanup = '<STR_LIT>' , <EOL> * funcs ) : <EOL> funcs = list ( funcs ) <EOL> results = dict ( [ ( f , [ ] ) for f in funcs ] ) <EOL> for i in xrange ( repeat ) : <EOL>"}
{"rec_id": "5143", "recitation_code": "start = timeit . default timer ( )", "input_code_id": 36527, "input": "<s> import os <EOL> import copy <EOL> import jsbeautifier <EOL> options = jsbeautifier . default_options ( ) <EOL> options . wrap_line_length = <NUM_LIT> <EOL> data = '<STR_LIT>' <EOL> data_min = '<STR_LIT>' <EOL> def beautifier_test_underscore ( ) : <EOL> jsbeautifier . beautify ( data , options ) <EOL> def beautifier_test_underscore_min ( ) : <EOL> jsbeautifier . beautify ( data_min , options ) <EOL> def report_perf ( fn ) : <EOL> import timeit <EOL>"}
{"rec_id": "5143", "recitation_code": "start = timeit . default timer ( )", "input_code_id": 54173, "input": "<s> __author__ = \"<STR_LIT>\" <EOL> '''<STR_LIT>''' <EOL> import timeit <EOL> import random <EOL> for i in range ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) : <EOL> '''<STR_LIT>''' <EOL>"}
{"rec_id": "5163", "recitation_code": "xml + = self . LeftoverPropertiesToXml ( )", "input_code_id": 5163, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import types <EOL> import urlparse <EOL> from xml . sax import saxutils <EOL> from google . appengine . datastore import datastore_pb <EOL> from google . appengine . api import datastore <EOL> from google . appengine . api import datastore_errors <EOL> from google . appengine . api import datastore_types <EOL> class GdKind ( datastore . Entity ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> HEADER = u\"\"\"<STR_LIT>\"\"\" <EOL> FOOTER = u\"\"\"<STR_LIT>\"\"\" <EOL> _kind_properties = set ( ) <EOL> _contact_properties = set ( ) <EOL> def __init__ ( self , kind , title , kind_properties , contact_properties = [ ] ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> datastore . Entity . __init__ ( self , kind ) <EOL> if not isinstance ( title , types . StringTypes ) : <EOL> raise datastore_errors . BadValueError ( <EOL> '<STR_LIT>' % <EOL> ( title , datastore_types . typename ( title ) ) ) <EOL> self [ '<STR_LIT:title>' ] = title <EOL> self [ '<STR_LIT:content>' ] = '<STR_LIT>' <EOL> self . _contact_properties = set ( contact_properties ) <EOL> assert not self . _contact_properties . intersection ( self . keys ( ) ) <EOL> self . _kind_properties = set ( kind_properties ) - self . _contact_properties <EOL> self . _kind_properties . add ( '<STR_LIT:title>' ) <EOL> self . _kind_properties . add ( '<STR_LIT:content>' ) <EOL> def _KindPropertiesToXml ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> properties = self . _kind_properties . intersection ( set ( self . keys ( ) ) ) <EOL> xml = u'<STR_LIT>' <EOL> for prop in sorted ( properties ) : <EOL> prop_xml = saxutils . quoteattr ( prop ) [ <NUM_LIT:1> : - <NUM_LIT:1> ] <EOL> value = self [ prop ] <EOL> has_toxml = ( hasattr ( value , '<STR_LIT>' ) or <EOL> isinstance ( value , list ) and hasattr ( value [ <NUM_LIT:0> ] , '<STR_LIT>' ) ) <EOL> for val in self . _XmlEscapeValues ( prop ) : <EOL> if has_toxml : <EOL> xml += '<STR_LIT>' % val <EOL> else : <EOL> xml += '<STR_LIT>' % ( prop_xml , val , prop_xml ) <EOL> return xml <EOL> def _ContactPropertiesToXml ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> properties = self . _contact_properties . intersection ( set ( self . keys ( ) ) ) <EOL> xml = u'<STR_LIT>' <EOL> for prop in sorted ( properties ) : <EOL> values = self [ prop ] <EOL> if not isinstance ( values , list ) : <EOL> values = [ values ] <EOL> for value in values : <EOL> assert isinstance ( value , datastore_types . Key ) <EOL> xml += \"\"\"<STR_LIT>\"\"\" % ( self . kind ( ) . lower ( ) , prop , value . ToTagUri ( ) ) <EOL> return xml <EOL> def _LeftoverPropertiesToXml ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> leftovers = set ( self . keys ( ) ) <EOL> leftovers -= self . _kind_properties <EOL> leftovers -= self . _contact_properties <EOL> if leftovers : <EOL> return u'<STR_LIT>' + '<STR_LIT>' . join ( self . _PropertiesToXml ( leftovers ) ) <EOL> else : <EOL> return u'<STR_LIT>' <EOL> def ToXml ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> xml = GdKind . HEADER % self . kind ( ) . lower ( ) <EOL> xml += self . _KindPropertiesToXml ( ) <EOL> xml += self . _ContactPropertiesToXml ( ) <EOL>"}
{"rec_id": "5163", "recitation_code": "xml + = self . LeftoverPropertiesToXml ( )", "input_code_id": 31370, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import types <EOL> import urlparse <EOL> from xml . sax import saxutils <EOL> from google . appengine . datastore import datastore_pb <EOL> from google . appengine . api import datastore <EOL> from google . appengine . api import datastore_errors <EOL> from google . appengine . api import datastore_types <EOL> class GdKind ( datastore . Entity ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> HEADER = u\"\"\"<STR_LIT>\"\"\" <EOL> FOOTER = u\"\"\"<STR_LIT>\"\"\" <EOL> _kind_properties = set ( ) <EOL> _contact_properties = set ( ) <EOL> def __init__ ( self , kind , title , kind_properties , contact_properties = [ ] ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> datastore . Entity . __init__ ( self , kind ) <EOL> if not isinstance ( title , types . StringTypes ) : <EOL> raise datastore_errors . BadValueError ( <EOL> '<STR_LIT>' % <EOL> ( title , datastore_types . typename ( title ) ) ) <EOL> self [ '<STR_LIT:title>' ] = title <EOL> self [ '<STR_LIT:content>' ] = '<STR_LIT>' <EOL> self . _contact_properties = set ( contact_properties ) <EOL> assert not self . _contact_properties . intersection ( self . keys ( ) ) <EOL> self . _kind_properties = set ( kind_properties ) - self . _contact_properties <EOL> self . _kind_properties . add ( '<STR_LIT:title>' ) <EOL> self . _kind_properties . add ( '<STR_LIT:content>' ) <EOL> def _KindPropertiesToXml ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> properties = self . _kind_properties . intersection ( set ( self . keys ( ) ) ) <EOL> xml = u'<STR_LIT>' <EOL> for prop in sorted ( properties ) : <EOL> prop_xml = saxutils . quoteattr ( prop ) [ <NUM_LIT:1> : - <NUM_LIT:1> ] <EOL> value = self [ prop ] <EOL> has_toxml = ( hasattr ( value , '<STR_LIT>' ) or <EOL> isinstance ( value , list ) and hasattr ( value [ <NUM_LIT:0> ] , '<STR_LIT>' ) ) <EOL> for val in self . _XmlEscapeValues ( prop ) : <EOL> if has_toxml : <EOL> xml += '<STR_LIT>' % val <EOL> else : <EOL> xml += '<STR_LIT>' % ( prop_xml , val , prop_xml ) <EOL> return xml <EOL> def _ContactPropertiesToXml ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> properties = self . _contact_properties . intersection ( set ( self . keys ( ) ) ) <EOL> xml = u'<STR_LIT>' <EOL> for prop in sorted ( properties ) : <EOL> values = self [ prop ] <EOL> if not isinstance ( values , list ) : <EOL> values = [ values ] <EOL> for value in values : <EOL> assert isinstance ( value , datastore_types . Key ) <EOL> xml += \"\"\"<STR_LIT>\"\"\" % ( self . kind ( ) . lower ( ) , prop , value . ToTagUri ( ) ) <EOL> return xml <EOL> def _LeftoverPropertiesToXml ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> leftovers = set ( self . keys ( ) ) <EOL> leftovers -= self . _kind_properties <EOL> leftovers -= self . _contact_properties <EOL> if leftovers : <EOL> return u'<STR_LIT>' + '<STR_LIT>' . join ( self . _PropertiesToXml ( leftovers ) ) <EOL> else : <EOL> return u'<STR_LIT>' <EOL> def ToXml ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> xml = GdKind . HEADER % self . kind ( ) . lower ( ) <EOL> xml += self . _KindPropertiesToXml ( ) <EOL> xml += self . _ContactPropertiesToXml ( ) <EOL>"}
{"rec_id": "5189", "recitation_code": "def mkTest ( ) :", "input_code_id": 5189, "input": "<s> from __future__ import absolute_import <EOL> from __future__ import print_function <EOL> import sys <EOL> import os <EOL> sys . path . insert ( <NUM_LIT:0> , os . path . dirname ( os . path . dirname ( os . path . dirname ( os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) ) ) ) ) <EOL> from veriloggen import * <EOL> def mkLed ( ) : <EOL> m = Module ( '<STR_LIT>' ) <EOL> interval = m . Parameter ( '<STR_LIT>' , <NUM_LIT:16> ) <EOL> clk = m . Input ( '<STR_LIT>' ) <EOL> rst = m . Input ( '<STR_LIT>' ) <EOL> led = m . OutputReg ( '<STR_LIT>' , <NUM_LIT:8> , initval = <NUM_LIT:0> ) <EOL> count = m . Reg ( '<STR_LIT:count>' , <NUM_LIT:32> , initval = <NUM_LIT:0> ) <EOL> seq = Seq ( m , '<STR_LIT>' , clk , rst ) <EOL> seq . add ( Systask ( '<STR_LIT>' , '<STR_LIT>' , led , count ) ) <EOL> seq . add ( count ( count + <NUM_LIT:1> ) , cond = count < interval - <NUM_LIT:1> ) <EOL> seq . add ( count ( <NUM_LIT:0> ) , cond = count == interval - <NUM_LIT:1> ) <EOL> seq . add ( led ( led + <NUM_LIT:1> ) , cond = count == interval - <NUM_LIT:1> ) <EOL> seq . make_always ( ) <EOL> return m <EOL>"}
{"rec_id": "5189", "recitation_code": "def mkTest ( ) :", "input_code_id": 32120, "input": "<s> from __future__ import absolute_import <EOL> from __future__ import print_function <EOL> import sys <EOL> import os <EOL> sys . path . insert ( <NUM_LIT:0> , os . path . dirname ( os . path . dirname ( os . path . dirname ( os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) ) ) ) ) <EOL> from veriloggen import * <EOL> def mkLed ( ) : <EOL> m = Module ( '<STR_LIT>' ) <EOL> interval = m . Parameter ( '<STR_LIT>' , <NUM_LIT:16> ) <EOL> clk = m . Input ( '<STR_LIT>' ) <EOL> rst = m . Input ( '<STR_LIT>' ) <EOL> led = m . OutputReg ( '<STR_LIT>' , <NUM_LIT:8> ) <EOL> count = m . Reg ( '<STR_LIT:count>' , <NUM_LIT:32> ) <EOL> seq = Seq ( m , '<STR_LIT>' , clk ) <EOL> seq . add ( Systask ( '<STR_LIT>' , '<STR_LIT>' , led , count ) ) <EOL> seq . add ( count ( count + <NUM_LIT:1> ) , cond = count < interval - <NUM_LIT:1> ) <EOL> seq . add ( count ( <NUM_LIT:0> ) , cond = count == interval - <NUM_LIT:1> ) <EOL> seq . add ( led ( led + <NUM_LIT:1> ) , cond = count == interval - <NUM_LIT:1> ) <EOL> seq . make_always ( ) <EOL> return m <EOL>"}
{"rec_id": "5203", "recitation_code": "for audience segment in response [ ' ' ] :", "input_code_id": 5203, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from googleads import dfp <EOL> def main ( client ) : <EOL> client = dfp . DfpClient . LoadFromStorage ( ) <EOL> audience_segment_service = client . GetService ( <EOL> '<STR_LIT>' , version = '<STR_LIT>' ) <EOL> statement = dfp . FilterStatement ( ) <EOL> while True : <EOL> response = audience_segment_service . getAudienceSegmentsByStatement ( <EOL> statement . ToStatement ( ) ) <EOL> if '<STR_LIT>' in response : <EOL>"}
{"rec_id": "5203", "recitation_code": "for audience segment in response [ ' ' ] :", "input_code_id": 15511, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from googleads import dfp <EOL> def main ( client ) : <EOL> client = dfp . DfpClient . LoadFromStorage ( ) <EOL> audience_segment_service = client . GetService ( <EOL> '<STR_LIT>' , version = '<STR_LIT>' ) <EOL> statement = dfp . FilterStatement ( ) <EOL> while True : <EOL> response = audience_segment_service . getAudienceSegmentsByStatement ( <EOL> statement . ToStatement ( ) ) <EOL> if '<STR_LIT>' in response : <EOL>"}
{"rec_id": "5255", "recitation_code": "if not cuda ndarray . cuda enabled :", "input_code_id": 5255, "input": "<s> from __future__ import absolute_import , print_function , division <EOL> import os <EOL> import shutil <EOL> import unittest <EOL> from tempfile import mkdtemp <EOL> import numpy <EOL> from numpy . testing import assert_allclose <EOL> from nose . plugins . skip import SkipTest <EOL> import theano <EOL> import theano . sandbox . cuda as cuda_ndarray <EOL> from theano . sandbox . cuda . type import CudaNdarrayType <EOL> from theano . sandbox . cuda . var import CudaNdarraySharedVariable <EOL> from theano . sandbox . rng_mrg import MRG_RandomStreams <EOL> from theano . misc . pkl_utils import dump , load , StripPickler <EOL> class T_dump_load ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . origdir = os . getcwd ( ) <EOL> self . tmpdir = mkdtemp ( ) <EOL> os . chdir ( self . tmpdir ) <EOL> def tearDown ( self ) : <EOL> os . chdir ( self . origdir ) <EOL> if self . tmpdir is not None : <EOL> shutil . rmtree ( self . tmpdir ) <EOL> def test_dump_load ( self ) : <EOL> if not cuda_ndarray . cuda_enabled : <EOL> raise SkipTest ( '<STR_LIT>' ) <EOL> x = CudaNdarraySharedVariable ( '<STR_LIT:x>' , CudaNdarrayType ( ( <NUM_LIT:1> , <NUM_LIT:1> ) , name = '<STR_LIT:x>' ) , <EOL> [ [ <NUM_LIT:1> ] ] , False ) <EOL> with open ( '<STR_LIT:test>' , '<STR_LIT:wb>' ) as f : <EOL> dump ( x , f ) <EOL> with open ( '<STR_LIT:test>' , '<STR_LIT:rb>' ) as f : <EOL> x = load ( f ) <EOL> assert x . name == '<STR_LIT:x>' <EOL> assert_allclose ( x . get_value ( ) , [ [ <NUM_LIT:1> ] ] ) <EOL> def test_dump_load_mrg ( self ) : <EOL>"}
{"rec_id": "5255", "recitation_code": "if not cuda ndarray . cuda enabled :", "input_code_id": 18771, "input": "<s> import os <EOL> import shutil <EOL> import unittest <EOL> from tempfile import mkdtemp <EOL> import numpy <EOL> from numpy . testing import assert_allclose <EOL> from nose . plugins . skip import SkipTest <EOL> import theano <EOL> import theano . sandbox . cuda as cuda_ndarray <EOL> from theano . sandbox . cuda . type import CudaNdarrayType <EOL> from theano . sandbox . cuda . var import CudaNdarraySharedVariable <EOL> from theano . sandbox . rng_mrg import MRG_RandomStreams <EOL> from theano . misc . pkl_utils import dump , load , StripPickler <EOL> class T_dump_load ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . origdir = os . getcwd ( ) <EOL> self . tmpdir = mkdtemp ( ) <EOL> os . chdir ( self . tmpdir ) <EOL> def tearDown ( self ) : <EOL> os . chdir ( self . origdir ) <EOL> if self . tmpdir is not None : <EOL> shutil . rmtree ( self . tmpdir ) <EOL> def test_dump_load ( self ) : <EOL> if not cuda_ndarray . cuda_enabled : <EOL> raise SkipTest ( '<STR_LIT>' ) <EOL> x = CudaNdarraySharedVariable ( '<STR_LIT:x>' , CudaNdarrayType ( ( <NUM_LIT:1> , <NUM_LIT:1> ) , name = '<STR_LIT:x>' ) , <EOL> [ [ <NUM_LIT:1> ] ] , False ) <EOL> with open ( '<STR_LIT:test>' , '<STR_LIT:wb>' ) as f : <EOL> dump ( x , f ) <EOL> with open ( '<STR_LIT:test>' , '<STR_LIT:rb>' ) as f : <EOL> x = load ( f ) <EOL> assert x . name == '<STR_LIT:x>' <EOL> assert_allclose ( x . get_value ( ) , [ [ <NUM_LIT:1> ] ] ) <EOL> def test_dump_load_mrg ( self ) : <EOL>"}
{"rec_id": "5293", "recitation_code": "analyzer . generate ( )", "input_code_id": 5293, "input": "<s> from __future__ import absolute_import <EOL> from __future__ import print_function <EOL> import os <EOL> import sys <EOL> from pyverilog . dataflow . dataflow_analyzer import VerilogDataflowAnalyzer <EOL> from pyverilog . dataflow . optimizer import VerilogDataflowOptimizer <EOL> from pyverilog . controlflow . controlflow_analyzer import VerilogControlflowAnalyzer <EOL> codedir = os . path . dirname ( os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) ) + '<STR_LIT>' <EOL> expected = \"\"\"<STR_LIT>\"\"\" <EOL> def test ( ) : <EOL> filelist = [ codedir + '<STR_LIT>' ] <EOL> topmodule = '<STR_LIT>' <EOL> noreorder = False <EOL> nobind = False <EOL> include = None <EOL> define = None <EOL> analyzer = VerilogDataflowAnalyzer ( filelist , topmodule , <EOL> noreorder = noreorder , <EOL> nobind = nobind , <EOL> preprocess_include = include , <EOL> preprocess_define = define ) <EOL>"}
{"rec_id": "5293", "recitation_code": "analyzer . generate ( )", "input_code_id": 1289, "input": "<s> from __future__ import absolute_import <EOL> from __future__ import print_function <EOL> import os <EOL> import sys <EOL> from pyverilog . dataflow . dataflow_analyzer import VerilogDataflowAnalyzer <EOL> from pyverilog . dataflow . optimizer import VerilogDataflowOptimizer <EOL> from pyverilog . controlflow . controlflow_analyzer import VerilogControlflowAnalyzer <EOL> codedir = os . path . dirname ( os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) ) + '<STR_LIT>' <EOL> expected = \"\"\"<STR_LIT>\"\"\" <EOL> def test ( ) : <EOL> filelist = [ codedir + '<STR_LIT>' ] <EOL> topmodule = '<STR_LIT>' <EOL> noreorder = False <EOL> nobind = False <EOL> include = None <EOL> define = None <EOL> analyzer = VerilogDataflowAnalyzer ( filelist , topmodule , <EOL> noreorder = noreorder , <EOL> nobind = nobind , <EOL> preprocess_include = include , <EOL> preprocess_define = define ) <EOL>"}
{"rec_id": "5350", "recitation_code": "def run listing ( self , options ) :", "input_code_id": 5350, "input": "<s> from pip . basecommand import Command <EOL> from pip . exceptions import DistributionNotFound , BestVersionAlreadyInstalled <EOL> from pip . index import PackageFinder <EOL> from pip . log import logger <EOL> from pip . req import InstallRequirement <EOL> from pip . util import get_installed_distributions , dist_is_editable <EOL> from pip . cmdoptions import make_option_group , index_group <EOL> class ListCommand ( Command ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> name = '<STR_LIT:list>' <EOL> usage = \"\"\"<STR_LIT>\"\"\" <EOL> summary = '<STR_LIT>' <EOL> skip = [ '<STR_LIT>' ] <EOL> def __init__ ( self , * args , ** kw ) : <EOL> super ( ListCommand , self ) . __init__ ( * args , ** kw ) <EOL> cmd_opts = self . cmd_opts <EOL> cmd_opts . add_option ( <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> action = '<STR_LIT:store_true>' , <EOL> default = False , <EOL> help = '<STR_LIT>' ) <EOL> cmd_opts . add_option ( <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> action = '<STR_LIT:store_true>' , <EOL> default = False , <EOL> help = '<STR_LIT>' ) <EOL> cmd_opts . add_option ( <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> action = '<STR_LIT:store_true>' , <EOL> default = False , <EOL> help = '<STR_LIT>' ) <EOL> cmd_opts . add_option ( <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> action = '<STR_LIT:store_true>' , <EOL> default = False , <EOL> help = '<STR_LIT>' ) <EOL> cmd_opts . add_option ( <EOL> '<STR_LIT>' , <EOL> action = '<STR_LIT:store_true>' , <EOL> default = False , <EOL> help = \"<STR_LIT>\" ) <EOL> index_opts = make_option_group ( index_group , self . parser ) <EOL> self . parser . insert_option_group ( <NUM_LIT:0> , index_opts ) <EOL> self . parser . insert_option_group ( <NUM_LIT:0> , cmd_opts ) <EOL> def _build_package_finder ( self , options , index_urls , session ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return PackageFinder ( find_links = options . find_links , <EOL> index_urls = index_urls , <EOL> allow_external = options . allow_external , <EOL> allow_unverified = options . allow_unverified , <EOL> allow_all_external = options . allow_all_external , <EOL> allow_all_prereleases = options . pre , <EOL> process_dependency_links = <EOL> options . process_dependency_links , <EOL> session = session , <EOL> ) <EOL> def run ( self , options , args ) : <EOL> if options . outdated : <EOL> self . run_outdated ( options ) <EOL> elif options . uptodate : <EOL> self . run_uptodate ( options ) <EOL> elif options . editable : <EOL> self . run_editables ( options ) <EOL> else : <EOL> self . run_listing ( options ) <EOL>"}
{"rec_id": "5350", "recitation_code": "def run listing ( self , options ) :", "input_code_id": 64119, "input": "<s> from pip . basecommand import Command <EOL> from pip . exceptions import DistributionNotFound , BestVersionAlreadyInstalled <EOL> from pip . index import PackageFinder <EOL> from pip . log import logger <EOL> from pip . req import InstallRequirement <EOL> from pip . util import get_installed_distributions , dist_is_editable <EOL> from pip . cmdoptions import make_option_group , index_group <EOL> class ListCommand ( Command ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> name = '<STR_LIT:list>' <EOL> usage = \"\"\"<STR_LIT>\"\"\" <EOL> summary = '<STR_LIT>' <EOL> def __init__ ( self , * args , ** kw ) : <EOL> super ( ListCommand , self ) . __init__ ( * args , ** kw ) <EOL> cmd_opts = self . cmd_opts <EOL> cmd_opts . add_option ( <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> action = '<STR_LIT:store_true>' , <EOL> default = False , <EOL> help = '<STR_LIT>' ) <EOL> cmd_opts . add_option ( <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> action = '<STR_LIT:store_true>' , <EOL> default = False , <EOL> help = '<STR_LIT>' ) <EOL> cmd_opts . add_option ( <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> action = '<STR_LIT:store_true>' , <EOL> default = False , <EOL> help = '<STR_LIT>' ) <EOL> cmd_opts . add_option ( <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> action = '<STR_LIT:store_true>' , <EOL> default = False , <EOL> help = '<STR_LIT>' ) <EOL> index_opts = make_option_group ( index_group , self . parser ) <EOL> self . parser . insert_option_group ( <NUM_LIT:0> , index_opts ) <EOL> self . parser . insert_option_group ( <NUM_LIT:0> , cmd_opts ) <EOL> def _build_package_finder ( self , options , index_urls ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return PackageFinder ( find_links = options . find_links , <EOL> index_urls = index_urls , <EOL> use_mirrors = options . use_mirrors , <EOL> mirrors = options . mirrors ) <EOL> def run ( self , options , args ) : <EOL> if options . outdated : <EOL> self . run_outdated ( options ) <EOL> elif options . uptodate : <EOL> self . run_uptodate ( options ) <EOL> elif options . editable : <EOL> self . run_editables ( options ) <EOL> else : <EOL> self . run_listing ( options ) <EOL>"}
{"rec_id": "5367", "recitation_code": "pointer = nhist", "input_code_id": 5367, "input": "<s> from . configHandler import idleConf <EOL> class History : <EOL> def __init__ ( self , text , output_sep = \"<STR_LIT:\\n>\" ) : <EOL> self . text = text <EOL> self . history = [ ] <EOL> self . history_prefix = None <EOL> self . history_pointer = None <EOL> self . output_sep = output_sep <EOL> self . cyclic = idleConf . GetOption ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <NUM_LIT:1> , \"<STR_LIT:bool>\" ) <EOL> text . bind ( \"<STR_LIT>\" , self . history_prev ) <EOL> text . bind ( \"<STR_LIT>\" , self . history_next ) <EOL> def history_next ( self , event ) : <EOL> self . history_do ( <NUM_LIT:0> ) <EOL> return \"<STR_LIT>\" <EOL> def history_prev ( self , event ) : <EOL> self . history_do ( <NUM_LIT:1> ) <EOL> return \"<STR_LIT>\" <EOL> def _get_source ( self , start , end ) : <EOL> lines = self . text . get ( start , end ) . split ( self . output_sep ) <EOL> return \"<STR_LIT:\\n>\" . join ( lines ) <EOL> def _put_source ( self , where , source ) : <EOL> output = self . output_sep . join ( source . split ( \"<STR_LIT:\\n>\" ) ) <EOL> self . text . insert ( where , output ) <EOL> def history_do ( self , reverse ) : <EOL> nhist = len ( self . history ) <EOL> pointer = self . history_pointer <EOL> prefix = self . history_prefix <EOL> if pointer is not None and prefix is not None : <EOL> if self . text . compare ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) or self . _get_source ( \"<STR_LIT>\" , \"<STR_LIT>\" ) != self . history [ pointer ] : <EOL> pointer = prefix = None <EOL> if pointer is None or prefix is None : <EOL> prefix = self . _get_source ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if reverse : <EOL> pointer = nhist <EOL> else : <EOL> if self . cyclic : <EOL> pointer = - <NUM_LIT:1> <EOL> else : <EOL>"}
{"rec_id": "5367", "recitation_code": "pointer = nhist", "input_code_id": 4831, "input": "<s> \"<STR_LIT>\" <EOL> from idlelib . configHandler import idleConf <EOL> class History : <EOL> '''<STR_LIT>''' <EOL> def __init__ ( self , text ) : <EOL> '''<STR_LIT>''' <EOL> self . text = text <EOL> self . history = [ ] <EOL> self . prefix = None <EOL> self . pointer = None <EOL> self . cyclic = idleConf . GetOption ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <NUM_LIT:1> , \"<STR_LIT:bool>\" ) <EOL> text . bind ( \"<STR_LIT>\" , self . history_prev ) <EOL> text . bind ( \"<STR_LIT>\" , self . history_next ) <EOL> def history_next ( self , event ) : <EOL> \"<STR_LIT>\" <EOL> self . fetch ( reverse = False ) <EOL> return \"<STR_LIT>\" <EOL> def history_prev ( self , event ) : <EOL> \"<STR_LIT>\" <EOL> self . fetch ( reverse = True ) <EOL> return \"<STR_LIT>\" <EOL> def fetch ( self , reverse ) : <EOL> '''<STR_LIT>''' <EOL> nhist = len ( self . history ) <EOL> pointer = self . pointer <EOL> prefix = self . prefix <EOL> if pointer is not None and prefix is not None : <EOL> if self . text . compare ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) or self . text . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) != self . history [ pointer ] : <EOL> pointer = prefix = None <EOL> self . text . mark_set ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if pointer is None or prefix is None : <EOL> prefix = self . text . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if reverse : <EOL> pointer = nhist <EOL> else : <EOL> if self . cyclic : <EOL> pointer = - <NUM_LIT:1> <EOL> else : <EOL>"}
{"rec_id": "5367", "recitation_code": "pointer = nhist", "input_code_id": 41495, "input": "<s> from configHandler import idleConf <EOL> class History : <EOL> def __init__ ( self , text , output_sep = \"<STR_LIT:\\n>\" ) : <EOL> self . text = text <EOL> self . history = [ ] <EOL> self . history_prefix = None <EOL> self . history_pointer = None <EOL> self . output_sep = output_sep <EOL> self . cyclic = idleConf . GetOption ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <NUM_LIT:1> , \"<STR_LIT:bool>\" ) <EOL> text . bind ( \"<STR_LIT>\" , self . history_prev ) <EOL> text . bind ( \"<STR_LIT>\" , self . history_next ) <EOL> def history_next ( self , event ) : <EOL> self . history_do ( <NUM_LIT:0> ) <EOL> return \"<STR_LIT>\" <EOL> def history_prev ( self , event ) : <EOL> self . history_do ( <NUM_LIT:1> ) <EOL> return \"<STR_LIT>\" <EOL> def _get_source ( self , start , end ) : <EOL> lines = self . text . get ( start , end ) . split ( self . output_sep ) <EOL> return \"<STR_LIT:\\n>\" . join ( lines ) <EOL> def _put_source ( self , where , source ) : <EOL> output = self . output_sep . join ( source . split ( \"<STR_LIT:\\n>\" ) ) <EOL> self . text . insert ( where , output ) <EOL> def history_do ( self , reverse ) : <EOL> nhist = len ( self . history ) <EOL> pointer = self . history_pointer <EOL> prefix = self . history_prefix <EOL> if pointer is not None and prefix is not None : <EOL> if self . text . compare ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) or self . _get_source ( \"<STR_LIT>\" , \"<STR_LIT>\" ) != self . history [ pointer ] : <EOL> pointer = prefix = None <EOL> if pointer is None or prefix is None : <EOL> prefix = self . _get_source ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if reverse : <EOL> pointer = nhist <EOL> else : <EOL> if self . cyclic : <EOL> pointer = - <NUM_LIT:1> <EOL> else : <EOL>"}
{"rec_id": "5488", "recitation_code": "new node = MinNode ( type = TYPE GROUP )", "input_code_id": 5488, "input": "<s> \"<STR_LIT>\" <EOL> from . import pytree <EOL> from . pgen2 import grammar , token <EOL> from . pygram import pattern_symbols , python_symbols <EOL> syms = pattern_symbols <EOL> pysyms = python_symbols <EOL> tokens = grammar . opmap <EOL> token_labels = token <EOL> TYPE_ANY = - <NUM_LIT:1> <EOL> TYPE_ALTERNATIVES = - <NUM_LIT:2> <EOL> TYPE_GROUP = - <NUM_LIT:3> <EOL> class MinNode ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , type = None , name = None ) : <EOL> self . type = type <EOL> self . name = name <EOL> self . children = [ ] <EOL> self . leaf = False <EOL> self . parent = None <EOL> self . alternatives = [ ] <EOL> self . group = [ ] <EOL> def __repr__ ( self ) : <EOL> return str ( self . type ) + '<STR_LIT:U+0020>' + str ( self . name ) <EOL> def leaf_to_root ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> node = self <EOL> subp = [ ] <EOL> while node : <EOL> if node . type == TYPE_ALTERNATIVES : <EOL> node . alternatives . append ( subp ) <EOL> if len ( node . alternatives ) == len ( node . children ) : <EOL> subp = [ tuple ( node . alternatives ) ] <EOL> node . alternatives = [ ] <EOL> node = node . parent <EOL> continue <EOL> else : <EOL> node = node . parent <EOL> subp = None <EOL> break <EOL> if node . type == TYPE_GROUP : <EOL> node . group . append ( subp ) <EOL> if len ( node . group ) == len ( node . children ) : <EOL> subp = get_characteristic_subpattern ( node . group ) <EOL> node . group = [ ] <EOL> node = node . parent <EOL> continue <EOL> else : <EOL> node = node . parent <EOL> subp = None <EOL> break <EOL> if node . type == token_labels . NAME and node . name : <EOL> subp . append ( node . name ) <EOL> else : <EOL> subp . append ( node . type ) <EOL> node = node . parent <EOL> return subp <EOL> def get_linear_subpattern ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for l in self . leaves ( ) : <EOL> subp = l . leaf_to_root ( ) <EOL> if subp : <EOL> return subp <EOL> def leaves ( self ) : <EOL> \"<STR_LIT>\" <EOL> for child in self . children : <EOL> for x in child . leaves ( ) : <EOL> yield x <EOL> if not self . children : <EOL> yield self <EOL> def reduce_tree ( node , parent = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> new_node = None <EOL> if node . type == syms . Matcher : <EOL> node = node . children [ <NUM_LIT:0> ] <EOL> if node . type == syms . Alternatives : <EOL> if len ( node . children ) <= <NUM_LIT:2> : <EOL> new_node = reduce_tree ( node . children [ <NUM_LIT:0> ] , parent ) <EOL> else : <EOL> new_node = MinNode ( type = TYPE_ALTERNATIVES ) <EOL> for child in node . children : <EOL> if node . children . index ( child ) % <NUM_LIT:2> : <EOL> continue <EOL> reduced = reduce_tree ( child , new_node ) <EOL> if reduced is not None : <EOL> new_node . children . append ( reduced ) <EOL> elif node . type == syms . Alternative : <EOL> if len ( node . children ) > <NUM_LIT:1> : <EOL> new_node = MinNode ( type = TYPE_GROUP ) <EOL> for child in node . children : <EOL> reduced = reduce_tree ( child , new_node ) <EOL> if reduced : <EOL> new_node . children . append ( reduced ) <EOL> if not new_node . children : <EOL> new_node = None <EOL> else : <EOL> new_node = reduce_tree ( node . children [ <NUM_LIT:0> ] , parent ) <EOL> elif node . type == syms . Unit : <EOL> if ( isinstance ( node . children [ <NUM_LIT:0> ] , pytree . Leaf ) and <EOL> node . children [ <NUM_LIT:0> ] . value == '<STR_LIT:(>' ) : <EOL>"}
{"rec_id": "5488", "recitation_code": "new node = MinNode ( type = TYPE GROUP )", "input_code_id": 77577, "input": "<s> \"<STR_LIT>\" <EOL> from . import pytree <EOL> from . pgen2 import grammar , token <EOL> from . pygram import pattern_symbols , python_symbols <EOL> syms = pattern_symbols <EOL> pysyms = python_symbols <EOL> tokens = grammar . opmap <EOL> token_labels = token <EOL> TYPE_ANY = - <NUM_LIT:1> <EOL> TYPE_ALTERNATIVES = - <NUM_LIT:2> <EOL> TYPE_GROUP = - <NUM_LIT:3> <EOL> class MinNode ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , type = None , name = None ) : <EOL> self . type = type <EOL> self . name = name <EOL> self . children = [ ] <EOL> self . leaf = False <EOL> self . parent = None <EOL> self . alternatives = [ ] <EOL> self . group = [ ] <EOL> def __repr__ ( self ) : <EOL> return str ( self . type ) + '<STR_LIT:U+0020>' + str ( self . name ) <EOL> def leaf_to_root ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> node = self <EOL> subp = [ ] <EOL> while node : <EOL> if node . type == TYPE_ALTERNATIVES : <EOL> node . alternatives . append ( subp ) <EOL> if len ( node . alternatives ) == len ( node . children ) : <EOL> subp = [ tuple ( node . alternatives ) ] <EOL> node . alternatives = [ ] <EOL> node = node . parent <EOL> continue <EOL> else : <EOL> node = node . parent <EOL> subp = None <EOL> break <EOL> if node . type == TYPE_GROUP : <EOL> node . group . append ( subp ) <EOL> if len ( node . group ) == len ( node . children ) : <EOL> subp = get_characteristic_subpattern ( node . group ) <EOL> node . group = [ ] <EOL> node = node . parent <EOL> continue <EOL> else : <EOL> node = node . parent <EOL> subp = None <EOL> break <EOL> if node . type == token_labels . NAME and node . name : <EOL> subp . append ( node . name ) <EOL> else : <EOL> subp . append ( node . type ) <EOL> node = node . parent <EOL> return subp <EOL> def get_linear_subpattern ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for l in self . leaves ( ) : <EOL> subp = l . leaf_to_root ( ) <EOL> if subp : <EOL> return subp <EOL> def leaves ( self ) : <EOL> \"<STR_LIT>\" <EOL> for child in self . children : <EOL> for x in child . leaves ( ) : <EOL> yield x <EOL> if not self . children : <EOL> yield self <EOL> def reduce_tree ( node , parent = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> new_node = None <EOL> if node . type == syms . Matcher : <EOL> node = node . children [ <NUM_LIT:0> ] <EOL> if node . type == syms . Alternatives : <EOL> if len ( node . children ) <= <NUM_LIT:2> : <EOL> new_node = reduce_tree ( node . children [ <NUM_LIT:0> ] , parent ) <EOL> else : <EOL> new_node = MinNode ( type = TYPE_ALTERNATIVES ) <EOL> for child in node . children : <EOL> if node . children . index ( child ) % <NUM_LIT:2> : <EOL> continue <EOL> reduced = reduce_tree ( child , new_node ) <EOL> if reduced is not None : <EOL> new_node . children . append ( reduced ) <EOL> elif node . type == syms . Alternative : <EOL> if len ( node . children ) > <NUM_LIT:1> : <EOL> new_node = MinNode ( type = TYPE_GROUP ) <EOL> for child in node . children : <EOL> reduced = reduce_tree ( child , new_node ) <EOL> if reduced : <EOL> new_node . children . append ( reduced ) <EOL> if not new_node . children : <EOL> new_node = None <EOL> else : <EOL> new_node = reduce_tree ( node . children [ <NUM_LIT:0> ] , parent ) <EOL> elif node . type == syms . Unit : <EOL> if ( isinstance ( node . children [ <NUM_LIT:0> ] , pytree . Leaf ) and <EOL> node . children [ <NUM_LIT:0> ] . value == '<STR_LIT:(>' ) : <EOL>"}
{"rec_id": "5545", "recitation_code": "url ( r ' ' , empty view , name = ' ' ) ,", "input_code_id": 5545, "input": "<s> from __future__ import absolute_import <EOL> from django . conf . urls import patterns , url <EOL> from . views import empty_view <EOL> urlpatterns = patterns ( '<STR_LIT>' , <EOL>"}
{"rec_id": "5545", "recitation_code": "url ( r ' ' , empty view , name = ' ' ) ,", "input_code_id": 5757, "input": "<s> from __future__ import absolute_import <EOL> from django . conf . urls import patterns , url <EOL> from . views import empty_view , LazyRedirectView , login_required_view <EOL> urlpatterns = patterns ( '<STR_LIT>' , <EOL>"}
{"rec_id": "5545", "recitation_code": "url ( r ' ' , empty view , name = ' ' ) ,", "input_code_id": 196, "input": "<s> from __future__ import absolute_import <EOL> from django . conf . urls import patterns , url , include <EOL> from . views import empty_view <EOL> urlpatterns = patterns ( '<STR_LIT>' , <EOL>"}
{"rec_id": "5545", "recitation_code": "url ( r ' ' , empty view , name = ' ' ) ,", "input_code_id": 30984, "input": "<s> from django . conf . urls . defaults import * <EOL> from views import empty_view <EOL> urlpatterns = patterns ( '<STR_LIT>' , <EOL>"}
{"rec_id": "5545", "recitation_code": "url ( r ' ' , empty view , name = ' ' ) ,", "input_code_id": 81909, "input": "<s> from __future__ import absolute_import <EOL> from django . conf . urls import patterns , url <EOL> from . views import empty_view <EOL> urlpatterns = patterns ( '<STR_LIT>' , <EOL>"}
{"rec_id": "5671", "recitation_code": "for suggested ad unit in response [ ' ' ] :", "input_code_id": 5671, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from googleads import dfp <EOL> def main ( client ) : <EOL> suggested_ad_unit_service = client . GetService ( <EOL> '<STR_LIT>' , version = '<STR_LIT>' ) <EOL> statement = dfp . FilterStatement ( ) <EOL> while True : <EOL> response = suggested_ad_unit_service . getSuggestedAdUnitsByStatement ( <EOL> statement . ToStatement ( ) ) <EOL> if '<STR_LIT>' in response : <EOL>"}
{"rec_id": "5671", "recitation_code": "for suggested ad unit in response [ ' ' ] :", "input_code_id": 5225, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from googleads import dfp <EOL> def main ( client ) : <EOL> suggested_ad_unit_service = client . GetService ( <EOL> '<STR_LIT>' , version = '<STR_LIT>' ) <EOL> statement = dfp . FilterStatement ( ) <EOL> while True : <EOL> response = suggested_ad_unit_service . getSuggestedAdUnitsByStatement ( <EOL> statement . ToStatement ( ) ) <EOL> if '<STR_LIT>' in response : <EOL>"}
{"rec_id": "5671", "recitation_code": "for suggested ad unit in response [ ' ' ] :", "input_code_id": 86910, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from googleads import dfp <EOL> def main ( client ) : <EOL> suggested_ad_unit_service = client . GetService ( <EOL> '<STR_LIT>' , version = '<STR_LIT>' ) <EOL> statement = dfp . FilterStatement ( ) <EOL> while True : <EOL> response = suggested_ad_unit_service . getSuggestedAdUnitsByStatement ( <EOL> statement . ToStatement ( ) ) <EOL> if '<STR_LIT>' in response : <EOL>"}
{"rec_id": "5757", "recitation_code": "url ( r ' ' , empty view , name = ' ' ) ,", "input_code_id": 5545, "input": "<s> from __future__ import absolute_import <EOL> from django . conf . urls import patterns , url <EOL> from . views import empty_view <EOL> urlpatterns = patterns ( '<STR_LIT>' , <EOL>"}
{"rec_id": "5757", "recitation_code": "url ( r ' ' , empty view , name = ' ' ) ,", "input_code_id": 5757, "input": "<s> from __future__ import absolute_import <EOL> from django . conf . urls import patterns , url <EOL> from . views import empty_view , LazyRedirectView , login_required_view <EOL> urlpatterns = patterns ( '<STR_LIT>' , <EOL>"}
{"rec_id": "5757", "recitation_code": "url ( r ' ' , empty view , name = ' ' ) ,", "input_code_id": 196, "input": "<s> from __future__ import absolute_import <EOL> from django . conf . urls import patterns , url , include <EOL> from . views import empty_view <EOL> urlpatterns = patterns ( '<STR_LIT>' , <EOL>"}
{"rec_id": "5757", "recitation_code": "url ( r ' ' , empty view , name = ' ' ) ,", "input_code_id": 30984, "input": "<s> from django . conf . urls . defaults import * <EOL> from views import empty_view <EOL> urlpatterns = patterns ( '<STR_LIT>' , <EOL>"}
{"rec_id": "5757", "recitation_code": "url ( r ' ' , empty view , name = ' ' ) ,", "input_code_id": 81909, "input": "<s> from __future__ import absolute_import <EOL> from django . conf . urls import patterns , url <EOL> from . views import empty_view <EOL> urlpatterns = patterns ( '<STR_LIT>' , <EOL>"}
{"rec_id": "5844", "recitation_code": "for i in range ( trials ) :", "input_code_id": 5844, "input": "<s> import time <EOL> import numpy as np <EOL> from IPython import parallel <EOL> nlist = list ( map ( int , np . logspace ( <NUM_LIT:2> , <NUM_LIT:9> , <NUM_LIT:16> , base = <NUM_LIT:2> ) ) ) <EOL> nlist2 = list ( map ( int , np . logspace ( <NUM_LIT:2> , <NUM_LIT:8> , <NUM_LIT:15> , base = <NUM_LIT:2> ) ) ) <EOL> tlist = list ( map ( int , np . logspace ( <NUM_LIT:7> , <NUM_LIT> , <NUM_LIT:16> , base = <NUM_LIT:2> ) ) ) <EOL> nt = <NUM_LIT:16> <EOL> def wait ( t = <NUM_LIT:0> ) : <EOL> import time <EOL> time . sleep ( t ) <EOL> def echo ( s = '<STR_LIT>' ) : <EOL> return s <EOL> def time_throughput ( nmessages , t = <NUM_LIT:0> , f = wait ) : <EOL> client = parallel . Client ( ) <EOL> view = client . load_balanced_view ( ) <EOL> if f is echo : <EOL> t = np . random . random ( t / <NUM_LIT:8> ) <EOL> view . apply_sync ( echo , '<STR_LIT>' ) <EOL> client . spin ( ) <EOL> tic = time . time ( ) <EOL> for i in range ( nmessages ) : <EOL> view . apply ( f , t ) <EOL> lap = time . time ( ) <EOL> client . wait ( ) <EOL> toc = time . time ( ) <EOL> return lap - tic , toc - tic <EOL> def do_runs ( nlist , t = <NUM_LIT:0> , f = wait , trials = <NUM_LIT:2> , runner = time_throughput ) : <EOL> A = np . zeros ( ( len ( nlist ) , <NUM_LIT:2> ) ) <EOL>"}
{"rec_id": "5844", "recitation_code": "for i in range ( trials ) :", "input_code_id": 908, "input": "<s> import os <EOL> import errno <EOL> import hashlib <EOL> import tempfile <EOL> import logging <EOL> import unittest <EOL> import config <EOL> try : <EOL> from config import TEST_SQLALCHEMY_DATABASE_URI <EOL> except ImportError : <EOL> raise ValueError ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> config . PERMDIR = os . path . join ( tempfile . gettempdir ( ) , '<STR_LIT>' ) <EOL> config . POLL_INTERVAL = <NUM_LIT:0> <EOL> config . ERU_URL = None <EOL> config . ERU_NETWORK = '<STR_LIT>' <EOL> try : <EOL> os . makedirs ( config . PERMDIR ) <EOL> except OSError as exc : <EOL> if exc . errno == errno . EEXIST and os . path . isdir ( config . PERMDIR ) : <EOL> pass <EOL> import daemonutils . cluster_task <EOL> import daemonutils . auto_balance <EOL> import handlers . base <EOL> import models . base <EOL> import eru_utils <EOL> app = handlers . base . app <EOL> app . debug = True <EOL> app . config [ '<STR_LIT>' ] = TEST_SQLALCHEMY_DATABASE_URI <EOL> models . base . init_db ( app ) <EOL> unittest . TestCase . maxDiff = None <EOL> logging . basicConfig ( <EOL> level = logging . DEBUG , format = '<STR_LIT>' , <EOL> filename = os . path . join ( tempfile . gettempdir ( ) , '<STR_LIT>' ) ) <EOL> def reset_db ( ) : <EOL> models . base . db . session . close ( ) <EOL> models . base . db . drop_all ( ) <EOL> models . base . db . create_all ( ) <EOL> class TestCase ( unittest . TestCase ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> unittest . TestCase . __init__ ( self , * args , ** kwargs ) <EOL> self . app = app <EOL> self . db = models . base . db <EOL> self . eru_client = eru_utils . eru_client = None <EOL> def setUp ( self ) : <EOL> reset_db ( ) <EOL> def replace_eru_client ( self , client = None ) : <EOL> if client is None : <EOL> client = FakeEruClientBase ( ) <EOL> self . eru_client = eru_utils . eru_client = client <EOL> return client <EOL> def run ( self , result = None ) : <EOL> if not ( result and ( result . failures or result . errors ) ) : <EOL> unittest . TestCase . run ( self , result ) <EOL> def exec_all_tasks ( self , trials = <NUM_LIT> ) : <EOL>"}
{"rec_id": "5907", "recitation_code": "self . addImageItem ( root , \" \" )", "input_code_id": 5907, "input": "<s> from pyjamas . ui . Composite import Composite <EOL> from pyjamas . ui . Tree import Tree <EOL> from pyjamas . ui . TreeItem import TreeItem <EOL> class Mailboxes ( Composite ) : <EOL> def __init__ ( self ) : <EOL> Composite . __init__ ( self ) <EOL> self . tree = Tree ( ) <EOL> root = TreeItem ( self . imageItemHTML ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> self . tree . addItem ( root ) <EOL> inboxItem = self . addImageItem ( root , \"<STR_LIT>\" ) <EOL> self . addImageItem ( root , \"<STR_LIT>\" ) <EOL> self . addImageItem ( root , \"<STR_LIT>\" ) <EOL>"}
{"rec_id": "5907", "recitation_code": "self . addImageItem ( root , \" \" )", "input_code_id": 53010, "input": "<s> from pyjamas . ui . Composite import Composite <EOL> from pyjamas . ui . Tree import Tree <EOL> from pyjamas . ui . TreeItem import TreeItem <EOL> class Mailboxes ( Composite ) : <EOL> def __init__ ( self ) : <EOL> Composite . __init__ ( self ) <EOL> self . tree = Tree ( ) <EOL> root = TreeItem ( self . imageItemHTML ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> self . tree . addItem ( root ) <EOL> inboxItem = self . addImageItem ( root , \"<STR_LIT>\" ) <EOL> self . addImageItem ( root , \"<STR_LIT>\" ) <EOL> self . addImageItem ( root , \"<STR_LIT>\" ) <EOL>"}
{"rec_id": "6242", "recitation_code": "config = super ( NullHandler , self ) . get default config help ( )", "input_code_id": 6242, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from Handler import Handler <EOL> class NullHandler ( Handler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def process ( self , metric ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . log . debug ( \"<STR_LIT>\" , str ( metric ) . rstrip ( ) . replace ( '<STR_LIT:U+0020>' , '<STR_LIT:\\t>' ) ) <EOL> def get_default_config_help ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>"}
{"rec_id": "6242", "recitation_code": "config = super ( NullHandler , self ) . get default config help ( )", "input_code_id": 61649, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from Handler import Handler <EOL> class NullHandler ( Handler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def process ( self , metric ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . log . debug ( \"<STR_LIT>\" , str ( metric ) . rstrip ( ) . replace ( '<STR_LIT:U+0020>' , '<STR_LIT:\\t>' ) ) <EOL> def get_default_config_help ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>"}
{"rec_id": "6356", "recitation_code": "assert ( ' ' = = modules . process query ( ' ' ) [ 0 ] )", "input_code_id": 6356, "input": "<s> import modules <EOL> def test_movie ( ) : <EOL> assert ( '<STR_LIT>' == modules . process_query ( '<STR_LIT>' ) [ <NUM_LIT:0> ] ) <EOL>"}
{"rec_id": "6356", "recitation_code": "assert ( ' ' = = modules . process query ( ' ' ) [ 0 ] )", "input_code_id": 50069, "input": "<s> import modules <EOL> def test_dictionary ( ) : <EOL> assert ( '<STR_LIT>' == modules . process_query ( '<STR_LIT>' ) [ <NUM_LIT:0> ] ) <EOL>"}
{"rec_id": "6390", "recitation_code": "for creative set in response [ ' ' ] :", "input_code_id": 6390, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from googleads import dfp <EOL> def main ( client ) : <EOL> creative_set_service = client . GetService ( '<STR_LIT>' , <EOL> version = '<STR_LIT>' ) <EOL> statement = dfp . FilterStatement ( ) <EOL> while True : <EOL> response = creative_set_service . getCreativeSetsByStatement ( <EOL> statement . ToStatement ( ) ) <EOL> if '<STR_LIT>' in response : <EOL>"}
{"rec_id": "6390", "recitation_code": "for creative set in response [ ' ' ] :", "input_code_id": 25718, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from googleads import dfp <EOL> def main ( client ) : <EOL> creative_set_service = client . GetService ( '<STR_LIT>' , <EOL> version = '<STR_LIT>' ) <EOL> statement = dfp . FilterStatement ( ) <EOL> while True : <EOL> response = creative_set_service . getCreativeSetsByStatement ( <EOL> statement . ToStatement ( ) ) <EOL> if '<STR_LIT>' in response : <EOL>"}
{"rec_id": "6390", "recitation_code": "for creative set in response [ ' ' ] :", "input_code_id": 76693, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from googleads import dfp <EOL> def main ( client ) : <EOL> creative_set_service = client . GetService ( '<STR_LIT>' , <EOL> version = '<STR_LIT>' ) <EOL> statement = dfp . FilterStatement ( ) <EOL> while True : <EOL> response = creative_set_service . getCreativeSetsByStatement ( <EOL> statement . ToStatement ( ) ) <EOL> if '<STR_LIT>' in response : <EOL>"}
{"rec_id": "6402", "recitation_code": "mapper . fit ( data )", "input_code_id": 6402, "input": "<s> import km <EOL> data = km . np . genfromtxt ( '<STR_LIT>' , delimiter = '<STR_LIT:U+002C>' ) <EOL> mapper = km . KeplerMapper ( cluster_algorithm = km . cluster . DBSCAN ( eps = <NUM_LIT:0.1> , min_samples = <NUM_LIT:5> ) , nr_cubes = <NUM_LIT:10> , overlap_perc = <NUM_LIT> , verbose = <NUM_LIT:1> ) <EOL>"}
{"rec_id": "6402", "recitation_code": "mapper . fit ( data )", "input_code_id": 1075, "input": "<s> import km <EOL> data = km . np . genfromtxt ( '<STR_LIT>' , delimiter = '<STR_LIT:U+002C>' ) <EOL> mapper = km . KeplerMapper ( cluster_algorithm = km . cluster . DBSCAN ( eps = <NUM_LIT> , min_samples = <NUM_LIT:3> ) , nr_cubes = <NUM_LIT> , link_local = False , overlap_perc = <NUM_LIT> , verbose = <NUM_LIT:1> ) <EOL>"}
{"rec_id": "6499", "recitation_code": "s = cs . servers . get ( 0 )", "input_code_id": 6499, "input": "<s> from cloudservers . backup_schedules import * <EOL> from fakeserver import FakeServer <EOL> from utils import assert_isinstance <EOL> cs = FakeServer ( ) <EOL> def test_get_backup_schedule ( ) : <EOL> s = cs . servers . get ( <NUM_LIT> ) <EOL> b = cs . backup_schedules . get ( server = s ) <EOL> assert_isinstance ( b , BackupSchedule ) <EOL> cs . assert_called ( '<STR_LIT:GET>' , '<STR_LIT>' ) <EOL> b = cs . backup_schedules . get ( server = <NUM_LIT> ) <EOL> assert_isinstance ( b , BackupSchedule ) <EOL> cs . assert_called ( '<STR_LIT:GET>' , '<STR_LIT>' ) <EOL> assert_isinstance ( s . backup_schedule , BackupSchedule ) <EOL> cs . assert_called ( '<STR_LIT:GET>' , '<STR_LIT>' ) <EOL> b = s . backup_schedule . get ( ) <EOL> cs . assert_called ( '<STR_LIT:GET>' , '<STR_LIT>' ) <EOL> def test_create_update_backup_schedule ( ) : <EOL>"}
{"rec_id": "6499", "recitation_code": "s = cs . servers . get ( 0 )", "input_code_id": 46668, "input": "<s> from openstack . compute . backup_schedules import * <EOL> from fakeserver import FakeServer <EOL> from utils import assert_isinstance <EOL> cs = FakeServer ( ) <EOL> def test_get_backup_schedule ( ) : <EOL> s = cs . servers . get ( <NUM_LIT> ) <EOL> b = cs . backup_schedules . get ( server = s ) <EOL> assert_isinstance ( b , BackupSchedule ) <EOL> cs . assert_called ( '<STR_LIT:GET>' , '<STR_LIT>' ) <EOL> b = cs . backup_schedules . get ( server = <NUM_LIT> ) <EOL> assert_isinstance ( b , BackupSchedule ) <EOL> cs . assert_called ( '<STR_LIT:GET>' , '<STR_LIT>' ) <EOL> assert_isinstance ( s . backup_schedule , BackupSchedule ) <EOL> cs . assert_called ( '<STR_LIT:GET>' , '<STR_LIT>' ) <EOL> b = s . backup_schedule . get ( ) <EOL> cs . assert_called ( '<STR_LIT:GET>' , '<STR_LIT>' ) <EOL> def test_create_update_backup_schedule ( ) : <EOL>"}
{"rec_id": "6510", "recitation_code": "def get ImageId ( self ) :", "input_code_id": 6510, "input": "<s> from aliyunsdkcore . request import RpcRequest <EOL> class ModifyImageShareGroupPermissionRequest ( RpcRequest ) : <EOL> def __init__ ( self ) : <EOL> RpcRequest . __init__ ( self , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def get_OwnerId ( self ) : <EOL> return self . get_query_params ( ) . get ( '<STR_LIT>' ) <EOL> def set_OwnerId ( self , OwnerId ) : <EOL> self . add_query_param ( '<STR_LIT>' , OwnerId ) <EOL> def get_ResourceOwnerAccount ( self ) : <EOL> return self . get_query_params ( ) . get ( '<STR_LIT>' ) <EOL> def set_ResourceOwnerAccount ( self , ResourceOwnerAccount ) : <EOL> self . add_query_param ( '<STR_LIT>' , ResourceOwnerAccount ) <EOL> def get_ResourceOwnerId ( self ) : <EOL> return self . get_query_params ( ) . get ( '<STR_LIT>' ) <EOL> def set_ResourceOwnerId ( self , ResourceOwnerId ) : <EOL> self . add_query_param ( '<STR_LIT>' , ResourceOwnerId ) <EOL>"}
{"rec_id": "6510", "recitation_code": "def get ImageId ( self ) :", "input_code_id": 83620, "input": "<s> from aliyunsdkcore . request import RpcRequest <EOL> class ModifyImageAttributeRequest ( RpcRequest ) : <EOL> def __init__ ( self ) : <EOL> RpcRequest . __init__ ( self , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def get_OwnerId ( self ) : <EOL> return self . get_query_params ( ) . get ( '<STR_LIT>' ) <EOL> def set_OwnerId ( self , OwnerId ) : <EOL> self . add_query_param ( '<STR_LIT>' , OwnerId ) <EOL> def get_ResourceOwnerAccount ( self ) : <EOL> return self . get_query_params ( ) . get ( '<STR_LIT>' ) <EOL> def set_ResourceOwnerAccount ( self , ResourceOwnerAccount ) : <EOL> self . add_query_param ( '<STR_LIT>' , ResourceOwnerAccount ) <EOL> def get_ResourceOwnerId ( self ) : <EOL> return self . get_query_params ( ) . get ( '<STR_LIT>' ) <EOL> def set_ResourceOwnerId ( self , ResourceOwnerId ) : <EOL> self . add_query_param ( '<STR_LIT>' , ResourceOwnerId ) <EOL>"}
{"rec_id": "6588", "recitation_code": "develop . run ( self )", "input_code_id": 6588, "input": "<s> import os <EOL> from os import path <EOL> from setuptools import setup <EOL> from subprocess import check_call <EOL> from distutils . command . build import build <EOL> from distutils . dir_util import copy_tree , remove_tree <EOL> from setuptools . command . develop import develop <EOL> def get_submodules_and_fix_paths ( ) : <EOL> if path . exists ( '<STR_LIT>' ) : <EOL> check_call ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> check_call ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> check_call ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> check_call ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> check_call ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , shell = True ) <EOL> dst = \"<STR_LIT>\" <EOL> src = \"<STR_LIT>\" <EOL> copy_tree ( src , dst ) <EOL> remove_tree ( src ) <EOL> class build_with_submodules ( build ) : <EOL> def run ( self ) : <EOL> get_submodules_and_fix_paths ( ) <EOL> build . run ( self ) <EOL> class develop_with_submodules ( develop ) : <EOL> def run ( self ) : <EOL> get_submodules_and_fix_paths ( ) <EOL>"}
{"rec_id": "6588", "recitation_code": "develop . run ( self )", "input_code_id": 70819, "input": "<s> from os import path <EOL> from setuptools import setup <EOL> from subprocess import check_call <EOL> from distutils . command . build import build <EOL> from setuptools . command . develop import develop <EOL> def get_submodules ( ) : <EOL> if path . exists ( '<STR_LIT>' ) : <EOL> check_call ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> check_call ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> check_call ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> check_call ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> class build_with_submodules ( build ) : <EOL> def run ( self ) : <EOL> get_submodules ( ) <EOL> build . run ( self ) <EOL> class develop_with_submodules ( develop ) : <EOL> def run ( self ) : <EOL> get_submodules ( ) <EOL>"}
{"rec_id": "6834", "recitation_code": "create args . update ( args )", "input_code_id": 6834, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> import simplejson as json <EOL> except ImportError : <EOL> import json <EOL> from bigml . resourcehandler import ResourceHandler <EOL> from bigml . resourcehandler import ( check_resource_type , <EOL> get_sample_id , get_resource_type , <EOL> get_dataset_id , check_resource ) <EOL> from bigml . constants import ( SAMPLE_PATH , DATASET_PATH , <EOL> TINY_RESOURCE ) <EOL> class SampleHandler ( ResourceHandler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . sample_url = self . url + SAMPLE_PATH <EOL> def create_sample ( self , dataset , args = None , wait_time = <NUM_LIT:3> , retries = <NUM_LIT:10> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> dataset_id = None <EOL> resource_type = get_resource_type ( dataset ) <EOL> if resource_type == DATASET_PATH : <EOL> dataset_id = get_dataset_id ( dataset ) <EOL> check_resource ( dataset_id , <EOL> query_string = TINY_RESOURCE , <EOL> wait_time = wait_time , retries = retries , <EOL> raise_on_error = True , api = self ) <EOL> else : <EOL> raise Exception ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % resource_type ) <EOL> create_args = { } <EOL> if args is not None : <EOL>"}
{"rec_id": "6834", "recitation_code": "create args . update ( args )", "input_code_id": 43999, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> import simplejson as json <EOL> except ImportError : <EOL> import json <EOL> from bigml . resourcehandler import ResourceHandler <EOL> from bigml . resourcehandler import ( check_resource_type , <EOL> get_correlation_id , get_resource_type , <EOL> get_dataset_id , check_resource ) <EOL> from bigml . constants import ( CORRELATION_PATH , DATASET_PATH , <EOL> TINY_RESOURCE ) <EOL> class CorrelationHandler ( ResourceHandler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . correlation_url = self . url + CORRELATION_PATH <EOL> def create_correlation ( self , dataset , args = None , wait_time = <NUM_LIT:3> , retries = <NUM_LIT:10> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> dataset_id = None <EOL> resource_type = get_resource_type ( dataset ) <EOL> if resource_type == DATASET_PATH : <EOL> dataset_id = get_dataset_id ( dataset ) <EOL> check_resource ( dataset_id , <EOL> query_string = TINY_RESOURCE , <EOL> wait_time = wait_time , retries = retries , <EOL> raise_on_error = True , api = self ) <EOL> else : <EOL> raise Exception ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % resource_type ) <EOL> create_args = { } <EOL> if args is not None : <EOL>"}
{"rec_id": "6858", "recitation_code": "fetch ( \" \" , fail ok = True )", "input_code_id": 6858, "input": "<s> from __future__ import absolute_import , division , print_function , with_statement <EOL> import logging <EOL> import os <EOL> import signal <EOL> import subprocess <EOL> import sys <EOL> from tornado . httpclient import HTTPClient , HTTPError <EOL> from tornado . httpserver import HTTPServer <EOL> from tornado . ioloop import IOLoop <EOL> from tornado . log import gen_log <EOL> from tornado . process import fork_processes , task_id , Subprocess <EOL> from tornado . simple_httpclient import SimpleAsyncHTTPClient <EOL> from tornado . testing import bind_unused_port , ExpectLog , AsyncTestCase <EOL> from tornado . test . util import unittest , skipIfNonUnix <EOL> from tornado . web import RequestHandler , Application <EOL> def skip_if_twisted ( ) : <EOL> if IOLoop . configured_class ( ) . __name__ . endswith ( '<STR_LIT>' ) : <EOL> raise unittest . SkipTest ( \"<STR_LIT>\" ) <EOL> @ skipIfNonUnix <EOL> class ProcessTest ( unittest . TestCase ) : <EOL> def get_app ( self ) : <EOL> class ProcessHandler ( RequestHandler ) : <EOL> def get ( self ) : <EOL> if self . get_argument ( \"<STR_LIT>\" , None ) : <EOL> os . _exit ( int ( self . get_argument ( \"<STR_LIT>\" ) ) ) <EOL> if self . get_argument ( \"<STR_LIT>\" , None ) : <EOL> os . kill ( os . getpid ( ) , <EOL> int ( self . get_argument ( \"<STR_LIT>\" ) ) ) <EOL> self . write ( str ( os . getpid ( ) ) ) <EOL> return Application ( [ ( \"<STR_LIT:/>\" , ProcessHandler ) ] ) <EOL> def tearDown ( self ) : <EOL> if task_id ( ) is not None : <EOL> logging . error ( \"<STR_LIT>\" ) <EOL> logging . shutdown ( ) <EOL> os . _exit ( <NUM_LIT:1> ) <EOL> signal . alarm ( <NUM_LIT:0> ) <EOL> super ( ProcessTest , self ) . tearDown ( ) <EOL> def test_multi_process ( self ) : <EOL> skip_if_twisted ( ) <EOL> with ExpectLog ( gen_log , \"<STR_LIT>\" ) : <EOL> self . assertFalse ( IOLoop . initialized ( ) ) <EOL> sock , port = bind_unused_port ( ) <EOL> def get_url ( path ) : <EOL> return \"<STR_LIT>\" % ( port , path ) <EOL> signal . alarm ( <NUM_LIT:5> ) <EOL> try : <EOL> id = fork_processes ( <NUM_LIT:3> , max_restarts = <NUM_LIT:3> ) <EOL> self . assertTrue ( id is not None ) <EOL> signal . alarm ( <NUM_LIT:5> ) <EOL> except SystemExit as e : <EOL> self . assertEqual ( e . code , <NUM_LIT:0> ) <EOL> self . assertTrue ( task_id ( ) is None ) <EOL> sock . close ( ) <EOL> return <EOL> try : <EOL> if id in ( <NUM_LIT:0> , <NUM_LIT:1> ) : <EOL> self . assertEqual ( id , task_id ( ) ) <EOL> server = HTTPServer ( self . get_app ( ) ) <EOL> server . add_sockets ( [ sock ] ) <EOL> IOLoop . instance ( ) . start ( ) <EOL> elif id == <NUM_LIT:2> : <EOL> self . assertEqual ( id , task_id ( ) ) <EOL> sock . close ( ) <EOL> client = HTTPClient ( SimpleAsyncHTTPClient ) <EOL> def fetch ( url , fail_ok = False ) : <EOL> try : <EOL> return client . fetch ( get_url ( url ) ) <EOL> except HTTPError as e : <EOL> if not ( fail_ok and e . code == <NUM_LIT> ) : <EOL> raise <EOL> fetch ( \"<STR_LIT>\" , fail_ok = True ) <EOL> fetch ( \"<STR_LIT>\" , fail_ok = True ) <EOL> int ( fetch ( \"<STR_LIT:/>\" ) . body ) <EOL>"}
{"rec_id": "6858", "recitation_code": "fetch ( \" \" , fail ok = True )", "input_code_id": 52385, "input": "<s> from __future__ import absolute_import , division , print_function , with_statement <EOL> import logging <EOL> import os <EOL> import signal <EOL> import subprocess <EOL> import sys <EOL> from tornado . httpclient import HTTPClient , HTTPError <EOL> from tornado . httpserver import HTTPServer <EOL> from tornado . ioloop import IOLoop <EOL> from tornado . log import gen_log <EOL> from tornado . process import fork_processes , task_id , Subprocess <EOL> from tornado . simple_httpclient import SimpleAsyncHTTPClient <EOL> from tornado . testing import bind_unused_port , ExpectLog , AsyncTestCase <EOL> from tornado . test . util import unittest , skipIfNonUnix <EOL> from tornado . web import RequestHandler , Application <EOL> def skip_if_twisted ( ) : <EOL> if IOLoop . configured_class ( ) . __name__ . endswith ( ( '<STR_LIT>' , <EOL> '<STR_LIT>' ) ) : <EOL> raise unittest . SkipTest ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> @ skipIfNonUnix <EOL> class ProcessTest ( unittest . TestCase ) : <EOL> def get_app ( self ) : <EOL> class ProcessHandler ( RequestHandler ) : <EOL> def get ( self ) : <EOL> if self . get_argument ( \"<STR_LIT>\" , None ) : <EOL> os . _exit ( int ( self . get_argument ( \"<STR_LIT>\" ) ) ) <EOL> if self . get_argument ( \"<STR_LIT>\" , None ) : <EOL> os . kill ( os . getpid ( ) , <EOL> int ( self . get_argument ( \"<STR_LIT>\" ) ) ) <EOL> self . write ( str ( os . getpid ( ) ) ) <EOL> return Application ( [ ( \"<STR_LIT:/>\" , ProcessHandler ) ] ) <EOL> def tearDown ( self ) : <EOL> if task_id ( ) is not None : <EOL> logging . error ( \"<STR_LIT>\" ) <EOL> logging . shutdown ( ) <EOL> os . _exit ( <NUM_LIT:1> ) <EOL> signal . alarm ( <NUM_LIT:0> ) <EOL> super ( ProcessTest , self ) . tearDown ( ) <EOL> def test_multi_process ( self ) : <EOL> skip_if_twisted ( ) <EOL> with ExpectLog ( gen_log , \"<STR_LIT>\" ) : <EOL> self . assertFalse ( IOLoop . initialized ( ) ) <EOL> sock , port = bind_unused_port ( ) <EOL> def get_url ( path ) : <EOL> return \"<STR_LIT>\" % ( port , path ) <EOL> signal . alarm ( <NUM_LIT:5> ) <EOL> try : <EOL> id = fork_processes ( <NUM_LIT:3> , max_restarts = <NUM_LIT:3> ) <EOL> self . assertTrue ( id is not None ) <EOL> signal . alarm ( <NUM_LIT:5> ) <EOL> except SystemExit as e : <EOL> self . assertEqual ( e . code , <NUM_LIT:0> ) <EOL> self . assertTrue ( task_id ( ) is None ) <EOL> sock . close ( ) <EOL> return <EOL> try : <EOL> if id in ( <NUM_LIT:0> , <NUM_LIT:1> ) : <EOL> self . assertEqual ( id , task_id ( ) ) <EOL> server = HTTPServer ( self . get_app ( ) ) <EOL> server . add_sockets ( [ sock ] ) <EOL> IOLoop . instance ( ) . start ( ) <EOL> elif id == <NUM_LIT:2> : <EOL> self . assertEqual ( id , task_id ( ) ) <EOL> sock . close ( ) <EOL> client = HTTPClient ( SimpleAsyncHTTPClient ) <EOL> def fetch ( url , fail_ok = False ) : <EOL> try : <EOL> return client . fetch ( get_url ( url ) ) <EOL> except HTTPError as e : <EOL> if not ( fail_ok and e . code == <NUM_LIT> ) : <EOL> raise <EOL> fetch ( \"<STR_LIT>\" , fail_ok = True ) <EOL> fetch ( \"<STR_LIT>\" , fail_ok = True ) <EOL> int ( fetch ( \"<STR_LIT:/>\" ) . body ) <EOL>"}
{"rec_id": "6914", "recitation_code": "versions = factory . get versions ( )", "input_code_id": 6914, "input": "<s> from sahara . plugins . cdh import abstractversionhandler as avh <EOL> from sahara . plugins . cdh import versionfactory as vf <EOL> from sahara . tests . unit import base <EOL> class VersionFactoryTestCase ( base . SaharaTestCase ) : <EOL> def test_get_instance ( self ) : <EOL> self . assertFalse ( vf . VersionFactory . initialized ) <EOL> factory = vf . VersionFactory . get_instance ( ) <EOL> self . assertIsInstance ( factory , vf . VersionFactory ) <EOL> self . assertTrue ( vf . VersionFactory . initialized ) <EOL> def test_get_versions ( self ) : <EOL> factory = vf . VersionFactory . get_instance ( ) <EOL>"}
{"rec_id": "6914", "recitation_code": "versions = factory . get versions ( )", "input_code_id": 28198, "input": "<s> from sahara . plugins . hdp . versions import versionhandlerfactory <EOL> from sahara . tests . unit import base <EOL> class VersionManagerFactoryTest ( base . SaharaTestCase ) : <EOL> def test_get_versions ( self ) : <EOL> factory = versionhandlerfactory . VersionHandlerFactory . get_instance ( ) <EOL> versions = factory . get_versions ( ) <EOL> self . assertEqual ( <NUM_LIT:1> , len ( versions ) ) <EOL>"}
{"rec_id": "6938", "recitation_code": "@ pass logger", "input_code_id": 6938, "input": "<s> import click <EOL> from shpkpr . cli import arguments <EOL> from shpkpr . cli import options <EOL> from shpkpr . cli . entrypoint import CONTEXT_SETTINGS <EOL> from shpkpr . cli . logger import pass_logger <EOL> @ click . group ( '<STR_LIT>' , short_help = '<STR_LIT>' , context_settings = CONTEXT_SETTINGS ) <EOL> @ pass_logger <EOL> def cli ( logger ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ cli . command ( '<STR_LIT:list>' , short_help = '<STR_LIT>' , context_settings = CONTEXT_SETTINGS ) <EOL> @ options . application_id <EOL> @ options . marathon_client <EOL> @ pass_logger <EOL> def list ( logger , marathon_client , application_id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> application = marathon_client . get_application ( application_id ) <EOL> for k , v in sorted ( application [ '<STR_LIT>' ] . items ( ) ) : <EOL> logger . log ( \"<STR_LIT>\" , k , v ) <EOL> @ cli . command ( '<STR_LIT>' , short_help = '<STR_LIT>' , context_settings = CONTEXT_SETTINGS ) <EOL> @ arguments . env_pairs <EOL> @ options . application_id <EOL> @ options . force <EOL> @ options . marathon_client <EOL>"}
{"rec_id": "6938", "recitation_code": "@ pass logger", "input_code_id": 9867, "input": "<s> import click <EOL> from shpkpr . cli import options <EOL> from shpkpr . cli . entrypoint import CONTEXT_SETTINGS <EOL> from shpkpr . cli . logger import pass_logger <EOL> @ click . command ( '<STR_LIT:list>' , short_help = \"<STR_LIT>\" , context_settings = CONTEXT_SETTINGS ) <EOL>"}
{"rec_id": "7066", "recitation_code": "fs = cgi . FieldStorage ( environ = env )", "input_code_id": 7066, "input": "<s> from test . test_support import run_unittest , check_warnings <EOL> import cgi <EOL> import os <EOL> import sys <EOL> import tempfile <EOL> import unittest <EOL> from collections import namedtuple <EOL> class HackedSysModule : <EOL> argv = [ ] <EOL> stdin = sys . stdin <EOL> cgi . sys = HackedSysModule ( ) <EOL> try : <EOL> from cStringIO import StringIO <EOL> except ImportError : <EOL> from StringIO import StringIO <EOL> class ComparableException : <EOL> def __init__ ( self , err ) : <EOL> self . err = err <EOL> def __str__ ( self ) : <EOL> return str ( self . err ) <EOL> def __cmp__ ( self , anExc ) : <EOL> if not isinstance ( anExc , Exception ) : <EOL> return - <NUM_LIT:1> <EOL> x = cmp ( self . err . __class__ , anExc . __class__ ) <EOL> if x != <NUM_LIT:0> : <EOL> return x <EOL> return cmp ( self . err . args , anExc . args ) <EOL> def __getattr__ ( self , attr ) : <EOL> return getattr ( self . err , attr ) <EOL> def do_test ( buf , method ) : <EOL> env = { } <EOL> if method == \"<STR_LIT:GET>\" : <EOL> fp = None <EOL> env [ '<STR_LIT>' ] = '<STR_LIT:GET>' <EOL> env [ '<STR_LIT>' ] = buf <EOL> elif method == \"<STR_LIT:POST>\" : <EOL> fp = StringIO ( buf ) <EOL> env [ '<STR_LIT>' ] = '<STR_LIT:POST>' <EOL> env [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> env [ '<STR_LIT>' ] = str ( len ( buf ) ) <EOL> else : <EOL> raise ValueError , \"<STR_LIT>\" % method <EOL> try : <EOL> return cgi . parse ( fp , env , strict_parsing = <NUM_LIT:1> ) <EOL> except StandardError , err : <EOL> return ComparableException ( err ) <EOL> parse_strict_test_cases = [ <EOL> ( \"<STR_LIT>\" , ValueError ( \"<STR_LIT>\" ) ) , <EOL> ( \"<STR_LIT:&>\" , ValueError ( \"<STR_LIT>\" ) ) , <EOL> ( \"<STR_LIT>\" , ValueError ( \"<STR_LIT>\" ) ) , <EOL> ( \"<STR_LIT:;>\" , ValueError ( \"<STR_LIT>\" ) ) , <EOL> ( \"<STR_LIT>\" , ValueError ( \"<STR_LIT>\" ) ) , <EOL> ( \"<STR_LIT:=>\" , { } ) , <EOL> ( \"<STR_LIT>\" , { } ) , <EOL> ( \"<STR_LIT>\" , { } ) , <EOL> ( \"<STR_LIT>\" , { '<STR_LIT>' : [ '<STR_LIT:a>' ] } ) , <EOL> ( \"<STR_LIT>\" , ValueError ( \"<STR_LIT>\" ) ) , <EOL> ( \"<STR_LIT>\" , ValueError ( \"<STR_LIT>\" ) ) , <EOL> ( \"<STR_LIT>\" , ValueError ( \"<STR_LIT>\" ) ) , <EOL> ( \"<STR_LIT>\" , { '<STR_LIT:b>' : [ '<STR_LIT:a>' ] } ) , <EOL> ( \"<STR_LIT>\" , { '<STR_LIT>' : [ '<STR_LIT:a>' ] } ) , <EOL> ( \"<STR_LIT>\" , { '<STR_LIT:a>' : [ '<STR_LIT>' ] } ) , <EOL> ( \"<STR_LIT>\" , { '<STR_LIT:a>' : [ '<STR_LIT>' ] } ) , <EOL> ( \"<STR_LIT>\" , ValueError ( \"<STR_LIT>\" ) ) , <EOL> ( \"<STR_LIT>\" , ValueError ( \"<STR_LIT>\" ) ) , <EOL> ( \"<STR_LIT>\" , { '<STR_LIT:a>' : [ '<STR_LIT>' ] , '<STR_LIT:b>' : [ '<STR_LIT>' ] } ) , <EOL> ( \"<STR_LIT>\" , { '<STR_LIT:a>' : [ '<STR_LIT>' , '<STR_LIT>' ] } ) , <EOL> ( \"<STR_LIT>\" , { '<STR_LIT:x>' : [ '<STR_LIT:1>' ] , '<STR_LIT:y>' : [ '<STR_LIT>' ] , '<STR_LIT:z>' : [ '<STR_LIT>' ] } ) , <EOL> ( \"<STR_LIT>\" , { '<STR_LIT:x>' : [ '<STR_LIT:1>' ] , '<STR_LIT:y>' : [ '<STR_LIT>' ] , '<STR_LIT:z>' : [ '<STR_LIT>' ] } ) , <EOL> ( \"<STR_LIT>\" , { '<STR_LIT:x>' : [ '<STR_LIT:1>' ] , '<STR_LIT:y>' : [ '<STR_LIT>' ] , '<STR_LIT:z>' : [ '<STR_LIT>' ] } ) , <EOL> ( \"<STR_LIT>\" , <EOL> { '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT:r>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> } ) , <EOL> ( \"<STR_LIT>\" , <EOL> { '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT:100>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT:1>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> } ) <EOL> ] <EOL> def first_elts ( list ) : <EOL> return map ( lambda x : x [ <NUM_LIT:0> ] , list ) <EOL> def first_second_elts ( list ) : <EOL> return map ( lambda p : ( p [ <NUM_LIT:0> ] , p [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] ) , list ) <EOL> def gen_result ( data , environ ) : <EOL> fake_stdin = StringIO ( data ) <EOL> fake_stdin . seek ( <NUM_LIT:0> ) <EOL> form = cgi . FieldStorage ( fp = fake_stdin , environ = environ ) <EOL> result = { } <EOL> for k , v in dict ( form ) . items ( ) : <EOL> result [ k ] = isinstance ( v , list ) and form . getlist ( k ) or v . value <EOL> return result <EOL> class CgiTests ( unittest . TestCase ) : <EOL> def test_escape ( self ) : <EOL> self . assertEqual ( \"<STR_LIT>\" , cgi . escape ( \"<STR_LIT>\" ) ) <EOL> self . assertEqual ( \"<STR_LIT>\" , cgi . escape ( \"<STR_LIT>\" ) ) <EOL> self . assertEqual ( \"<STR_LIT>\" , cgi . escape ( '<STR_LIT>' , True ) ) <EOL> def test_strict ( self ) : <EOL> for orig , expect in parse_strict_test_cases : <EOL> d = do_test ( orig , \"<STR_LIT:GET>\" ) <EOL> self . assertEqual ( d , expect , \"<STR_LIT>\" % repr ( orig ) ) <EOL> d = do_test ( orig , \"<STR_LIT:POST>\" ) <EOL> self . assertEqual ( d , expect , \"<STR_LIT>\" % repr ( orig ) ) <EOL> env = { '<STR_LIT>' : orig } <EOL> fcd = cgi . FormContentDict ( env ) <EOL> sd = cgi . SvFormContentDict ( env ) <EOL> fs = cgi . FieldStorage ( environ = env ) <EOL> if isinstance ( expect , dict ) : <EOL> self . assertEqual ( len ( expect ) , len ( fcd ) ) <EOL> self . assertItemsEqual ( expect . keys ( ) , fcd . keys ( ) ) <EOL> self . assertItemsEqual ( expect . values ( ) , fcd . values ( ) ) <EOL> self . assertItemsEqual ( expect . items ( ) , fcd . items ( ) ) <EOL> self . assertEqual ( fcd . get ( \"<STR_LIT>\" , \"<STR_LIT:default>\" ) , \"<STR_LIT:default>\" ) <EOL> self . assertEqual ( len ( sd ) , len ( fs ) ) <EOL> self . assertItemsEqual ( sd . keys ( ) , fs . keys ( ) ) <EOL> self . assertEqual ( fs . getvalue ( \"<STR_LIT>\" , \"<STR_LIT:default>\" ) , \"<STR_LIT:default>\" ) <EOL> for key in expect . keys ( ) : <EOL> expect_val = expect [ key ] <EOL> self . assertTrue ( fcd . has_key ( key ) ) <EOL> self . assertItemsEqual ( fcd [ key ] , expect [ key ] ) <EOL> self . assertEqual ( fcd . get ( key , \"<STR_LIT:default>\" ) , fcd [ key ] ) <EOL> self . assertTrue ( fs . has_key ( key ) ) <EOL> if len ( expect_val ) > <NUM_LIT:1> : <EOL> single_value = <NUM_LIT:0> <EOL> else : <EOL> single_value = <NUM_LIT:1> <EOL> try : <EOL> val = sd [ key ] <EOL> except IndexError : <EOL> self . assertFalse ( single_value ) <EOL> self . assertEqual ( fs . getvalue ( key ) , expect_val ) <EOL> else : <EOL> self . assertTrue ( single_value ) <EOL> self . assertEqual ( val , expect_val [ <NUM_LIT:0> ] ) <EOL> self . assertEqual ( fs . getvalue ( key ) , expect_val [ <NUM_LIT:0> ] ) <EOL> self . assertItemsEqual ( sd . getlist ( key ) , expect_val ) <EOL> if single_value : <EOL> self . assertItemsEqual ( sd . values ( ) , <EOL> first_elts ( expect . values ( ) ) ) <EOL> self . assertItemsEqual ( sd . items ( ) , <EOL> first_second_elts ( expect . items ( ) ) ) <EOL> def test_weird_formcontentdict ( self ) : <EOL> env = { '<STR_LIT>' : \"<STR_LIT>\" } <EOL> expect = { '<STR_LIT:x>' : <NUM_LIT:1> , '<STR_LIT:y>' : <NUM_LIT> , '<STR_LIT:z>' : '<STR_LIT>' , '<STR_LIT:1>' : '<STR_LIT>' } <EOL> d = cgi . InterpFormContentDict ( env ) <EOL>"}
{"rec_id": "7066", "recitation_code": "fs = cgi . FieldStorage ( environ = env )", "input_code_id": 66080, "input": "<s> from test . test_support import run_unittest , check_warnings <EOL> import cgi <EOL> import os <EOL> import sys <EOL> import tempfile <EOL> import unittest <EOL> from collections import namedtuple <EOL> class HackedSysModule : <EOL> argv = [ ] <EOL> stdin = sys . stdin <EOL> cgi . sys = HackedSysModule ( ) <EOL> try : <EOL> from cStringIO import StringIO <EOL> except ImportError : <EOL> from StringIO import StringIO <EOL> class ComparableException : <EOL> def __init__ ( self , err ) : <EOL> self . err = err <EOL> def __str__ ( self ) : <EOL> return str ( self . err ) <EOL> def __cmp__ ( self , anExc ) : <EOL> if not isinstance ( anExc , Exception ) : <EOL> return - <NUM_LIT:1> <EOL> x = cmp ( self . err . __class__ , anExc . __class__ ) <EOL> if x != <NUM_LIT:0> : <EOL> return x <EOL> return cmp ( self . err . args , anExc . args ) <EOL> def __getattr__ ( self , attr ) : <EOL> return getattr ( self . err , attr ) <EOL> def do_test ( buf , method ) : <EOL> env = { } <EOL> if method == \"<STR_LIT:GET>\" : <EOL> fp = None <EOL> env [ '<STR_LIT>' ] = '<STR_LIT:GET>' <EOL> env [ '<STR_LIT>' ] = buf <EOL> elif method == \"<STR_LIT:POST>\" : <EOL> fp = StringIO ( buf ) <EOL> env [ '<STR_LIT>' ] = '<STR_LIT:POST>' <EOL> env [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> env [ '<STR_LIT>' ] = str ( len ( buf ) ) <EOL> else : <EOL> raise ValueError , \"<STR_LIT>\" % method <EOL> try : <EOL> return cgi . parse ( fp , env , strict_parsing = <NUM_LIT:1> ) <EOL> except StandardError , err : <EOL> return ComparableException ( err ) <EOL> parse_strict_test_cases = [ <EOL> ( \"<STR_LIT>\" , ValueError ( \"<STR_LIT>\" ) ) , <EOL> ( \"<STR_LIT:&>\" , ValueError ( \"<STR_LIT>\" ) ) , <EOL> ( \"<STR_LIT>\" , ValueError ( \"<STR_LIT>\" ) ) , <EOL> ( \"<STR_LIT:;>\" , ValueError ( \"<STR_LIT>\" ) ) , <EOL> ( \"<STR_LIT>\" , ValueError ( \"<STR_LIT>\" ) ) , <EOL> ( \"<STR_LIT:=>\" , { } ) , <EOL> ( \"<STR_LIT>\" , { } ) , <EOL> ( \"<STR_LIT>\" , { } ) , <EOL> ( \"<STR_LIT>\" , { '<STR_LIT>' : [ '<STR_LIT:a>' ] } ) , <EOL> ( \"<STR_LIT>\" , ValueError ( \"<STR_LIT>\" ) ) , <EOL> ( \"<STR_LIT>\" , ValueError ( \"<STR_LIT>\" ) ) , <EOL> ( \"<STR_LIT>\" , ValueError ( \"<STR_LIT>\" ) ) , <EOL> ( \"<STR_LIT>\" , { '<STR_LIT:b>' : [ '<STR_LIT:a>' ] } ) , <EOL> ( \"<STR_LIT>\" , { '<STR_LIT>' : [ '<STR_LIT:a>' ] } ) , <EOL> ( \"<STR_LIT>\" , { '<STR_LIT:a>' : [ '<STR_LIT>' ] } ) , <EOL> ( \"<STR_LIT>\" , { '<STR_LIT:a>' : [ '<STR_LIT>' ] } ) , <EOL> ( \"<STR_LIT>\" , ValueError ( \"<STR_LIT>\" ) ) , <EOL> ( \"<STR_LIT>\" , ValueError ( \"<STR_LIT>\" ) ) , <EOL> ( \"<STR_LIT>\" , { '<STR_LIT:a>' : [ '<STR_LIT>' ] , '<STR_LIT:b>' : [ '<STR_LIT>' ] } ) , <EOL> ( \"<STR_LIT>\" , { '<STR_LIT:a>' : [ '<STR_LIT>' , '<STR_LIT>' ] } ) , <EOL> ( \"<STR_LIT>\" , { '<STR_LIT:x>' : [ '<STR_LIT:1>' ] , '<STR_LIT:y>' : [ '<STR_LIT>' ] , '<STR_LIT:z>' : [ '<STR_LIT>' ] } ) , <EOL> ( \"<STR_LIT>\" , { '<STR_LIT:x>' : [ '<STR_LIT:1>' ] , '<STR_LIT:y>' : [ '<STR_LIT>' ] , '<STR_LIT:z>' : [ '<STR_LIT>' ] } ) , <EOL> ( \"<STR_LIT>\" , { '<STR_LIT:x>' : [ '<STR_LIT:1>' ] , '<STR_LIT:y>' : [ '<STR_LIT>' ] , '<STR_LIT:z>' : [ '<STR_LIT>' ] } ) , <EOL> ( \"<STR_LIT>\" , <EOL> { '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT:r>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> } ) , <EOL> ( \"<STR_LIT>\" , <EOL> { '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT:100>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT:1>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> } ) <EOL> ] <EOL> def first_elts ( list ) : <EOL> return map ( lambda x : x [ <NUM_LIT:0> ] , list ) <EOL> def first_second_elts ( list ) : <EOL> return map ( lambda p : ( p [ <NUM_LIT:0> ] , p [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] ) , list ) <EOL> def gen_result ( data , environ ) : <EOL> fake_stdin = StringIO ( data ) <EOL> fake_stdin . seek ( <NUM_LIT:0> ) <EOL> form = cgi . FieldStorage ( fp = fake_stdin , environ = environ ) <EOL> result = { } <EOL> for k , v in dict ( form ) . items ( ) : <EOL> result [ k ] = isinstance ( v , list ) and form . getlist ( k ) or v . value <EOL> return result <EOL> class CgiTests ( unittest . TestCase ) : <EOL> def test_escape ( self ) : <EOL> self . assertEqual ( \"<STR_LIT>\" , cgi . escape ( \"<STR_LIT>\" ) ) <EOL> self . assertEqual ( \"<STR_LIT>\" , cgi . escape ( \"<STR_LIT>\" ) ) <EOL> self . assertEqual ( \"<STR_LIT>\" , cgi . escape ( '<STR_LIT>' , True ) ) <EOL> def test_strict ( self ) : <EOL> for orig , expect in parse_strict_test_cases : <EOL> d = do_test ( orig , \"<STR_LIT:GET>\" ) <EOL> self . assertEqual ( d , expect , \"<STR_LIT>\" % repr ( orig ) ) <EOL> d = do_test ( orig , \"<STR_LIT:POST>\" ) <EOL> self . assertEqual ( d , expect , \"<STR_LIT>\" % repr ( orig ) ) <EOL> env = { '<STR_LIT>' : orig } <EOL> fcd = cgi . FormContentDict ( env ) <EOL> sd = cgi . SvFormContentDict ( env ) <EOL> fs = cgi . FieldStorage ( environ = env ) <EOL> if isinstance ( expect , dict ) : <EOL> self . assertEqual ( len ( expect ) , len ( fcd ) ) <EOL> self . assertItemsEqual ( expect . keys ( ) , fcd . keys ( ) ) <EOL> self . assertItemsEqual ( expect . values ( ) , fcd . values ( ) ) <EOL> self . assertItemsEqual ( expect . items ( ) , fcd . items ( ) ) <EOL> self . assertEqual ( fcd . get ( \"<STR_LIT>\" , \"<STR_LIT:default>\" ) , \"<STR_LIT:default>\" ) <EOL> self . assertEqual ( len ( sd ) , len ( fs ) ) <EOL> self . assertItemsEqual ( sd . keys ( ) , fs . keys ( ) ) <EOL> self . assertEqual ( fs . getvalue ( \"<STR_LIT>\" , \"<STR_LIT:default>\" ) , \"<STR_LIT:default>\" ) <EOL> for key in expect . keys ( ) : <EOL> expect_val = expect [ key ] <EOL> self . assertTrue ( fcd . has_key ( key ) ) <EOL> self . assertItemsEqual ( fcd [ key ] , expect [ key ] ) <EOL> self . assertEqual ( fcd . get ( key , \"<STR_LIT:default>\" ) , fcd [ key ] ) <EOL> self . assertTrue ( fs . has_key ( key ) ) <EOL> if len ( expect_val ) > <NUM_LIT:1> : <EOL> single_value = <NUM_LIT:0> <EOL> else : <EOL> single_value = <NUM_LIT:1> <EOL> try : <EOL> val = sd [ key ] <EOL> except IndexError : <EOL> self . assertFalse ( single_value ) <EOL> self . assertEqual ( fs . getvalue ( key ) , expect_val ) <EOL> else : <EOL> self . assertTrue ( single_value ) <EOL> self . assertEqual ( val , expect_val [ <NUM_LIT:0> ] ) <EOL> self . assertEqual ( fs . getvalue ( key ) , expect_val [ <NUM_LIT:0> ] ) <EOL> self . assertItemsEqual ( sd . getlist ( key ) , expect_val ) <EOL> if single_value : <EOL> self . assertItemsEqual ( sd . values ( ) , <EOL> first_elts ( expect . values ( ) ) ) <EOL> self . assertItemsEqual ( sd . items ( ) , <EOL> first_second_elts ( expect . items ( ) ) ) <EOL> def test_weird_formcontentdict ( self ) : <EOL> env = { '<STR_LIT>' : \"<STR_LIT>\" } <EOL> expect = { '<STR_LIT:x>' : <NUM_LIT:1> , '<STR_LIT:y>' : <NUM_LIT> , '<STR_LIT:z>' : '<STR_LIT>' , '<STR_LIT:1>' : '<STR_LIT>' } <EOL> d = cgi . InterpFormContentDict ( env ) <EOL>"}
{"rec_id": "7110", "recitation_code": "test . must contain ( ' ' , ' ' )", "input_code_id": 7110, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> import TestGyp <EOL> test = TestGyp . TestGyp ( ) <EOL> os . environ [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> test . run_gyp ( '<STR_LIT>' ) <EOL> test . build ( '<STR_LIT>' ) <EOL> test . must_contain ( '<STR_LIT>' , '<STR_LIT>' ) <EOL>"}
{"rec_id": "7110", "recitation_code": "test . must contain ( ' ' , ' ' )", "input_code_id": 63019, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import TestGyp <EOL> test = TestGyp . TestGyp ( formats = [ '<STR_LIT>' ] , workdir = '<STR_LIT>' ) <EOL> test . run_gyp ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> test . must_contain ( '<STR_LIT>' , '<STR_LIT>' ) <EOL>"}
{"rec_id": "7153", "recitation_code": "is mobile = True", "input_code_id": 7153, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> class DetectorsHub ( dict ) : <EOL> _known_types = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def __init__ ( self , * args , ** kw ) : <EOL> dict . __init__ ( self , * args , ** kw ) <EOL> for typ in self . _known_types : <EOL> self . setdefault ( typ , [ ] ) <EOL> self . registerDetectors ( ) <EOL> def register ( self , detector ) : <EOL> if detector . info_type not in self . _known_types : <EOL> self [ detector . info_type ] = [ detector ] <EOL> self . _known_types . insert ( detector . order , detector . info_type ) <EOL> else : <EOL> self [ detector . info_type ] . append ( detector ) <EOL> def reorderByPrefs ( self , detectors , prefs ) : <EOL> if prefs is None : <EOL> return [ ] <EOL> elif prefs == [ ] : <EOL> return detectors <EOL> else : <EOL> prefs . insert ( <NUM_LIT:0> , '<STR_LIT>' ) <EOL> def key_name ( d ) : <EOL> return d . name in prefs and prefs . index ( d . name ) or sys . maxint <EOL> return sorted ( detectors , key = key_name ) <EOL> def __iter__ ( self ) : <EOL> return iter ( self . _known_types ) <EOL> def registerDetectors ( self ) : <EOL> detectors = [ v ( ) for v in globals ( ) . values ( ) <EOL> if DetectorBase in getattr ( v , '<STR_LIT>' , [ ] ) ] <EOL> for d in detectors : <EOL> if d . can_register : <EOL> self . register ( d ) <EOL> class DetectorBase ( object ) : <EOL> name = \"<STR_LIT>\" <EOL> info_type = '<STR_LIT>' <EOL> result_key = '<STR_LIT>' <EOL> order = <NUM_LIT:10> <EOL> look_for = [ ] <EOL> skip_if_found = [ ] <EOL> can_register = False <EOL> is_mobile = False <EOL> is_tablet = False <EOL> prefs = dict ( ) <EOL> version_splitters = [ \"<STR_LIT:/>\" , \"<STR_LIT:U+0020>\" ] <EOL> _suggested_detectors = None <EOL> def __init__ ( self ) : <EOL> if not self . name : <EOL> self . name = self . __class__ . __name__ <EOL> self . can_register = ( self . __class__ . __dict__ . get ( '<STR_LIT>' , True ) ) <EOL> def detect ( self , agent , result ) : <EOL> if agent and self . checkWords ( agent ) : <EOL> result [ self . info_type ] = dict ( name = self . name ) <EOL> is_mobile = self . is_mobile <EOL> is_tablet = self . is_tablet <EOL> if is_mobile : <EOL> result [ '<STR_LIT>' ] = is_mobile <EOL> if is_tablet : <EOL> result [ '<STR_LIT>' ] = is_tablet <EOL> version = self . getVersion ( agent ) <EOL> if version : <EOL> result [ self . info_type ] [ '<STR_LIT:version>' ] = version <EOL> return True <EOL> return False <EOL> def checkWords ( self , agent ) : <EOL> for w in self . skip_if_found : <EOL> if w in agent : <EOL> return False <EOL> for w in self . look_for : <EOL> if not w in agent : <EOL> return False <EOL> return True <EOL> def getVersion ( self , agent ) : <EOL> vs = self . version_splitters <EOL> return agent . partition ( self . look_for [ <NUM_LIT:0> ] + vs [ <NUM_LIT:0> ] ) [ <NUM_LIT:2> ] . partition ( vs [ <NUM_LIT:1> ] ) [ <NUM_LIT:0> ] . strip ( ) <EOL> class OS ( DetectorBase ) : <EOL> info_type = \"<STR_LIT>\" <EOL> can_register = False <EOL> version_splitters = [ \"<STR_LIT:;>\" , \"<STR_LIT:U+0020>\" ] <EOL> class Dist ( DetectorBase ) : <EOL> info_type = \"<STR_LIT>\" <EOL> can_register = False <EOL> class Flavor ( DetectorBase ) : <EOL> info_type = \"<STR_LIT>\" <EOL> can_register = False <EOL> class Browser ( DetectorBase ) : <EOL> info_type = \"<STR_LIT>\" <EOL> can_register = False <EOL> class Macintosh ( OS ) : <EOL> look_for = [ '<STR_LIT>' ] <EOL> prefs = dict ( dist = None ) <EOL> def getVersion ( self , agent ) : <EOL> pass <EOL> class Firefox ( Browser ) : <EOL> look_for = [ \"<STR_LIT>\" ] <EOL> class Konqueror ( Browser ) : <EOL> look_for = [ \"<STR_LIT>\" ] <EOL> version_splitters = [ \"<STR_LIT:/>\" , \"<STR_LIT:;>\" ] <EOL> class Opera ( Browser ) : <EOL> look_for = [ \"<STR_LIT>\" ] <EOL> def getVersion ( self , agent ) : <EOL> return agent . partition ( self . look_for [ <NUM_LIT:0> ] ) [ <NUM_LIT:2> ] [ <NUM_LIT:1> : ] . partition ( '<STR_LIT:U+0020>' ) [ <NUM_LIT:0> ] <EOL> class Netscape ( Browser ) : <EOL> look_for = [ \"<STR_LIT>\" ] <EOL> class MSIE ( Browser ) : <EOL> look_for = [ \"<STR_LIT>\" ] <EOL> skip_if_found = [ \"<STR_LIT>\" ] <EOL> name = \"<STR_LIT>\" <EOL> version_splitters = [ \"<STR_LIT:U+0020>\" , \"<STR_LIT:;>\" ] <EOL> class Galeon ( Browser ) : <EOL> look_for = [ \"<STR_LIT>\" ] <EOL> class Safari ( Browser ) : <EOL> look_for = [ \"<STR_LIT>\" ] <EOL> skip_if_found = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , '<STR_LIT>' ] <EOL> def getVersion ( self , agent ) : <EOL> if \"<STR_LIT>\" in agent : <EOL> return agent . partition ( '<STR_LIT>' ) [ <NUM_LIT:2> ] . partition ( '<STR_LIT:U+0020>' ) [ <NUM_LIT:0> ] . strip ( ) <EOL> class SafariTablet ( Browser ) : <EOL> name = \"<STR_LIT>\" <EOL> look_for = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> skip_if_found = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> is_mobile = True <EOL> is_tablet = True <EOL> def getVersion ( self , agent ) : <EOL> if \"<STR_LIT>\" in agent : <EOL> return agent . partition ( '<STR_LIT>' ) [ <NUM_LIT:2> ] . partition ( '<STR_LIT:U+0020>' ) [ <NUM_LIT:0> ] . strip ( ) <EOL> class SafariMobile ( Browser ) : <EOL> name = \"<STR_LIT>\" <EOL> look_for = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> is_mobile = True <EOL> def getVersion ( self , agent ) : <EOL> if \"<STR_LIT>\" in agent : <EOL> return agent . partition ( '<STR_LIT>' ) [ <NUM_LIT:2> ] . partition ( '<STR_LIT:U+0020>' ) [ <NUM_LIT:0> ] . strip ( ) <EOL> class SafariNokia ( Browser ) : <EOL> name = \"<STR_LIT>\" <EOL> look_for = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> is_mobile = True <EOL> def getVersion ( self , agent ) : <EOL> pass <EOL> class SafariiPad ( Browser ) : <EOL> name = \"<STR_LIT>\" <EOL> look_for = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> skip_if_found = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> is_mobile = True <EOL> is_tablet = True <EOL> def getVersion ( self , agent ) : <EOL> if \"<STR_LIT>\" in agent : <EOL> return agent . partition ( '<STR_LIT>' ) [ <NUM_LIT:2> ] . partition ( '<STR_LIT:U+0020>' ) [ <NUM_LIT:0> ] . strip ( ) <EOL> class Linux ( OS ) : <EOL> look_for = [ \"<STR_LIT>\" ] <EOL> prefs = dict ( dist = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , flavor = None ) <EOL> def getVersion ( self , agent ) : <EOL> pass <EOL> class BlackBerry ( OS ) : <EOL> look_for = [ '<STR_LIT>' ] <EOL> prefs = dict ( flavor = [ '<STR_LIT>' ] ) <EOL> is_mobile = True <EOL> def checkWords ( self , agent ) : <EOL> if '<STR_LIT>' in agent or '<STR_LIT>' in agent : <EOL> return True <EOL> return False <EOL> def getVersion ( self , agent ) : <EOL> pass <EOL> class PlayBook ( Flavor ) : <EOL> look_for = [ '<STR_LIT>' ] <EOL> is_mobile = True <EOL> is_tablet = True <EOL> def getVersion ( self , agent ) : <EOL> return agent . partition ( '<STR_LIT>' ) [ <NUM_LIT:2> ] . partition ( '<STR_LIT:;>' ) [ <NUM_LIT:0> ] . strip ( ) <EOL> class Macintosh ( OS ) : <EOL> look_for = [ '<STR_LIT>' ] <EOL> prefs = dict ( dist = None , flavor = [ '<STR_LIT>' ] ) <EOL> def getVersion ( self , agent ) : <EOL> pass <EOL> class MacOS ( Flavor ) : <EOL> look_for = [ '<STR_LIT>' ] <EOL> prefs = dict ( browser = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , \"<STR_LIT>\" ] ) <EOL> def getVersion ( self , agent ) : <EOL> version_end_chars = [ '<STR_LIT:;>' , '<STR_LIT:)>' ] <EOL> part = agent . partition ( '<STR_LIT>' ) [ <NUM_LIT:2> ] . strip ( ) <EOL> for c in version_end_chars : <EOL> if c in part : <EOL> version = part . partition ( c ) [ <NUM_LIT:0> ] <EOL> break <EOL> return version . replace ( '<STR_LIT:_>' , '<STR_LIT:.>' ) <EOL> class Windows ( OS ) : <EOL> look_for = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> prefs = dict ( browser = [ \"<STR_LIT>\" , '<STR_LIT>' ] , <EOL> dist = [ '<STR_LIT>' ] , flavor = None ) <EOL> def getVersion ( self , agent ) : <EOL> v = agent . partition ( '<STR_LIT>' ) <EOL> return v [ <NUM_LIT:1> ] + '<STR_LIT:U+0020>' + v [ <NUM_LIT:2> ] . replace ( '<STR_LIT:)>' , '<STR_LIT:;>' ) . partition ( '<STR_LIT:;>' ) [ <NUM_LIT:0> ] . strip ( ) <EOL> class WindowsMobile ( Dist ) : <EOL> name = '<STR_LIT>' <EOL> look_for = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> is_mobile = True <EOL> def getVersion ( self , agent ) : <EOL> return agent . partition ( '<STR_LIT>' ) [ <NUM_LIT:2> ] . replace ( '<STR_LIT:)>' , '<STR_LIT>' ) . partition ( '<STR_LIT:;>' ) [ <NUM_LIT:0> ] . strip ( ) <EOL> class Ubuntu ( Dist ) : <EOL> look_for = [ '<STR_LIT>' ] <EOL> version_splitters = [ \"<STR_LIT:/>\" , \"<STR_LIT:U+0020>\" ] <EOL> prefs = dict ( browser = [ '<STR_LIT>' ] ) <EOL> class Debian ( Dist ) : <EOL> look_for = [ '<STR_LIT>' ] <EOL> version_splitters = [ \"<STR_LIT:/>\" , \"<STR_LIT:U+0020>\" ] <EOL> prefs = dict ( browser = [ '<STR_LIT>' ] ) <EOL> class Chrome ( Browser ) : <EOL> look_for = [ '<STR_LIT>' ] <EOL>"}
{"rec_id": "7153", "recitation_code": "is mobile = True", "input_code_id": 18026, "input": "<s> import re <EOL> import random <EOL> from types import MethodType <EOL> from django . http import HttpResponseRedirect <EOL> from django . http import SimpleCookie <EOL> from django . http import HttpRequest <EOL> from django . conf import settings <EOL> try : <EOL> from threading import local <EOL> except ImportError : <EOL> from django . utils . _threading_local import local <EOL> THREAD_LOCALS = local ( ) <EOL> def _set_cookie ( self , key , value = '<STR_LIT>' , max_age = None , expires = None , path = '<STR_LIT:/>' , <EOL> domain = None , secure = False ) : <EOL> self . _resp_cookies [ key ] = value <EOL> self . COOKIES [ key ] = value <EOL> if max_age is not None : <EOL> self . _resp_cookies [ key ] [ '<STR_LIT>' ] = max_age <EOL> if expires is not None : <EOL> self . _resp_cookies [ key ] [ '<STR_LIT>' ] = expires <EOL> if path is not None : <EOL> self . _resp_cookies [ key ] [ '<STR_LIT:path>' ] = path <EOL> if domain is not None : <EOL> self . _resp_cookies [ key ] [ '<STR_LIT>' ] = domain <EOL> if secure : <EOL> self . _resp_cookies [ key ] [ '<STR_LIT>' ] = True <EOL> def _delete_cookie ( self , key , path = '<STR_LIT:/>' , domain = None ) : <EOL> self . set_cookie ( key , max_age = <NUM_LIT:0> , path = path , domain = domain , <EOL> expires = '<STR_LIT>' ) <EOL> try : <EOL> del self . COOKIES [ key ] <EOL> except KeyError : <EOL> pass <EOL> IGNORE_AGENTS = getattr ( settings , '<STR_LIT>' , [ ] ) <EOL> USER_AGENTS_TEST_MATCH = ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT:port>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , ) <EOL> USER_AGENTS_TEST_SEARCH = u\"<STR_LIT>\" % u'<STR_LIT:|>' . join ( ( <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , ) ) <EOL> USER_AGENTS_EXCEPTION_SEARCH = u\"<STR_LIT>\" % u'<STR_LIT:|>' . join ( ( '<STR_LIT>' , ) ) <EOL> HTTP_ACCEPT_REGEX = re . compile ( \"<STR_LIT>\" , <EOL> re . IGNORECASE ) <EOL> def is_mobile_agent ( request ) : <EOL> user_agents_test_match = r'<STR_LIT>' % '<STR_LIT:|>' . join ( <EOL> USER_AGENTS_TEST_MATCH ) <EOL> user_agents_test_match_regex = re . compile ( <EOL> user_agents_test_match , re . IGNORECASE ) <EOL> user_agents_test_search_regex = re . compile ( <EOL> USER_AGENTS_TEST_SEARCH , re . IGNORECASE ) <EOL> user_agents_exception_search_regex = re . compile ( <EOL> USER_AGENTS_EXCEPTION_SEARCH , re . IGNORECASE ) <EOL> is_mobile = False <EOL> if '<STR_LIT>' in request . META : <EOL> user_agent = request . META [ '<STR_LIT>' ] <EOL> if user_agents_test_search_regex . search ( user_agent ) and not user_agents_exception_search_regex . search ( user_agent ) : <EOL>"}
{"rec_id": "7199", "recitation_code": "test pred file = \" \"", "input_code_id": 7199, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import numpy as np <EOL> import theano <EOL> import theano . tensor as T <EOL> import lasagne as nn <EOL> import data <EOL> import load <EOL> import nn_plankton <EOL> import dihedral <EOL> import tmp_dnn <EOL> import tta <EOL> batch_size = <NUM_LIT> <EOL> chunk_size = <NUM_LIT> <EOL> num_chunks_train = <NUM_LIT> <EOL> momentum = <NUM_LIT> <EOL> learning_rate_schedule = { <EOL> <NUM_LIT:0> : <NUM_LIT> , <EOL> <NUM_LIT:100> : <NUM_LIT> , <EOL> <NUM_LIT:200> : <NUM_LIT> , <EOL> } <EOL> validate_every = <NUM_LIT> <EOL> save_every = <NUM_LIT> <EOL> sdir = \"<STR_LIT>\" <EOL> train_pred_file = \"<STR_LIT>\" <EOL> valid_pred_file = \"<STR_LIT>\" <EOL>"}
{"rec_id": "7199", "recitation_code": "test pred file = \" \"", "input_code_id": 53937, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import numpy as np <EOL> import theano <EOL> import theano . tensor as T <EOL> import lasagne as nn <EOL> import data <EOL> import load <EOL> import nn_plankton <EOL> import dihedral <EOL> import tmp_dnn <EOL> import tta <EOL> batch_size = <NUM_LIT> <EOL> chunk_size = <NUM_LIT> <EOL> num_chunks_train = <NUM_LIT> <EOL> momentum = <NUM_LIT> <EOL> learning_rate_schedule = { <EOL> <NUM_LIT:0> : <NUM_LIT> , <EOL> <NUM_LIT:100> : <NUM_LIT> , <EOL> <NUM_LIT:200> : <NUM_LIT> , <EOL> } <EOL> validate_every = <NUM_LIT> <EOL> save_every = <NUM_LIT> <EOL> train_pred_file = \"<STR_LIT>\" <EOL> valid_pred_file = \"<STR_LIT>\" <EOL>"}
{"rec_id": "7199", "recitation_code": "test pred file = \" \"", "input_code_id": 64181, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import numpy as np <EOL> import theano <EOL> import theano . tensor as T <EOL> import lasagne as nn <EOL> import data <EOL> import load <EOL> import nn_plankton <EOL> import dihedral <EOL> import tmp_dnn <EOL> import tta <EOL> batch_size = <NUM_LIT> <EOL> chunk_size = <NUM_LIT> <EOL> num_chunks_train = <NUM_LIT> <EOL> momentum = <NUM_LIT> <EOL> learning_rate_schedule = { <EOL> <NUM_LIT:0> : <NUM_LIT> , <EOL> <NUM_LIT:100> : <NUM_LIT> , <EOL> <NUM_LIT:200> : <NUM_LIT> , <EOL> } <EOL> validate_every = <NUM_LIT> <EOL> save_every = <NUM_LIT> <EOL> sdir = \"<STR_LIT>\" <EOL> train_pred_file = \"<STR_LIT>\" <EOL> valid_pred_file = \"<STR_LIT>\" <EOL>"}
{"rec_id": "7233", "recitation_code": "for metric in metrics :", "input_code_id": 7233, "input": "<s> from subprocess import Popen <EOL> from test_common import * <EOL> import urllib . request , urllib . error , urllib . parse , socket , ssl , time , os , signal , json , sys <EOL> if __name__ == \"<STR_LIT:__main__>\" : <EOL> ghostunnel = None <EOL> try : <EOL> root = RootCert ( '<STR_LIT:root>' ) <EOL> root . create_signed_cert ( '<STR_LIT>' ) <EOL> root . create_signed_cert ( '<STR_LIT>' ) <EOL> ghostunnel = run_ghostunnel ( [ '<STR_LIT>' , '<STR_LIT>' . format ( LOCALHOST ) , <EOL> '<STR_LIT>' . format ( LOCALHOST , STATUS_PORT ) , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' . format ( LOCALHOST , STATUS_PORT ) ] ) <EOL> urlopen = lambda path : urllib . request . urlopen ( path , cafile = '<STR_LIT>' ) <EOL> TcpClient ( STATUS_PORT ) . connect ( <NUM_LIT:20> ) <EOL> status = json . loads ( str ( urlopen ( \"<STR_LIT>\" . format ( LOCALHOST , STATUS_PORT ) ) . read ( ) , '<STR_LIT:utf-8>' ) ) <EOL> metrics = json . loads ( str ( urlopen ( \"<STR_LIT>\" . format ( LOCALHOST , STATUS_PORT ) ) . read ( ) , '<STR_LIT:utf-8>' ) ) <EOL>"}
{"rec_id": "7233", "recitation_code": "for metric in metrics :", "input_code_id": 68588, "input": "<s> from __future__ import print_function <EOL> import sys <EOL> import urllib2 <EOL> import base64 <EOL> from . meters import Counter , Histogram , Meter , Timer <EOL> from . registry import MetricsRegistry <EOL> from . reporter import Reporter <EOL> class HostedGraphiteReporter ( Reporter ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( <EOL> self , hosted_graphite_api_key , registry = None , reporting_interval = <NUM_LIT:10> , url = \"<STR_LIT>\" , <EOL> clock = None ) : <EOL> super ( HostedGraphiteReporter , self ) . __init__ ( <EOL> registry , reporting_interval , clock ) <EOL> self . url = url <EOL> self . api_key = hosted_graphite_api_key <EOL> def report_now ( self , registry = None , timestamp = None ) : <EOL> metrics = self . _collect_metrics ( registry or self . registry , timestamp ) <EOL>"}
{"rec_id": "7314", "recitation_code": "@ pl announce ( ' ' )", "input_code_id": 2012, "input": "<s> from spockbot . plugins import default_plugins <EOL> from spockbot . plugins . base import get_settings , pl_announce <EOL> class PloaderFetch ( object ) : <EOL> def __init__ ( self , plugins , plugin_settings ) : <EOL> self . plugins = plugins <EOL> self . plugin_settings = plugin_settings <EOL> def get_plugins ( self ) : <EOL> return self . plugins <EOL> def get_plugin_settings ( self , plugin ) : <EOL> return self . plugin_settings . get ( plugin , { } ) <EOL> @ pl_announce ( '<STR_LIT>' ) <EOL>"}
{"rec_id": "7314", "recitation_code": "@ pl announce ( ' ' )", "input_code_id": 7314, "input": "<s> import logging <EOL> from collections import deque <EOL> from spockbot . plugins . base import pl_announce , PluginBase <EOL> from spockbot . vector import Vector3 <EOL> from bat . command import register_command <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> @ pl_announce ( '<STR_LIT>' ) <EOL> class MovementCommandsPlugin ( PluginBase ) : <EOL> requires = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , ploader , settings ) : <EOL> super ( MovementCommandsPlugin , self ) . __init__ ( ploader , settings ) <EOL> self . commands . register_handlers ( self ) <EOL> ploader . provides ( '<STR_LIT>' , self ) <EOL> self . path_queue = deque ( ) <EOL> self . follow_eid = None <EOL> def on_entity_move ( self , evt , packet ) : <EOL> eid = packet . data [ '<STR_LIT>' ] <EOL> if self . follow_eid and eid == self . follow_eid : <EOL> self . teleport ( Vector3 ( self . entities . entities [ eid ] ) ) <EOL> @ register_command ( '<STR_LIT>' , '<STR_LIT:3>' ) <EOL> def tp_block ( self , coords ) : <EOL> self . teleport ( Vector3 ( * coords ) . ifloor ( ) . iadd ( <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT> ) ) <EOL> @ register_command ( '<STR_LIT>' , '<STR_LIT:3>' ) <EOL> def tp_delta ( self , deltas ) : <EOL> self . teleport ( Vector3 ( * deltas ) . iadd ( self . clientinfo . position ) ) <EOL> @ register_command ( '<STR_LIT>' , '<STR_LIT:3>' ) <EOL> def teleport ( self , coords ) : <EOL> self . clientinfo . position . init ( * coords ) <EOL> @ register_command ( '<STR_LIT>' , '<STR_LIT>' ) <EOL>"}
{"rec_id": "7314", "recitation_code": "@ pl announce ( ' ' )", "input_code_id": 42515, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from spockbot . mcdata . utils import Info <EOL> from spockbot . plugins . base import PluginBase , pl_announce <EOL> class MCEntity ( Info ) : <EOL> eid = <NUM_LIT:0> <EOL> status = <NUM_LIT:0> <EOL> nbt = None <EOL> metadata = None <EOL> class MovementEntity ( MCEntity ) : <EOL> x = <NUM_LIT:0> <EOL> y = <NUM_LIT:0> <EOL> z = <NUM_LIT:0> <EOL> yaw = <NUM_LIT:0> <EOL> pitch = <NUM_LIT:0> <EOL> on_ground = True <EOL> class PlayerEntity ( MovementEntity ) : <EOL> uuid = <NUM_LIT:0> <EOL> current_item = <NUM_LIT:0> <EOL> metadata = None <EOL> class ObjectEntity ( MovementEntity ) : <EOL> obj_type = <NUM_LIT:0> <EOL> obj_data = <NUM_LIT:0> <EOL> speed_x = <NUM_LIT:0> <EOL> speed_y = <NUM_LIT:0> <EOL> speed_z = <NUM_LIT:0> <EOL> class MobEntity ( MovementEntity ) : <EOL> mob_type = <NUM_LIT:0> <EOL> head_pitch = <NUM_LIT:0> <EOL> head_yaw = <NUM_LIT:0> <EOL> velocity_x = <NUM_LIT:0> <EOL> velocity_y = <NUM_LIT:0> <EOL> velocity_z = <NUM_LIT:0> <EOL> metadata = None <EOL> class PaintingEntity ( MCEntity ) : <EOL> title = \"<STR_LIT>\" <EOL> location = { <EOL> '<STR_LIT:x>' : <NUM_LIT:0> , <EOL> '<STR_LIT:y>' : <NUM_LIT:0> , <EOL> '<STR_LIT:z>' : <NUM_LIT:0> , <EOL> } <EOL> direction = <NUM_LIT:0> <EOL> class ExpEntity ( MCEntity ) : <EOL> x = <NUM_LIT:0> <EOL> y = <NUM_LIT:0> <EOL> z = <NUM_LIT:0> <EOL> count = <NUM_LIT:0> <EOL> class GlobalEntity ( MCEntity ) : <EOL> global_type = <NUM_LIT:0> <EOL> x = <NUM_LIT:0> <EOL> y = <NUM_LIT:0> <EOL> z = <NUM_LIT:0> <EOL> class EntitiesCore ( object ) : <EOL> def __init__ ( self ) : <EOL> self . client_player = MCEntity ( ) <EOL> self . entities = { } <EOL> self . players = { } <EOL> self . mobs = { } <EOL> self . objects = { } <EOL> self . paintings = { } <EOL> self . exp_orbs = { } <EOL> self . global_entities = { } <EOL> @ pl_announce ( '<STR_LIT>' ) <EOL> class EntitiesPlugin ( PluginBase ) : <EOL> requires = '<STR_LIT>' <EOL> events = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL>"}
{"rec_id": "7314", "recitation_code": "@ pl announce ( ' ' )", "input_code_id": 52483, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from spockbot . mcdata import constants , windows <EOL> from spockbot . mcdata . windows import make_slot_check <EOL> from spockbot . plugins . base import PluginBase , pl_announce <EOL> from spockbot . plugins . tools . event import EVENT_UNREGISTER <EOL> from spockbot . plugins . tools . inventory_async import InventoryAsync <EOL> class InventoryCore ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , net_plugin , send_click ) : <EOL> self . _net = net_plugin <EOL> self . send_click = send_click <EOL> self . active_slot_nr = <NUM_LIT:0> <EOL> self . cursor_slot = windows . SlotCursor ( ) <EOL> self . window = windows . PlayerWindow ( ) <EOL> self . async = InventoryAsync ( self ) <EOL> def total_stored ( self , wanted , slots = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if slots is None : <EOL> slots = self . window . slots <EOL> wanted = make_slot_check ( wanted ) <EOL> return sum ( slot . amount for slot in slots if wanted ( slot ) ) <EOL> def find_slot ( self , wanted , slots = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for slot in self . find_slots ( wanted , slots ) : <EOL> return slot <EOL> return None <EOL> def find_slots ( self , wanted , slots = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if slots is None : <EOL> slots = self . inv_slots_preferred + self . window . window_slots <EOL> wanted = make_slot_check ( wanted ) <EOL> for slot in slots : <EOL> if wanted ( slot ) : <EOL> yield slot <EOL> def select_active_slot ( self , slot_or_hotbar_index ) : <EOL> if hasattr ( slot_or_hotbar_index , '<STR_LIT>' ) : <EOL> hotbar_start = self . window . hotbar_slots [ <NUM_LIT:0> ] . slot_nr <EOL> slot_or_hotbar_index = slot_or_hotbar_index . slot_nr - hotbar_start <EOL> assert <NUM_LIT:0> <= slot_or_hotbar_index < constants . INV_SLOTS_HOTBAR , '<STR_LIT>' % slot_or_hotbar_index <EOL> if self . active_slot_nr != slot_or_hotbar_index : <EOL> self . active_slot_nr = slot_or_hotbar_index <EOL> self . _net . push_packet ( '<STR_LIT>' , <EOL> { '<STR_LIT>' : slot_or_hotbar_index } ) <EOL> def click_slot ( self , slot , right = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if isinstance ( slot , int ) : <EOL> slot = self . window . slots [ slot ] <EOL> button = constants . INV_BUTTON_RIGHT if right else constants . INV_BUTTON_LEFT <EOL> return self . send_click ( windows . SingleClick ( slot , button ) ) <EOL> def drop_slot ( self , slot = None , drop_stack = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if slot is None : <EOL> if self . cursor_slot . is_empty : <EOL> slot = self . active_slot <EOL> else : <EOL> slot = self . cursor_slot <EOL> elif isinstance ( slot , int ) : <EOL> slot = self . window . slots [ slot ] <EOL> if slot == self . cursor_slot : <EOL> return self . click_slot ( self . cursor_slot , not drop_stack ) <EOL> return self . send_click ( windows . DropClick ( slot , drop_stack ) ) <EOL> def close_window ( self ) : <EOL> self . _net . push_packet ( '<STR_LIT>' , <EOL> { '<STR_LIT>' : self . window . window_id } ) <EOL> def creative_set_slot ( self , slot_nr = None , slot_dict = None , slot = None ) : <EOL> self . _net . push_packet ( '<STR_LIT>' , { <EOL> '<STR_LIT>' : slot_nr or slot . slot_nr , <EOL> '<STR_LIT>' : slot_dict or slot . get_dict ( ) , <EOL> } ) <EOL> @ property <EOL> def active_slot ( self ) : <EOL> return self . window . hotbar_slots [ self . active_slot_nr ] <EOL> @ property <EOL> def inv_slots_preferred ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> slots = [ self . active_slot ] <EOL> slots . extend ( slot for slot in self . window . hotbar_slots <EOL> if slot != self . active_slot ) <EOL> slots . extend ( self . window . inventory_slots ) <EOL> return slots <EOL> @ pl_announce ( '<STR_LIT>' ) <EOL> class InventoryPlugin ( PluginBase ) : <EOL> requires = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> events = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> def __init__ ( self , ploader , settings ) : <EOL> super ( InventoryPlugin , self ) . __init__ ( ploader , settings ) <EOL> self . inventory = InventoryCore ( self . net , self . send_click ) <EOL> ploader . provides ( '<STR_LIT>' , self . inventory ) <EOL> self . action_id = <NUM_LIT:1> <EOL>"}
{"rec_id": "7314", "recitation_code": "@ pl announce ( ' ' )", "input_code_id": 83193, "input": "<s> from spockbot . plugins . base import PluginBase , pl_announce <EOL> from spockbot . plugins . tools . task import Task <EOL> @ pl_announce ( '<STR_LIT>' ) <EOL> class TaskManager ( PluginBase ) : <EOL> requires = '<STR_LIT>' <EOL> def __init__ ( self , ploader , settings ) : <EOL> super ( TaskManager , self ) . __init__ ( ploader , settings ) <EOL>"}
{"rec_id": "7433", "recitation_code": "( self . callstack [ pos ] [ 3 ] , body ) )", "input_code_id": 7433, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import json <EOL> import requests <EOL> import six <EOL> from six . moves . urllib import parse <EOL> from magnumclient . openstack . common . apiclient import client <EOL> def assert_has_keys ( dct , required = None , optional = None ) : <EOL> required = required or [ ] <EOL> optional = optional or [ ] <EOL> for k in required : <EOL> try : <EOL> assert k in dct <EOL> except AssertionError : <EOL> extra_keys = set ( dct . keys ( ) ) . difference ( set ( required + optional ) ) <EOL> raise AssertionError ( \"<STR_LIT>\" % <EOL> list ( extra_keys ) ) <EOL> class TestResponse ( requests . Response ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , data ) : <EOL> super ( TestResponse , self ) . __init__ ( ) <EOL> self . _content_consumed = True <EOL> if isinstance ( data , dict ) : <EOL> self . status_code = data . get ( '<STR_LIT>' , <NUM_LIT:200> ) <EOL> text = data . get ( '<STR_LIT:text>' , \"<STR_LIT>\" ) <EOL> if isinstance ( text , ( dict , list ) ) : <EOL> self . _content = json . dumps ( text ) <EOL> default_headers = { <EOL> \"<STR_LIT:Content-Type>\" : \"<STR_LIT:application/json>\" , <EOL> } <EOL> else : <EOL> self . _content = text <EOL> default_headers = { } <EOL> if six . PY3 and isinstance ( self . _content , six . string_types ) : <EOL> self . _content = self . _content . encode ( '<STR_LIT:utf-8>' , '<STR_LIT:strict>' ) <EOL> self . headers = data . get ( '<STR_LIT>' ) or default_headers <EOL> else : <EOL> self . status_code = data <EOL> def __eq__ ( self , other ) : <EOL> return ( self . status_code == other . status_code and <EOL> self . headers == other . headers and <EOL> self . _content == other . _content ) <EOL> class FakeHTTPClient ( client . HTTPClient ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . callstack = [ ] <EOL> self . fixtures = kwargs . pop ( \"<STR_LIT>\" , None ) or { } <EOL> if not args and \"<STR_LIT>\" not in kwargs : <EOL> args = ( None , ) <EOL> super ( FakeHTTPClient , self ) . __init__ ( * args , ** kwargs ) <EOL> def assert_called ( self , method , url , body = None , pos = - <NUM_LIT:1> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> expected = ( method , url ) <EOL> called = self . callstack [ pos ] [ <NUM_LIT:0> : <NUM_LIT:2> ] <EOL> assert self . callstack , \"<STR_LIT>\" % expected <EOL> assert expected == called , '<STR_LIT>' % ( expected + called ) <EOL> if body is not None : <EOL> if self . callstack [ pos ] [ <NUM_LIT:3> ] != body : <EOL> raise AssertionError ( '<STR_LIT>' % <EOL>"}
{"rec_id": "7433", "recitation_code": "( self . callstack [ pos ] [ 3 ] , body ) )", "input_code_id": 48640, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import json <EOL> import requests <EOL> import six <EOL> from six . moves . urllib import parse <EOL> from rackclient . openstack . common . apiclient import client <EOL> def assert_has_keys ( dct , required = [ ] , optional = [ ] ) : <EOL> for k in required : <EOL> try : <EOL> assert k in dct <EOL> except AssertionError : <EOL> extra_keys = set ( dct . keys ( ) ) . difference ( set ( required + optional ) ) <EOL> raise AssertionError ( \"<STR_LIT>\" % <EOL> list ( extra_keys ) ) <EOL> class TestResponse ( requests . Response ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , data ) : <EOL> super ( TestResponse , self ) . __init__ ( ) <EOL> self . _content_consumed = True <EOL> if isinstance ( data , dict ) : <EOL> self . status_code = data . get ( '<STR_LIT>' , <NUM_LIT:200> ) <EOL> text = data . get ( '<STR_LIT:text>' , \"<STR_LIT>\" ) <EOL> if isinstance ( text , ( dict , list ) ) : <EOL> self . _content = json . dumps ( text ) <EOL> default_headers = { <EOL> \"<STR_LIT:Content-Type>\" : \"<STR_LIT:application/json>\" , <EOL> } <EOL> else : <EOL> self . _content = text <EOL> default_headers = { } <EOL> if six . PY3 and isinstance ( self . _content , six . string_types ) : <EOL> self . _content = self . _content . encode ( '<STR_LIT:utf-8>' , '<STR_LIT:strict>' ) <EOL> self . headers = data . get ( '<STR_LIT>' ) or default_headers <EOL> else : <EOL> self . status_code = data <EOL> def __eq__ ( self , other ) : <EOL> return ( self . status_code == other . status_code and <EOL> self . headers == other . headers and <EOL> self . _content == other . _content ) <EOL> class FakeHTTPClient ( client . HTTPClient ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . callstack = [ ] <EOL> self . fixtures = kwargs . pop ( \"<STR_LIT>\" , None ) or { } <EOL> if not args and \"<STR_LIT>\" not in kwargs : <EOL> args = ( None , ) <EOL> super ( FakeHTTPClient , self ) . __init__ ( * args , ** kwargs ) <EOL> def assert_called ( self , method , url , body = None , pos = - <NUM_LIT:1> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> expected = ( method , url ) <EOL> called = self . callstack [ pos ] [ <NUM_LIT:0> : <NUM_LIT:2> ] <EOL> assert self . callstack , \"<STR_LIT>\" % expected <EOL> assert expected == called , '<STR_LIT>' % ( expected + called ) <EOL> if body is not None : <EOL> if self . callstack [ pos ] [ <NUM_LIT:3> ] != body : <EOL> raise AssertionError ( '<STR_LIT>' % <EOL>"}
{"rec_id": "7555", "recitation_code": "match = re . match ( r ' ' , value )", "input_code_id": 7555, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import <EOL> import re <EOL> import datetime <EOL> from django . contrib . localflavor . no . no_municipalities import MUNICIPALITY_CHOICES <EOL> from django . core . validators import EMPTY_VALUES <EOL> from django . forms import ValidationError <EOL> from django . forms . fields import Field , RegexField , Select <EOL> from django . utils . translation import ugettext_lazy as _ <EOL> class NOZipCodeField ( RegexField ) : <EOL> default_error_messages = { <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> } <EOL> def __init__ ( self , max_length = None , min_length = None , * args , ** kwargs ) : <EOL> super ( NOZipCodeField , self ) . __init__ ( r'<STR_LIT>' , <EOL> max_length , min_length , * args , ** kwargs ) <EOL> class NOMunicipalitySelect ( Select ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , attrs = None ) : <EOL> super ( NOMunicipalitySelect , self ) . __init__ ( attrs , choices = MUNICIPALITY_CHOICES ) <EOL> class NOSocialSecurityNumber ( Field ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> default_error_messages = { <EOL> '<STR_LIT>' : _ ( u'<STR_LIT>' ) , <EOL> } <EOL> def clean ( self , value ) : <EOL> super ( NOSocialSecurityNumber , self ) . clean ( value ) <EOL> if value in EMPTY_VALUES : <EOL> return u'<STR_LIT>' <EOL> if not re . match ( r'<STR_LIT>' , value ) : <EOL> raise ValidationError ( self . error_messages [ '<STR_LIT>' ] ) <EOL>"}
{"rec_id": "7555", "recitation_code": "match = re . match ( r ' ' , value )", "input_code_id": 81921, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import , unicode_literals <EOL> import re <EOL> import datetime <EOL> from django . contrib . localflavor . no . no_municipalities import MUNICIPALITY_CHOICES <EOL> from django . core . validators import EMPTY_VALUES <EOL> from django . forms import ValidationError <EOL> from django . forms . fields import Field , RegexField , Select <EOL> from django . utils . translation import ugettext_lazy as _ <EOL> class NOZipCodeField ( RegexField ) : <EOL> default_error_messages = { <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> } <EOL> def __init__ ( self , max_length = None , min_length = None , * args , ** kwargs ) : <EOL> super ( NOZipCodeField , self ) . __init__ ( r'<STR_LIT>' , <EOL> max_length , min_length , * args , ** kwargs ) <EOL> class NOMunicipalitySelect ( Select ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , attrs = None ) : <EOL> super ( NOMunicipalitySelect , self ) . __init__ ( attrs , choices = MUNICIPALITY_CHOICES ) <EOL> class NOSocialSecurityNumber ( Field ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> default_error_messages = { <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> } <EOL> def clean ( self , value ) : <EOL> super ( NOSocialSecurityNumber , self ) . clean ( value ) <EOL> if value in EMPTY_VALUES : <EOL> return '<STR_LIT>' <EOL> if not re . match ( r'<STR_LIT>' , value ) : <EOL> raise ValidationError ( self . error_messages [ '<STR_LIT>' ] ) <EOL>"}
{"rec_id": "7681", "recitation_code": "def test im func ( self ) :", "input_code_id": 1373, "input": "<s> from test import test_support <EOL> import types <EOL> import unittest <EOL> class FuncAttrsTest ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> class F : <EOL> def a ( self ) : <EOL> pass <EOL> def b ( ) : <EOL> return <NUM_LIT:3> <EOL> self . f = F <EOL> self . fi = F ( ) <EOL> self . b = b <EOL> def cannot_set_attr ( self , obj , name , value , exceptions ) : <EOL> try : <EOL> setattr ( obj , name , value ) <EOL> except exceptions : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" % ( name , value ) ) <EOL> try : <EOL> delattr ( obj , name ) <EOL> except exceptions : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" % name ) <EOL> class FunctionPropertiesTest ( FuncAttrsTest ) : <EOL> def test_module ( self ) : <EOL> self . assertEqual ( self . b . __module__ , __name__ ) <EOL> def test_dir_includes_correct_attrs ( self ) : <EOL> self . b . known_attr = <NUM_LIT:7> <EOL> self . assertIn ( '<STR_LIT>' , dir ( self . b ) , <EOL> \"<STR_LIT>\" ) <EOL> self . f . a . im_func . known_attr = <NUM_LIT:7> <EOL> self . assertIn ( '<STR_LIT>' , dir ( self . f . a ) , <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> self . assertIn ( '<STR_LIT>' , dir ( self . fi . a ) , <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> def test_duplicate_function_equality ( self ) : <EOL> def duplicate ( ) : <EOL> '<STR_LIT>' <EOL> return <NUM_LIT:3> <EOL> self . assertNotEqual ( self . b , duplicate ) <EOL> @ unittest . skipIf ( test_support . is_jython , \"<STR_LIT>\" ) <EOL> def test_copying_func_code ( self ) : <EOL> def test ( ) : pass <EOL> self . assertEqual ( test ( ) , None ) <EOL> test . func_code = self . b . func_code <EOL> self . assertEqual ( test ( ) , <NUM_LIT:3> ) <EOL> @ unittest . skipIf ( test_support . is_jython , \"<STR_LIT>\" ) <EOL> def test_func_globals ( self ) : <EOL> self . assertIs ( self . b . func_globals , globals ( ) ) <EOL> self . cannot_set_attr ( self . b , '<STR_LIT>' , <NUM_LIT:2> , TypeError ) <EOL> @ unittest . skipIf ( test_support . is_jython , \"<STR_LIT>\" ) <EOL> def test_func_closure ( self ) : <EOL> a = <NUM_LIT:12> <EOL> def f ( ) : print a <EOL> c = f . func_closure <EOL> self . assertIsInstance ( c , tuple ) <EOL> self . assertEqual ( len ( c ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( c [ <NUM_LIT:0> ] . __class__ . __name__ , \"<STR_LIT>\" ) <EOL> self . cannot_set_attr ( f , \"<STR_LIT>\" , c , TypeError ) <EOL> def test_empty_cell ( self ) : <EOL> def f ( ) : print a <EOL> try : <EOL> f . func_closure [ <NUM_LIT:0> ] . cell_contents <EOL> except ValueError : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" ) <EOL> a = <NUM_LIT:12> <EOL> @ unittest . skipIf ( test_support . is_jython , \"<STR_LIT>\" ) <EOL> def test_func_name ( self ) : <EOL> self . assertEqual ( self . b . __name__ , '<STR_LIT:b>' ) <EOL> self . assertEqual ( self . b . func_name , '<STR_LIT:b>' ) <EOL> self . b . __name__ = '<STR_LIT:c>' <EOL> self . assertEqual ( self . b . __name__ , '<STR_LIT:c>' ) <EOL> self . assertEqual ( self . b . func_name , '<STR_LIT:c>' ) <EOL> self . b . func_name = '<STR_LIT:d>' <EOL> self . assertEqual ( self . b . __name__ , '<STR_LIT:d>' ) <EOL> self . assertEqual ( self . b . func_name , '<STR_LIT:d>' ) <EOL> self . cannot_set_attr ( self . b , '<STR_LIT>' , <NUM_LIT:7> , TypeError ) <EOL> self . cannot_set_attr ( self . b , '<STR_LIT>' , <NUM_LIT:7> , TypeError ) <EOL> s = \"\"\"<STR_LIT>\"\"\" <EOL> exec s in { '<STR_LIT>' : { } } <EOL> self . assertEqual ( self . f . a . __name__ , '<STR_LIT:a>' ) <EOL> self . assertEqual ( self . fi . a . __name__ , '<STR_LIT:a>' ) <EOL> self . cannot_set_attr ( self . f . a , \"<STR_LIT>\" , '<STR_LIT:a>' , AttributeError ) <EOL> self . cannot_set_attr ( self . fi . a , \"<STR_LIT>\" , '<STR_LIT:a>' , AttributeError ) <EOL> @ unittest . skipIf ( test_support . is_jython , \"<STR_LIT>\" ) <EOL> def test_func_code ( self ) : <EOL> num_one , num_two = <NUM_LIT:7> , <NUM_LIT:8> <EOL> def a ( ) : pass <EOL> def b ( ) : return <NUM_LIT:12> <EOL> def c ( ) : return num_one <EOL> def d ( ) : return num_two <EOL> def e ( ) : return num_one , num_two <EOL> for func in [ a , b , c , d , e ] : <EOL> self . assertEqual ( type ( func . func_code ) , types . CodeType ) <EOL> self . assertEqual ( c ( ) , <NUM_LIT:7> ) <EOL> self . assertEqual ( d ( ) , <NUM_LIT:8> ) <EOL> d . func_code = c . func_code <EOL> self . assertEqual ( c . func_code , d . func_code ) <EOL> self . assertEqual ( c ( ) , <NUM_LIT:7> ) <EOL> try : <EOL> b . func_code = c . func_code <EOL> except ValueError : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> try : <EOL> e . func_code = d . func_code <EOL> except ValueError : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> def test_blank_func_defaults ( self ) : <EOL> self . assertEqual ( self . b . func_defaults , None ) <EOL> del self . b . func_defaults <EOL> self . assertEqual ( self . b . func_defaults , None ) <EOL> def test_func_default_args ( self ) : <EOL> def first_func ( a , b ) : <EOL> return a + b <EOL> def second_func ( a = <NUM_LIT:1> , b = <NUM_LIT:2> ) : <EOL> return a + b <EOL> self . assertEqual ( first_func . func_defaults , None ) <EOL> self . assertEqual ( second_func . func_defaults , ( <NUM_LIT:1> , <NUM_LIT:2> ) ) <EOL> first_func . func_defaults = ( <NUM_LIT:1> , <NUM_LIT:2> ) <EOL> self . assertEqual ( first_func . func_defaults , ( <NUM_LIT:1> , <NUM_LIT:2> ) ) <EOL> self . assertEqual ( first_func ( ) , <NUM_LIT:3> ) <EOL> self . assertEqual ( first_func ( <NUM_LIT:3> ) , <NUM_LIT:5> ) <EOL> self . assertEqual ( first_func ( <NUM_LIT:3> , <NUM_LIT:5> ) , <NUM_LIT:8> ) <EOL> del second_func . func_defaults <EOL> self . assertEqual ( second_func . func_defaults , None ) <EOL> try : <EOL> second_func ( ) <EOL> except TypeError : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> class InstancemethodAttrTest ( FuncAttrsTest ) : <EOL> def test_im_class ( self ) : <EOL> self . assertEqual ( self . f . a . im_class , self . f ) <EOL> self . assertEqual ( self . fi . a . im_class , self . f ) <EOL>"}
{"rec_id": "7681", "recitation_code": "def test im func ( self ) :", "input_code_id": 7681, "input": "<s> from test import test_support <EOL> import types <EOL> import unittest <EOL> class FuncAttrsTest ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> class F : <EOL> def a ( self ) : <EOL> pass <EOL> def b ( ) : <EOL> return <NUM_LIT:3> <EOL> self . f = F <EOL> self . fi = F ( ) <EOL> self . b = b <EOL> def cannot_set_attr ( self , obj , name , value , exceptions ) : <EOL> try : <EOL> setattr ( obj , name , value ) <EOL> except exceptions : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" % ( name , value ) ) <EOL> try : <EOL> delattr ( obj , name ) <EOL> except exceptions : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" % name ) <EOL> class FunctionPropertiesTest ( FuncAttrsTest ) : <EOL> def test_module ( self ) : <EOL> self . assertEqual ( self . b . __module__ , __name__ ) <EOL> def test_dir_includes_correct_attrs ( self ) : <EOL> self . b . known_attr = <NUM_LIT:7> <EOL> self . assertIn ( '<STR_LIT>' , dir ( self . b ) , <EOL> \"<STR_LIT>\" ) <EOL> self . f . a . im_func . known_attr = <NUM_LIT:7> <EOL> self . assertIn ( '<STR_LIT>' , dir ( self . f . a ) , <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> self . assertIn ( '<STR_LIT>' , dir ( self . fi . a ) , <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> def test_duplicate_function_equality ( self ) : <EOL> def duplicate ( ) : <EOL> '<STR_LIT>' <EOL> return <NUM_LIT:3> <EOL> self . assertNotEqual ( self . b , duplicate ) <EOL> def test_copying_func_code ( self ) : <EOL> def test ( ) : pass <EOL> self . assertEqual ( test ( ) , None ) <EOL> test . func_code = self . b . func_code <EOL> self . assertEqual ( test ( ) , <NUM_LIT:3> ) <EOL> def test_func_globals ( self ) : <EOL> self . assertIs ( self . b . func_globals , globals ( ) ) <EOL> self . cannot_set_attr ( self . b , '<STR_LIT>' , <NUM_LIT:2> , TypeError ) <EOL> def test_func_closure ( self ) : <EOL> a = <NUM_LIT:12> <EOL> def f ( ) : print a <EOL> c = f . func_closure <EOL> self . assertIsInstance ( c , tuple ) <EOL> self . assertEqual ( len ( c ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( c [ <NUM_LIT:0> ] . __class__ . __name__ , \"<STR_LIT>\" ) <EOL> self . cannot_set_attr ( f , \"<STR_LIT>\" , c , TypeError ) <EOL> def test_empty_cell ( self ) : <EOL> def f ( ) : print a <EOL> try : <EOL> f . func_closure [ <NUM_LIT:0> ] . cell_contents <EOL> except ValueError : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" ) <EOL> a = <NUM_LIT:12> <EOL> def test_func_name ( self ) : <EOL> self . assertEqual ( self . b . __name__ , '<STR_LIT:b>' ) <EOL> self . assertEqual ( self . b . func_name , '<STR_LIT:b>' ) <EOL> self . b . __name__ = '<STR_LIT:c>' <EOL> self . assertEqual ( self . b . __name__ , '<STR_LIT:c>' ) <EOL> self . assertEqual ( self . b . func_name , '<STR_LIT:c>' ) <EOL> self . b . func_name = '<STR_LIT:d>' <EOL> self . assertEqual ( self . b . __name__ , '<STR_LIT:d>' ) <EOL> self . assertEqual ( self . b . func_name , '<STR_LIT:d>' ) <EOL> self . cannot_set_attr ( self . b , '<STR_LIT>' , <NUM_LIT:7> , TypeError ) <EOL> self . cannot_set_attr ( self . b , '<STR_LIT>' , <NUM_LIT:7> , TypeError ) <EOL> s = \"\"\"<STR_LIT>\"\"\" <EOL> exec s in { '<STR_LIT>' : { } } <EOL> self . assertEqual ( self . f . a . __name__ , '<STR_LIT:a>' ) <EOL> self . assertEqual ( self . fi . a . __name__ , '<STR_LIT:a>' ) <EOL> self . cannot_set_attr ( self . f . a , \"<STR_LIT>\" , '<STR_LIT:a>' , AttributeError ) <EOL> self . cannot_set_attr ( self . fi . a , \"<STR_LIT>\" , '<STR_LIT:a>' , AttributeError ) <EOL> def test_func_code ( self ) : <EOL> num_one , num_two = <NUM_LIT:7> , <NUM_LIT:8> <EOL> def a ( ) : pass <EOL> def b ( ) : return <NUM_LIT:12> <EOL> def c ( ) : return num_one <EOL> def d ( ) : return num_two <EOL> def e ( ) : return num_one , num_two <EOL> for func in [ a , b , c , d , e ] : <EOL> self . assertEqual ( type ( func . func_code ) , types . CodeType ) <EOL> self . assertEqual ( c ( ) , <NUM_LIT:7> ) <EOL> self . assertEqual ( d ( ) , <NUM_LIT:8> ) <EOL> d . func_code = c . func_code <EOL> self . assertEqual ( c . func_code , d . func_code ) <EOL> self . assertEqual ( c ( ) , <NUM_LIT:7> ) <EOL> try : <EOL> b . func_code = c . func_code <EOL> except ValueError : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> try : <EOL> e . func_code = d . func_code <EOL> except ValueError : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> def test_blank_func_defaults ( self ) : <EOL> self . assertEqual ( self . b . func_defaults , None ) <EOL> del self . b . func_defaults <EOL> self . assertEqual ( self . b . func_defaults , None ) <EOL> def test_func_default_args ( self ) : <EOL> def first_func ( a , b ) : <EOL> return a + b <EOL> def second_func ( a = <NUM_LIT:1> , b = <NUM_LIT:2> ) : <EOL> return a + b <EOL> self . assertEqual ( first_func . func_defaults , None ) <EOL> self . assertEqual ( second_func . func_defaults , ( <NUM_LIT:1> , <NUM_LIT:2> ) ) <EOL> first_func . func_defaults = ( <NUM_LIT:1> , <NUM_LIT:2> ) <EOL> self . assertEqual ( first_func . func_defaults , ( <NUM_LIT:1> , <NUM_LIT:2> ) ) <EOL> self . assertEqual ( first_func ( ) , <NUM_LIT:3> ) <EOL> self . assertEqual ( first_func ( <NUM_LIT:3> ) , <NUM_LIT:5> ) <EOL> self . assertEqual ( first_func ( <NUM_LIT:3> , <NUM_LIT:5> ) , <NUM_LIT:8> ) <EOL> del second_func . func_defaults <EOL> self . assertEqual ( second_func . func_defaults , None ) <EOL> try : <EOL> second_func ( ) <EOL> except TypeError : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> class InstancemethodAttrTest ( FuncAttrsTest ) : <EOL> def test_im_class ( self ) : <EOL> self . assertEqual ( self . f . a . im_class , self . f ) <EOL> self . assertEqual ( self . fi . a . im_class , self . f ) <EOL> self . cannot_set_attr ( self . f . a , \"<STR_LIT>\" , self . f , TypeError ) <EOL> self . cannot_set_attr ( self . fi . a , \"<STR_LIT>\" , self . f , TypeError ) <EOL>"}
{"rec_id": "7681", "recitation_code": "def test im func ( self ) :", "input_code_id": 65598, "input": "<s> from test import test_support <EOL> import types <EOL> import unittest <EOL> class FuncAttrsTest ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> class F : <EOL> def a ( self ) : <EOL> pass <EOL> def b ( ) : <EOL> return <NUM_LIT:3> <EOL> self . f = F <EOL> self . fi = F ( ) <EOL> self . b = b <EOL> def cannot_set_attr ( self , obj , name , value , exceptions ) : <EOL> try : <EOL> setattr ( obj , name , value ) <EOL> except exceptions : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" % ( name , value ) ) <EOL> try : <EOL> delattr ( obj , name ) <EOL> except exceptions : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" % name ) <EOL> class FunctionPropertiesTest ( FuncAttrsTest ) : <EOL> def test_module ( self ) : <EOL> self . assertEqual ( self . b . __module__ , __name__ ) <EOL> def test_dir_includes_correct_attrs ( self ) : <EOL> self . b . known_attr = <NUM_LIT:7> <EOL> self . assertIn ( '<STR_LIT>' , dir ( self . b ) , <EOL> \"<STR_LIT>\" ) <EOL> self . f . a . im_func . known_attr = <NUM_LIT:7> <EOL> self . assertIn ( '<STR_LIT>' , dir ( self . f . a ) , <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> self . assertIn ( '<STR_LIT>' , dir ( self . fi . a ) , <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> def test_duplicate_function_equality ( self ) : <EOL> def duplicate ( ) : <EOL> '<STR_LIT>' <EOL> return <NUM_LIT:3> <EOL> self . assertNotEqual ( self . b , duplicate ) <EOL> def test_copying_func_code ( self ) : <EOL> def test ( ) : pass <EOL> self . assertEqual ( test ( ) , None ) <EOL> test . func_code = self . b . func_code <EOL> self . assertEqual ( test ( ) , <NUM_LIT:3> ) <EOL> def test_func_globals ( self ) : <EOL> self . assertIs ( self . b . func_globals , globals ( ) ) <EOL> self . cannot_set_attr ( self . b , '<STR_LIT>' , <NUM_LIT:2> , TypeError ) <EOL> def test_func_closure ( self ) : <EOL> a = <NUM_LIT:12> <EOL> def f ( ) : print a <EOL> c = f . func_closure <EOL> self . assertIsInstance ( c , tuple ) <EOL> self . assertEqual ( len ( c ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( c [ <NUM_LIT:0> ] . __class__ . __name__ , \"<STR_LIT>\" ) <EOL> self . cannot_set_attr ( f , \"<STR_LIT>\" , c , TypeError ) <EOL> def test_empty_cell ( self ) : <EOL> def f ( ) : print a <EOL> try : <EOL> f . func_closure [ <NUM_LIT:0> ] . cell_contents <EOL> except ValueError : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" ) <EOL> a = <NUM_LIT:12> <EOL> def test_func_name ( self ) : <EOL> self . assertEqual ( self . b . __name__ , '<STR_LIT:b>' ) <EOL> self . assertEqual ( self . b . func_name , '<STR_LIT:b>' ) <EOL> self . b . __name__ = '<STR_LIT:c>' <EOL> self . assertEqual ( self . b . __name__ , '<STR_LIT:c>' ) <EOL> self . assertEqual ( self . b . func_name , '<STR_LIT:c>' ) <EOL> self . b . func_name = '<STR_LIT:d>' <EOL> self . assertEqual ( self . b . __name__ , '<STR_LIT:d>' ) <EOL> self . assertEqual ( self . b . func_name , '<STR_LIT:d>' ) <EOL> self . cannot_set_attr ( self . b , '<STR_LIT>' , <NUM_LIT:7> , TypeError ) <EOL> self . cannot_set_attr ( self . b , '<STR_LIT>' , <NUM_LIT:7> , TypeError ) <EOL> s = \"\"\"<STR_LIT>\"\"\" <EOL> exec s in { '<STR_LIT>' : { } } <EOL> self . assertEqual ( self . f . a . __name__ , '<STR_LIT:a>' ) <EOL> self . assertEqual ( self . fi . a . __name__ , '<STR_LIT:a>' ) <EOL> self . cannot_set_attr ( self . f . a , \"<STR_LIT>\" , '<STR_LIT:a>' , AttributeError ) <EOL> self . cannot_set_attr ( self . fi . a , \"<STR_LIT>\" , '<STR_LIT:a>' , AttributeError ) <EOL> def test_func_code ( self ) : <EOL> num_one , num_two = <NUM_LIT:7> , <NUM_LIT:8> <EOL> def a ( ) : pass <EOL> def b ( ) : return <NUM_LIT:12> <EOL> def c ( ) : return num_one <EOL> def d ( ) : return num_two <EOL> def e ( ) : return num_one , num_two <EOL> for func in [ a , b , c , d , e ] : <EOL> self . assertEqual ( type ( func . func_code ) , types . CodeType ) <EOL> self . assertEqual ( c ( ) , <NUM_LIT:7> ) <EOL> self . assertEqual ( d ( ) , <NUM_LIT:8> ) <EOL> d . func_code = c . func_code <EOL> self . assertEqual ( c . func_code , d . func_code ) <EOL> self . assertEqual ( c ( ) , <NUM_LIT:7> ) <EOL> try : <EOL> b . func_code = c . func_code <EOL> except ValueError : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> try : <EOL> e . func_code = d . func_code <EOL> except ValueError : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> def test_blank_func_defaults ( self ) : <EOL> self . assertEqual ( self . b . func_defaults , None ) <EOL> del self . b . func_defaults <EOL> self . assertEqual ( self . b . func_defaults , None ) <EOL> def test_func_default_args ( self ) : <EOL> def first_func ( a , b ) : <EOL> return a + b <EOL> def second_func ( a = <NUM_LIT:1> , b = <NUM_LIT:2> ) : <EOL> return a + b <EOL> self . assertEqual ( first_func . func_defaults , None ) <EOL> self . assertEqual ( second_func . func_defaults , ( <NUM_LIT:1> , <NUM_LIT:2> ) ) <EOL> first_func . func_defaults = ( <NUM_LIT:1> , <NUM_LIT:2> ) <EOL> self . assertEqual ( first_func . func_defaults , ( <NUM_LIT:1> , <NUM_LIT:2> ) ) <EOL> self . assertEqual ( first_func ( ) , <NUM_LIT:3> ) <EOL> self . assertEqual ( first_func ( <NUM_LIT:3> ) , <NUM_LIT:5> ) <EOL> self . assertEqual ( first_func ( <NUM_LIT:3> , <NUM_LIT:5> ) , <NUM_LIT:8> ) <EOL> del second_func . func_defaults <EOL> self . assertEqual ( second_func . func_defaults , None ) <EOL> try : <EOL> second_func ( ) <EOL> except TypeError : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> class InstancemethodAttrTest ( FuncAttrsTest ) : <EOL> def test_im_class ( self ) : <EOL> self . assertEqual ( self . f . a . im_class , self . f ) <EOL> self . assertEqual ( self . fi . a . im_class , self . f ) <EOL> self . cannot_set_attr ( self . f . a , \"<STR_LIT>\" , self . f , TypeError ) <EOL> self . cannot_set_attr ( self . fi . a , \"<STR_LIT>\" , self . f , TypeError ) <EOL>"}
{"rec_id": "7745", "recitation_code": "return QueueClient ( * args , * * kwargs )", "input_code_id": 7745, "input": "<s> __all__ = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class QueueClient ( object ) : <EOL> def __new__ ( cls , mode = '<STR_LIT>' , * args , ** kwargs ) : <EOL> if mode == '<STR_LIT>' : <EOL> from zenqueue . client . http . async import QueueClient <EOL>"}
{"rec_id": "7745", "recitation_code": "return QueueClient ( * args , * * kwargs )", "input_code_id": 71450, "input": "<s> __all__ = [ '<STR_LIT>' , '<STR_LIT:http>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class QueueClient ( object ) : <EOL> def __new__ ( cls , method = '<STR_LIT>' , * args , ** kwargs ) : <EOL> if method == '<STR_LIT>' : <EOL> from zenqueue . client . native import QueueClient <EOL>"}
{"rec_id": "7785", "recitation_code": "return \" \" % self . preparer . format sequence ( drop . element )", "input_code_id": 7785, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import datetime <EOL> from sqlalchemy import schema as sa_schema <EOL> from sqlalchemy import exc , types as sqltypes , sql , util <EOL> from sqlalchemy . sql import expression <EOL> from sqlalchemy . engine import base , default , reflection <EOL> from sqlalchemy . sql import compiler <EOL> from sqlalchemy . types import ( BIGINT , BLOB , DATE , FLOAT , INTEGER , NUMERIC , <EOL> SMALLINT , TEXT , TIME , TIMESTAMP , Integer ) <EOL> RESERVED_WORDS = set ( [ <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:all>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:count>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:date>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:default>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:end>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:file>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT:float>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:index>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:int>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:key>\" , \"<STR_LIT>\" , \"<STR_LIT:left>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:null>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT:password>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT:right>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:size>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:start>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:time>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT:to>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:user>\" , \"<STR_LIT>\" , \"<STR_LIT:value>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> ] ) <EOL> class _StringType ( sqltypes . String ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , charset = None , ** kw ) : <EOL> self . charset = charset <EOL> super ( _StringType , self ) . __init__ ( ** kw ) <EOL> class VARCHAR ( _StringType , sqltypes . VARCHAR ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> __visit_name__ = '<STR_LIT>' <EOL> def __init__ ( self , length = None , ** kwargs ) : <EOL> super ( VARCHAR , self ) . __init__ ( length = length , ** kwargs ) <EOL> class CHAR ( _StringType , sqltypes . CHAR ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> __visit_name__ = '<STR_LIT>' <EOL> def __init__ ( self , length = None , ** kwargs ) : <EOL> super ( CHAR , self ) . __init__ ( length = length , ** kwargs ) <EOL> class _FBDateTime ( sqltypes . DateTime ) : <EOL> def bind_processor ( self , dialect ) : <EOL> def process ( value ) : <EOL> if type ( value ) == datetime . date : <EOL> return datetime . datetime ( value . year , value . month , value . day ) <EOL> else : <EOL> return value <EOL> return process <EOL> colspecs = { <EOL> sqltypes . DateTime : _FBDateTime <EOL> } <EOL> ischema_names = { <EOL> '<STR_LIT>' : SMALLINT , <EOL> '<STR_LIT>' : INTEGER , <EOL> '<STR_LIT>' : FLOAT , <EOL> '<STR_LIT>' : FLOAT , <EOL> '<STR_LIT>' : DATE , <EOL> '<STR_LIT>' : TIME , <EOL> '<STR_LIT>' : TEXT , <EOL> '<STR_LIT>' : BIGINT , <EOL> '<STR_LIT>' : FLOAT , <EOL> '<STR_LIT>' : TIMESTAMP , <EOL> '<STR_LIT>' : VARCHAR , <EOL> '<STR_LIT>' : CHAR , <EOL> '<STR_LIT>' : BLOB , <EOL> } <EOL> class FBTypeCompiler ( compiler . GenericTypeCompiler ) : <EOL> def visit_boolean ( self , type_ , ** kw ) : <EOL> return self . visit_SMALLINT ( type_ , ** kw ) <EOL> def visit_datetime ( self , type_ , ** kw ) : <EOL> return self . visit_TIMESTAMP ( type_ , ** kw ) <EOL> def visit_TEXT ( self , type_ , ** kw ) : <EOL> return \"<STR_LIT>\" <EOL> def visit_BLOB ( self , type_ , ** kw ) : <EOL> return \"<STR_LIT>\" <EOL> def _extend_string ( self , type_ , basic ) : <EOL> charset = getattr ( type_ , '<STR_LIT>' , None ) <EOL> if charset is None : <EOL> return basic <EOL> else : <EOL> return '<STR_LIT>' % ( basic , charset ) <EOL> def visit_CHAR ( self , type_ , ** kw ) : <EOL> basic = super ( FBTypeCompiler , self ) . visit_CHAR ( type_ , ** kw ) <EOL> return self . _extend_string ( type_ , basic ) <EOL> def visit_VARCHAR ( self , type_ , ** kw ) : <EOL> if not type_ . length : <EOL> raise exc . CompileError ( <EOL> \"<STR_LIT>\" % <EOL> self . dialect . name ) <EOL> basic = super ( FBTypeCompiler , self ) . visit_VARCHAR ( type_ , ** kw ) <EOL> return self . _extend_string ( type_ , basic ) <EOL> class FBCompiler ( sql . compiler . SQLCompiler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ansi_bind_rules = True <EOL> def visit_now_func ( self , fn , ** kw ) : <EOL> return \"<STR_LIT>\" <EOL> def visit_startswith_op_binary ( self , binary , operator , ** kw ) : <EOL> return '<STR_LIT>' % ( <EOL> binary . left . _compiler_dispatch ( self , ** kw ) , <EOL> binary . right . _compiler_dispatch ( self , ** kw ) ) <EOL> def visit_notstartswith_op_binary ( self , binary , operator , ** kw ) : <EOL> return '<STR_LIT>' % ( <EOL> binary . left . _compiler_dispatch ( self , ** kw ) , <EOL> binary . right . _compiler_dispatch ( self , ** kw ) ) <EOL> def visit_mod_binary ( self , binary , operator , ** kw ) : <EOL> return \"<STR_LIT>\" % ( <EOL> self . process ( binary . left , ** kw ) , <EOL> self . process ( binary . right , ** kw ) ) <EOL> def visit_alias ( self , alias , asfrom = False , ** kwargs ) : <EOL> if self . dialect . _version_two : <EOL> return super ( FBCompiler , self ) . visit_alias ( alias , asfrom = asfrom , ** kwargs ) <EOL> else : <EOL> if asfrom : <EOL> alias_name = isinstance ( alias . name , <EOL> expression . _truncated_label ) and self . _truncated_identifier ( \"<STR_LIT>\" , <EOL> alias . name ) or alias . name <EOL> return self . process ( <EOL> alias . original , asfrom = asfrom , ** kwargs ) + \"<STR_LIT:U+0020>\" + self . preparer . format_alias ( alias , alias_name ) <EOL> else : <EOL> return self . process ( alias . original , ** kwargs ) <EOL> def visit_substring_func ( self , func , ** kw ) : <EOL> s = self . process ( func . clauses . clauses [ <NUM_LIT:0> ] ) <EOL> start = self . process ( func . clauses . clauses [ <NUM_LIT:1> ] ) <EOL> if len ( func . clauses . clauses ) > <NUM_LIT:2> : <EOL> length = self . process ( func . clauses . clauses [ <NUM_LIT:2> ] ) <EOL> return \"<STR_LIT>\" % ( s , start , length ) <EOL> else : <EOL> return \"<STR_LIT>\" % ( s , start ) <EOL> def visit_length_func ( self , function , ** kw ) : <EOL> if self . dialect . _version_two : <EOL> return \"<STR_LIT>\" + self . function_argspec ( function ) <EOL> else : <EOL> return \"<STR_LIT>\" + self . function_argspec ( function ) <EOL> visit_char_length_func = visit_length_func <EOL> def function_argspec ( self , func , ** kw ) : <EOL> if func . clauses is not None and len ( func . clauses ) : <EOL> return self . process ( func . clause_expr , ** kw ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> def default_from ( self ) : <EOL> return \"<STR_LIT>\" <EOL> def visit_sequence ( self , seq ) : <EOL> return \"<STR_LIT>\" % self . preparer . format_sequence ( seq ) <EOL> def get_select_precolumns ( self , select , ** kw ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> result = \"<STR_LIT>\" <EOL> if select . _limit_clause is not None : <EOL> result += \"<STR_LIT>\" % self . process ( select . _limit_clause , ** kw ) <EOL> if select . _offset_clause is not None : <EOL> result += \"<STR_LIT>\" % self . process ( select . _offset_clause , ** kw ) <EOL> if select . _distinct : <EOL> result += \"<STR_LIT>\" <EOL> return result <EOL> def limit_clause ( self , select , ** kw ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return \"<STR_LIT>\" <EOL> def returning_clause ( self , stmt , returning_cols ) : <EOL> columns = [ <EOL> self . _label_select_column ( None , c , True , False , { } ) <EOL> for c in expression . _select_iterables ( returning_cols ) <EOL> ] <EOL> return '<STR_LIT>' + '<STR_LIT:U+002CU+0020>' . join ( columns ) <EOL> class FBDDLCompiler ( sql . compiler . DDLCompiler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def visit_create_sequence ( self , create ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if create . element . start is not None : <EOL> raise NotImplemented ( <EOL> \"<STR_LIT>\" ) <EOL> if create . element . increment is not None : <EOL> raise NotImplemented ( <EOL> \"<STR_LIT>\" ) <EOL> if self . dialect . _version_two : <EOL> return \"<STR_LIT>\" % self . preparer . format_sequence ( create . element ) <EOL> else : <EOL> return \"<STR_LIT>\" % self . preparer . format_sequence ( create . element ) <EOL> def visit_drop_sequence ( self , drop ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . dialect . _version_two : <EOL> return \"<STR_LIT>\" % self . preparer . format_sequence ( drop . element ) <EOL> else : <EOL>"}
{"rec_id": "7785", "recitation_code": "return \" \" % self . preparer . format sequence ( drop . element )", "input_code_id": 11689, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import datetime <EOL> from sqlalchemy import schema as sa_schema <EOL> from sqlalchemy import exc , types as sqltypes , sql , util <EOL> from sqlalchemy . sql import expression <EOL> from sqlalchemy . engine import base , default , reflection <EOL> from sqlalchemy . sql import compiler <EOL> from sqlalchemy . types import ( BIGINT , BLOB , DATE , FLOAT , INTEGER , NUMERIC , <EOL> SMALLINT , TEXT , TIME , TIMESTAMP , Integer ) <EOL> RESERVED_WORDS = set ( [ <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:all>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:count>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:date>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:default>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:end>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:file>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT:float>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:index>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:int>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:key>\" , \"<STR_LIT>\" , \"<STR_LIT:left>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:null>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT:password>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT:right>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:size>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:start>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:time>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT:to>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:user>\" , \"<STR_LIT>\" , \"<STR_LIT:value>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> ] ) <EOL> class _StringType ( sqltypes . String ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , charset = None , ** kw ) : <EOL> self . charset = charset <EOL> super ( _StringType , self ) . __init__ ( ** kw ) <EOL> class VARCHAR ( _StringType , sqltypes . VARCHAR ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> __visit_name__ = '<STR_LIT>' <EOL> def __init__ ( self , length = None , ** kwargs ) : <EOL> super ( VARCHAR , self ) . __init__ ( length = length , ** kwargs ) <EOL> class CHAR ( _StringType , sqltypes . CHAR ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> __visit_name__ = '<STR_LIT>' <EOL> def __init__ ( self , length = None , ** kwargs ) : <EOL> super ( CHAR , self ) . __init__ ( length = length , ** kwargs ) <EOL> class _FBDateTime ( sqltypes . DateTime ) : <EOL> def bind_processor ( self , dialect ) : <EOL> def process ( value ) : <EOL> if type ( value ) == datetime . date : <EOL> return datetime . datetime ( value . year , value . month , value . day ) <EOL> else : <EOL> return value <EOL> return process <EOL> colspecs = { <EOL> sqltypes . DateTime : _FBDateTime <EOL> } <EOL> ischema_names = { <EOL> '<STR_LIT>' : SMALLINT , <EOL> '<STR_LIT>' : INTEGER , <EOL> '<STR_LIT>' : FLOAT , <EOL> '<STR_LIT>' : FLOAT , <EOL> '<STR_LIT>' : DATE , <EOL> '<STR_LIT>' : TIME , <EOL> '<STR_LIT>' : TEXT , <EOL> '<STR_LIT>' : BIGINT , <EOL> '<STR_LIT>' : FLOAT , <EOL> '<STR_LIT>' : TIMESTAMP , <EOL> '<STR_LIT>' : VARCHAR , <EOL> '<STR_LIT>' : CHAR , <EOL> '<STR_LIT>' : BLOB , <EOL> } <EOL> class FBTypeCompiler ( compiler . GenericTypeCompiler ) : <EOL> def visit_boolean ( self , type_ ) : <EOL> return self . visit_SMALLINT ( type_ ) <EOL> def visit_datetime ( self , type_ ) : <EOL> return self . visit_TIMESTAMP ( type_ ) <EOL> def visit_TEXT ( self , type_ ) : <EOL> return \"<STR_LIT>\" <EOL> def visit_BLOB ( self , type_ ) : <EOL> return \"<STR_LIT>\" <EOL> def _extend_string ( self , type_ , basic ) : <EOL> charset = getattr ( type_ , '<STR_LIT>' , None ) <EOL> if charset is None : <EOL> return basic <EOL> else : <EOL> return '<STR_LIT>' % ( basic , charset ) <EOL> def visit_CHAR ( self , type_ ) : <EOL> basic = super ( FBTypeCompiler , self ) . visit_CHAR ( type_ ) <EOL> return self . _extend_string ( type_ , basic ) <EOL> def visit_VARCHAR ( self , type_ ) : <EOL> if not type_ . length : <EOL> raise exc . CompileError ( <EOL> \"<STR_LIT>\" % <EOL> self . dialect . name ) <EOL> basic = super ( FBTypeCompiler , self ) . visit_VARCHAR ( type_ ) <EOL> return self . _extend_string ( type_ , basic ) <EOL> class FBCompiler ( sql . compiler . SQLCompiler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ansi_bind_rules = True <EOL> def visit_now_func ( self , fn , ** kw ) : <EOL> return \"<STR_LIT>\" <EOL> def visit_startswith_op_binary ( self , binary , operator , ** kw ) : <EOL> return '<STR_LIT>' % ( <EOL> binary . left . _compiler_dispatch ( self , ** kw ) , <EOL> binary . right . _compiler_dispatch ( self , ** kw ) ) <EOL> def visit_notstartswith_op_binary ( self , binary , operator , ** kw ) : <EOL> return '<STR_LIT>' % ( <EOL> binary . left . _compiler_dispatch ( self , ** kw ) , <EOL> binary . right . _compiler_dispatch ( self , ** kw ) ) <EOL> def visit_mod_binary ( self , binary , operator , ** kw ) : <EOL> return \"<STR_LIT>\" % ( <EOL> self . process ( binary . left , ** kw ) , <EOL> self . process ( binary . right , ** kw ) ) <EOL> def visit_alias ( self , alias , asfrom = False , ** kwargs ) : <EOL> if self . dialect . _version_two : <EOL> return super ( FBCompiler , self ) . visit_alias ( alias , asfrom = asfrom , ** kwargs ) <EOL> else : <EOL> if asfrom : <EOL> alias_name = isinstance ( alias . name , <EOL> expression . _truncated_label ) and self . _truncated_identifier ( \"<STR_LIT>\" , <EOL> alias . name ) or alias . name <EOL> return self . process ( <EOL> alias . original , asfrom = asfrom , ** kwargs ) + \"<STR_LIT:U+0020>\" + self . preparer . format_alias ( alias , alias_name ) <EOL> else : <EOL> return self . process ( alias . original , ** kwargs ) <EOL> def visit_substring_func ( self , func , ** kw ) : <EOL> s = self . process ( func . clauses . clauses [ <NUM_LIT:0> ] ) <EOL> start = self . process ( func . clauses . clauses [ <NUM_LIT:1> ] ) <EOL> if len ( func . clauses . clauses ) > <NUM_LIT:2> : <EOL> length = self . process ( func . clauses . clauses [ <NUM_LIT:2> ] ) <EOL> return \"<STR_LIT>\" % ( s , start , length ) <EOL> else : <EOL> return \"<STR_LIT>\" % ( s , start ) <EOL> def visit_length_func ( self , function , ** kw ) : <EOL> if self . dialect . _version_two : <EOL> return \"<STR_LIT>\" + self . function_argspec ( function ) <EOL> else : <EOL> return \"<STR_LIT>\" + self . function_argspec ( function ) <EOL> visit_char_length_func = visit_length_func <EOL> def function_argspec ( self , func , ** kw ) : <EOL> if func . clauses is not None and len ( func . clauses ) : <EOL> return self . process ( func . clause_expr , ** kw ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> def default_from ( self ) : <EOL> return \"<STR_LIT>\" <EOL> def visit_sequence ( self , seq ) : <EOL> return \"<STR_LIT>\" % self . preparer . format_sequence ( seq ) <EOL> def get_select_precolumns ( self , select ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> result = \"<STR_LIT>\" <EOL> if select . _limit : <EOL> result += \"<STR_LIT>\" % self . process ( sql . literal ( select . _limit ) ) <EOL> if select . _offset : <EOL> result += \"<STR_LIT>\" % self . process ( sql . literal ( select . _offset ) ) <EOL> if select . _distinct : <EOL> result += \"<STR_LIT>\" <EOL> return result <EOL> def limit_clause ( self , select ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return \"<STR_LIT>\" <EOL> def returning_clause ( self , stmt , returning_cols ) : <EOL> columns = [ <EOL> self . _label_select_column ( None , c , True , False , { } ) <EOL> for c in expression . _select_iterables ( returning_cols ) <EOL> ] <EOL> return '<STR_LIT>' + '<STR_LIT:U+002CU+0020>' . join ( columns ) <EOL> class FBDDLCompiler ( sql . compiler . DDLCompiler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def visit_create_sequence ( self , create ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if create . element . start is not None : <EOL> raise NotImplemented ( <EOL> \"<STR_LIT>\" ) <EOL> if create . element . increment is not None : <EOL> raise NotImplemented ( <EOL> \"<STR_LIT>\" ) <EOL> if self . dialect . _version_two : <EOL> return \"<STR_LIT>\" % self . preparer . format_sequence ( create . element ) <EOL> else : <EOL> return \"<STR_LIT>\" % self . preparer . format_sequence ( create . element ) <EOL> def visit_drop_sequence ( self , drop ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . dialect . _version_two : <EOL> return \"<STR_LIT>\" % self . preparer . format_sequence ( drop . element ) <EOL> else : <EOL>"}
{"rec_id": "7785", "recitation_code": "return \" \" % self . preparer . format sequence ( drop . element )", "input_code_id": 25620, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import datetime <EOL> from sqlalchemy import schema as sa_schema <EOL> from sqlalchemy import exc , types as sqltypes , sql , util <EOL> from sqlalchemy . sql import expression <EOL> from sqlalchemy . engine import base , default , reflection <EOL> from sqlalchemy . sql import compiler <EOL> from sqlalchemy . types import ( BIGINT , BLOB , DATE , FLOAT , INTEGER , NUMERIC , <EOL> SMALLINT , TEXT , TIME , TIMESTAMP , Integer ) <EOL> RESERVED_WORDS = set ( [ <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:all>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:count>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:date>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:default>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:end>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:file>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT:float>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:index>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:int>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:key>\" , \"<STR_LIT>\" , \"<STR_LIT:left>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:null>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT:password>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT:right>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:size>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:start>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:time>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT:to>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:user>\" , \"<STR_LIT>\" , \"<STR_LIT:value>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> ] ) <EOL> class _StringType ( sqltypes . String ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , charset = None , ** kw ) : <EOL> self . charset = charset <EOL> super ( _StringType , self ) . __init__ ( ** kw ) <EOL> class VARCHAR ( _StringType , sqltypes . VARCHAR ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> __visit_name__ = '<STR_LIT>' <EOL> def __init__ ( self , length = None , ** kwargs ) : <EOL> super ( VARCHAR , self ) . __init__ ( length = length , ** kwargs ) <EOL> class CHAR ( _StringType , sqltypes . CHAR ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> __visit_name__ = '<STR_LIT>' <EOL> def __init__ ( self , length = None , ** kwargs ) : <EOL> super ( CHAR , self ) . __init__ ( length = length , ** kwargs ) <EOL> class _FBDateTime ( sqltypes . DateTime ) : <EOL> def bind_processor ( self , dialect ) : <EOL> def process ( value ) : <EOL> if type ( value ) == datetime . date : <EOL> return datetime . datetime ( value . year , value . month , value . day ) <EOL> else : <EOL> return value <EOL> return process <EOL> colspecs = { <EOL> sqltypes . DateTime : _FBDateTime <EOL> } <EOL> ischema_names = { <EOL> '<STR_LIT>' : SMALLINT , <EOL> '<STR_LIT>' : INTEGER , <EOL> '<STR_LIT>' : FLOAT , <EOL> '<STR_LIT>' : FLOAT , <EOL> '<STR_LIT>' : DATE , <EOL> '<STR_LIT>' : TIME , <EOL> '<STR_LIT>' : TEXT , <EOL> '<STR_LIT>' : BIGINT , <EOL> '<STR_LIT>' : FLOAT , <EOL> '<STR_LIT>' : TIMESTAMP , <EOL> '<STR_LIT>' : VARCHAR , <EOL> '<STR_LIT>' : CHAR , <EOL> '<STR_LIT>' : BLOB , <EOL> } <EOL> class FBTypeCompiler ( compiler . GenericTypeCompiler ) : <EOL> def visit_boolean ( self , type_ ) : <EOL> return self . visit_SMALLINT ( type_ ) <EOL> def visit_datetime ( self , type_ ) : <EOL> return self . visit_TIMESTAMP ( type_ ) <EOL> def visit_TEXT ( self , type_ ) : <EOL> return \"<STR_LIT>\" <EOL> def visit_BLOB ( self , type_ ) : <EOL> return \"<STR_LIT>\" <EOL> def _extend_string ( self , type_ , basic ) : <EOL> charset = getattr ( type_ , '<STR_LIT>' , None ) <EOL> if charset is None : <EOL> return basic <EOL> else : <EOL> return '<STR_LIT>' % ( basic , charset ) <EOL> def visit_CHAR ( self , type_ ) : <EOL> basic = super ( FBTypeCompiler , self ) . visit_CHAR ( type_ ) <EOL> return self . _extend_string ( type_ , basic ) <EOL> def visit_VARCHAR ( self , type_ ) : <EOL> if not type_ . length : <EOL> raise exc . CompileError ( <EOL> \"<STR_LIT>\" % <EOL> self . dialect . name ) <EOL> basic = super ( FBTypeCompiler , self ) . visit_VARCHAR ( type_ ) <EOL> return self . _extend_string ( type_ , basic ) <EOL> class FBCompiler ( sql . compiler . SQLCompiler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ansi_bind_rules = True <EOL> def visit_now_func ( self , fn , ** kw ) : <EOL> return \"<STR_LIT>\" <EOL> def visit_startswith_op_binary ( self , binary , operator , ** kw ) : <EOL> return '<STR_LIT>' % ( <EOL> binary . left . _compiler_dispatch ( self , ** kw ) , <EOL> binary . right . _compiler_dispatch ( self , ** kw ) ) <EOL> def visit_notstartswith_op_binary ( self , binary , operator , ** kw ) : <EOL> return '<STR_LIT>' % ( <EOL> binary . left . _compiler_dispatch ( self , ** kw ) , <EOL> binary . right . _compiler_dispatch ( self , ** kw ) ) <EOL> def visit_mod_binary ( self , binary , operator , ** kw ) : <EOL> return \"<STR_LIT>\" % ( <EOL> self . process ( binary . left , ** kw ) , <EOL> self . process ( binary . right , ** kw ) ) <EOL> def visit_alias ( self , alias , asfrom = False , ** kwargs ) : <EOL> if self . dialect . _version_two : <EOL> return super ( FBCompiler , self ) . visit_alias ( alias , asfrom = asfrom , ** kwargs ) <EOL> else : <EOL> if asfrom : <EOL> alias_name = isinstance ( alias . name , <EOL> expression . _truncated_label ) and self . _truncated_identifier ( \"<STR_LIT>\" , <EOL> alias . name ) or alias . name <EOL> return self . process ( <EOL> alias . original , asfrom = asfrom , ** kwargs ) + \"<STR_LIT:U+0020>\" + self . preparer . format_alias ( alias , alias_name ) <EOL> else : <EOL> return self . process ( alias . original , ** kwargs ) <EOL> def visit_substring_func ( self , func , ** kw ) : <EOL> s = self . process ( func . clauses . clauses [ <NUM_LIT:0> ] ) <EOL> start = self . process ( func . clauses . clauses [ <NUM_LIT:1> ] ) <EOL> if len ( func . clauses . clauses ) > <NUM_LIT:2> : <EOL> length = self . process ( func . clauses . clauses [ <NUM_LIT:2> ] ) <EOL> return \"<STR_LIT>\" % ( s , start , length ) <EOL> else : <EOL> return \"<STR_LIT>\" % ( s , start ) <EOL> def visit_length_func ( self , function , ** kw ) : <EOL> if self . dialect . _version_two : <EOL> return \"<STR_LIT>\" + self . function_argspec ( function ) <EOL> else : <EOL> return \"<STR_LIT>\" + self . function_argspec ( function ) <EOL> visit_char_length_func = visit_length_func <EOL> def function_argspec ( self , func , ** kw ) : <EOL> if func . clauses is not None and len ( func . clauses ) : <EOL> return self . process ( func . clause_expr , ** kw ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> def default_from ( self ) : <EOL> return \"<STR_LIT>\" <EOL> def visit_sequence ( self , seq ) : <EOL> return \"<STR_LIT>\" % self . preparer . format_sequence ( seq ) <EOL> def get_select_precolumns ( self , select ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> result = \"<STR_LIT>\" <EOL> if select . _limit : <EOL> result += \"<STR_LIT>\" % self . process ( sql . literal ( select . _limit ) ) <EOL> if select . _offset : <EOL> result += \"<STR_LIT>\" % self . process ( sql . literal ( select . _offset ) ) <EOL> if select . _distinct : <EOL> result += \"<STR_LIT>\" <EOL> return result <EOL> def limit_clause ( self , select ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return \"<STR_LIT>\" <EOL> def returning_clause ( self , stmt , returning_cols ) : <EOL> columns = [ <EOL> self . _label_select_column ( None , c , True , False , { } ) <EOL> for c in expression . _select_iterables ( returning_cols ) <EOL> ] <EOL> return '<STR_LIT>' + '<STR_LIT:U+002CU+0020>' . join ( columns ) <EOL> class FBDDLCompiler ( sql . compiler . DDLCompiler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def visit_create_sequence ( self , create ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if create . element . start is not None : <EOL> raise NotImplemented ( <EOL> \"<STR_LIT>\" ) <EOL> if create . element . increment is not None : <EOL> raise NotImplemented ( <EOL> \"<STR_LIT>\" ) <EOL> if self . dialect . _version_two : <EOL> return \"<STR_LIT>\" % self . preparer . format_sequence ( create . element ) <EOL> else : <EOL> return \"<STR_LIT>\" % self . preparer . format_sequence ( create . element ) <EOL> def visit_drop_sequence ( self , drop ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . dialect . _version_two : <EOL>"}
{"rec_id": "7855", "recitation_code": "if self . total upload > = self . QUOTA :", "input_code_id": 7855, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from django . core . files . uploadhandler import FileUploadHandler , StopUpload <EOL> class QuotaUploadHandler ( FileUploadHandler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> QUOTA = <NUM_LIT:5> * <NUM_LIT:2> ** <NUM_LIT:20> <EOL> def __init__ ( self , request = None ) : <EOL> super ( QuotaUploadHandler , self ) . __init__ ( request ) <EOL> self . total_upload = <NUM_LIT:0> <EOL> def receive_data_chunk ( self , raw_data , start ) : <EOL> self . total_upload += len ( raw_data ) <EOL>"}
{"rec_id": "7855", "recitation_code": "if self . total upload > = self . QUOTA :", "input_code_id": 189, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from django . core . files . uploadhandler import FileUploadHandler , StopUpload <EOL> class QuotaUploadHandler ( FileUploadHandler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> QUOTA = <NUM_LIT:5> * <NUM_LIT:2> ** <NUM_LIT:20> <EOL> def __init__ ( self , request = None ) : <EOL> super ( QuotaUploadHandler , self ) . __init__ ( request ) <EOL> self . total_upload = <NUM_LIT:0> <EOL> def receive_data_chunk ( self , raw_data , start ) : <EOL> self . total_upload += len ( raw_data ) <EOL>"}
{"rec_id": "7855", "recitation_code": "if self . total upload > = self . QUOTA :", "input_code_id": 45197, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from django . core . files . uploadhandler import FileUploadHandler , StopUpload <EOL> class QuotaUploadHandler ( FileUploadHandler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> QUOTA = <NUM_LIT:5> * <NUM_LIT:2> ** <NUM_LIT:20> <EOL> def __init__ ( self , request = None ) : <EOL> super ( QuotaUploadHandler , self ) . __init__ ( request ) <EOL> self . total_upload = <NUM_LIT:0> <EOL> def receive_data_chunk ( self , raw_data , start ) : <EOL> self . total_upload += len ( raw_data ) <EOL>"}
{"rec_id": "7876", "recitation_code": "super ( CallTipWidget , self ) . showEvent ( event )", "input_code_id": 7876, "input": "<s> import re <EOL> from textwrap import dedent <EOL> from unicodedata import category <EOL> from IPython . external . qt import QtCore , QtGui <EOL> class CallTipWidget ( QtGui . QLabel ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , text_edit ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> assert isinstance ( text_edit , ( QtGui . QTextEdit , QtGui . QPlainTextEdit ) ) <EOL> super ( CallTipWidget , self ) . __init__ ( None , QtCore . Qt . ToolTip ) <EOL> self . _hide_timer = QtCore . QBasicTimer ( ) <EOL> self . _text_edit = text_edit <EOL> self . setFont ( text_edit . document ( ) . defaultFont ( ) ) <EOL> self . setForegroundRole ( QtGui . QPalette . ToolTipText ) <EOL> self . setBackgroundRole ( QtGui . QPalette . ToolTipBase ) <EOL> self . setPalette ( QtGui . QToolTip . palette ( ) ) <EOL> self . setAlignment ( QtCore . Qt . AlignLeft ) <EOL> self . setIndent ( <NUM_LIT:1> ) <EOL> self . setFrameStyle ( QtGui . QFrame . NoFrame ) <EOL> self . setMargin ( <NUM_LIT:1> + self . style ( ) . pixelMetric ( <EOL> QtGui . QStyle . PM_ToolTipLabelFrameWidth , None , self ) ) <EOL> self . setWindowOpacity ( self . style ( ) . styleHint ( <EOL> QtGui . QStyle . SH_ToolTipLabel_Opacity , None , self , None ) / <NUM_LIT> ) <EOL> def eventFilter ( self , obj , event ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if obj == self . _text_edit : <EOL> etype = event . type ( ) <EOL> if etype == QtCore . QEvent . KeyPress : <EOL> key = event . key ( ) <EOL> if key in ( QtCore . Qt . Key_Enter , QtCore . Qt . Key_Return ) : <EOL> self . hide ( ) <EOL> elif key == QtCore . Qt . Key_Escape : <EOL> self . hide ( ) <EOL> return True <EOL> elif etype == QtCore . QEvent . FocusOut : <EOL> self . hide ( ) <EOL> elif etype == QtCore . QEvent . Enter : <EOL> self . _hide_timer . stop ( ) <EOL> elif etype == QtCore . QEvent . Leave : <EOL> self . _leave_event_hide ( ) <EOL> return super ( CallTipWidget , self ) . eventFilter ( obj , event ) <EOL> def timerEvent ( self , event ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if event . timerId ( ) == self . _hide_timer . timerId ( ) : <EOL> self . _hide_timer . stop ( ) <EOL> self . hide ( ) <EOL> def enterEvent ( self , event ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> super ( CallTipWidget , self ) . enterEvent ( event ) <EOL> self . _hide_timer . stop ( ) <EOL> def hideEvent ( self , event ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> super ( CallTipWidget , self ) . hideEvent ( event ) <EOL> self . _text_edit . cursorPositionChanged . disconnect ( <EOL> self . _cursor_position_changed ) <EOL> self . _text_edit . removeEventFilter ( self ) <EOL> def leaveEvent ( self , event ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> super ( CallTipWidget , self ) . leaveEvent ( event ) <EOL> self . _leave_event_hide ( ) <EOL> def paintEvent ( self , event ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> painter = QtGui . QStylePainter ( self ) <EOL> option = QtGui . QStyleOptionFrame ( ) <EOL> option . initFrom ( self ) <EOL> painter . drawPrimitive ( QtGui . QStyle . PE_PanelTipLabel , option ) <EOL> painter . end ( ) <EOL> super ( CallTipWidget , self ) . paintEvent ( event ) <EOL> def setFont ( self , font ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> super ( CallTipWidget , self ) . setFont ( font ) <EOL> def showEvent ( self , event ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>"}
{"rec_id": "7876", "recitation_code": "super ( CallTipWidget , self ) . showEvent ( event )", "input_code_id": 14848, "input": "<s> import re <EOL> from textwrap import dedent <EOL> from unicodedata import category <EOL> from pyface . qt import QtCore , QtGui <EOL> class CallTipWidget ( QtGui . QLabel ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , text_edit ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> assert isinstance ( text_edit , ( QtGui . QTextEdit , QtGui . QPlainTextEdit ) ) <EOL> super ( CallTipWidget , self ) . __init__ ( None , QtCore . Qt . ToolTip ) <EOL> self . _hide_timer = QtCore . QBasicTimer ( ) <EOL> self . _text_edit = text_edit <EOL> self . setFont ( text_edit . document ( ) . defaultFont ( ) ) <EOL> self . setForegroundRole ( QtGui . QPalette . ToolTipText ) <EOL> self . setBackgroundRole ( QtGui . QPalette . ToolTipBase ) <EOL> self . setPalette ( QtGui . QToolTip . palette ( ) ) <EOL> self . setAlignment ( QtCore . Qt . AlignLeft ) <EOL> self . setIndent ( <NUM_LIT:1> ) <EOL> self . setFrameStyle ( QtGui . QFrame . NoFrame ) <EOL> self . setMargin ( <NUM_LIT:1> + self . style ( ) . pixelMetric ( <EOL> QtGui . QStyle . PM_ToolTipLabelFrameWidth , None , self ) ) <EOL> self . setWindowOpacity ( self . style ( ) . styleHint ( <EOL> QtGui . QStyle . SH_ToolTipLabel_Opacity , None , self , None ) / <NUM_LIT> ) <EOL> def eventFilter ( self , obj , event ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if obj == self . _text_edit : <EOL> etype = event . type ( ) <EOL> if etype == QtCore . QEvent . KeyPress : <EOL> key = event . key ( ) <EOL> if key in ( QtCore . Qt . Key_Enter , QtCore . Qt . Key_Return ) : <EOL> self . hide ( ) <EOL> elif key == QtCore . Qt . Key_Escape : <EOL> self . hide ( ) <EOL> return True <EOL> elif etype == QtCore . QEvent . FocusOut : <EOL> self . hide ( ) <EOL> elif etype == QtCore . QEvent . Enter : <EOL> self . _hide_timer . stop ( ) <EOL> elif etype == QtCore . QEvent . Leave : <EOL> self . _leave_event_hide ( ) <EOL> return super ( CallTipWidget , self ) . eventFilter ( obj , event ) <EOL> def timerEvent ( self , event ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if event . timerId ( ) == self . _hide_timer . timerId ( ) : <EOL> self . _hide_timer . stop ( ) <EOL> self . hide ( ) <EOL> def enterEvent ( self , event ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> super ( CallTipWidget , self ) . enterEvent ( event ) <EOL> self . _hide_timer . stop ( ) <EOL> def hideEvent ( self , event ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> super ( CallTipWidget , self ) . hideEvent ( event ) <EOL> self . _text_edit . cursorPositionChanged . disconnect ( <EOL> self . _cursor_position_changed ) <EOL> self . _text_edit . removeEventFilter ( self ) <EOL> def leaveEvent ( self , event ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> super ( CallTipWidget , self ) . leaveEvent ( event ) <EOL> self . _leave_event_hide ( ) <EOL> def paintEvent ( self , event ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> painter = QtGui . QStylePainter ( self ) <EOL> option = QtGui . QStyleOptionFrame ( ) <EOL> option . initFrom ( self ) <EOL> painter . drawPrimitive ( QtGui . QStyle . PE_PanelTipLabel , option ) <EOL> painter . end ( ) <EOL> super ( CallTipWidget , self ) . paintEvent ( event ) <EOL> def setFont ( self , font ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> super ( CallTipWidget , self ) . setFont ( font ) <EOL> def showEvent ( self , event ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>"}
{"rec_id": "7903", "recitation_code": "ui . say ( \" \" )", "input_code_id": 7903, "input": "<s> import pytest <EOL> from tests . helpers import ui , init_test_room <EOL> def test_linus_sees_quit_begin_and_help_in_menu_but_no_other_commands_before_entering_a_room ( ui ) : <EOL> ui , engine = init_test_room ( ui ) <EOL> ui . say ( \"<STR_LIT>\" ) <EOL> ui . say ( \"<STR_LIT>\" ) <EOL> ui . say ( \"<STR_LIT:q>\" ) <EOL> engine . main_loop ( ) <EOL>"}
{"rec_id": "7903", "recitation_code": "ui . say ( \" \" )", "input_code_id": 24091, "input": "<s> import pytest <EOL> from tests . helpers import ui , init_test_room <EOL> def test_fred_can_start_and_stop_the_loop_with_ease ( ui ) : <EOL> ui , engine = init_test_room ( ui ) <EOL> ui . say ( \"<STR_LIT>\" ) <EOL> ui . say ( \"<STR_LIT>\" ) <EOL> engine . main_loop ( ) <EOL> assert ui . output_anywhere ( \"<STR_LIT:>>\" ) <EOL> def test_fred_can_stop_the_loop_with_lower_case_q ( ui ) : <EOL> ui , engine = init_test_room ( ui ) <EOL> ui . say ( \"<STR_LIT>\" ) <EOL>"}
{"rec_id": "7903", "recitation_code": "ui . say ( \" \" )", "input_code_id": 85273, "input": "<s> import pytest <EOL> from tests . helpers import ui , init_roach_room <EOL> def test_roach_runs_to_the_exit ( ui ) : <EOL> ui , engine = init_roach_room ( ui ) <EOL> ui . say ( \"<STR_LIT>\" ) <EOL> ui . say ( \"<STR_LIT:k>\" ) <EOL> ui . say ( \"<STR_LIT:k>\" ) <EOL> ui . say ( \"<STR_LIT:k>\" ) <EOL> ui . say ( \"<STR_LIT:e>\" ) <EOL>"}
{"rec_id": "7930", "recitation_code": "class NoteResource ( ModelResource ) :", "input_code_id": 7930, "input": "<s> from django . conf . urls . defaults import url <EOL> from django . contrib . auth . models import User <EOL> from tastypie . bundle import Bundle <EOL> from tastypie import fields <EOL> from tastypie . resources import ModelResource <EOL> from tastypie . authentication import SessionAuthentication <EOL> from tastypie . authorization import Authorization <EOL> from basic . models import Note , AnnotatedNote , SlugBasedNote <EOL> class UserResource ( ModelResource ) : <EOL> class Meta : <EOL> resource_name = '<STR_LIT>' <EOL> queryset = User . objects . all ( ) <EOL> authorization = Authorization ( ) <EOL> class CachedUserResource ( ModelResource ) : <EOL> class Meta : <EOL> allowed_methods = ( '<STR_LIT>' , ) <EOL> queryset = User . objects . all ( ) <EOL> resource_name = '<STR_LIT>' <EOL> def create_response ( self , * args , ** kwargs ) : <EOL> resp = super ( CachedUserResource , self ) . create_response ( * args , ** kwargs ) <EOL> resp [ '<STR_LIT>' ] = \"<STR_LIT>\" <EOL> return resp <EOL>"}
{"rec_id": "7930", "recitation_code": "class NoteResource ( ModelResource ) :", "input_code_id": 85834, "input": "<s> from django . contrib . auth . models import User <EOL> from tastypie . cache import SimpleCache <EOL> from tastypie import fields <EOL> from tastypie . resources import ModelResource <EOL> from tastypie . authentication import SessionAuthentication <EOL> from tastypie . authorization import Authorization <EOL> from basic . models import Note , AnnotatedNote , SlugBasedNote <EOL> class UserResource ( ModelResource ) : <EOL> class Meta : <EOL> resource_name = '<STR_LIT>' <EOL> queryset = User . objects . all ( ) <EOL> authorization = Authorization ( ) <EOL> class CachedUserResource ( ModelResource ) : <EOL> class Meta : <EOL> allowed_methods = ( '<STR_LIT>' , ) <EOL> queryset = User . objects . all ( ) <EOL> resource_name = '<STR_LIT>' <EOL> cache = SimpleCache ( timeout = <NUM_LIT> ) <EOL> class PublicCachedUserResource ( ModelResource ) : <EOL> class Meta : <EOL> allowed_methods = ( '<STR_LIT>' , ) <EOL> queryset = User . objects . all ( ) <EOL> resource_name = '<STR_LIT>' <EOL> cache = SimpleCache ( timeout = <NUM_LIT> , public = True ) <EOL> class CacheDisabledUserResource ( ModelResource ) : <EOL> class Meta : <EOL> allowed_methods = ( '<STR_LIT>' , ) <EOL> queryset = User . objects . all ( ) <EOL> resource_name = '<STR_LIT>' <EOL> cache = SimpleCache ( timeout = <NUM_LIT:0> ) <EOL>"}
{"rec_id": "7940", "recitation_code": "expect3 = \" \" \" \" \" \"", "input_code_id": 7940, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import TestGyp <EOL> test = TestGyp . TestGyp ( ) <EOL> test . run_gyp ( '<STR_LIT>' , chdir = '<STR_LIT:src>' ) <EOL> test . relocate ( '<STR_LIT:src>' , '<STR_LIT>' ) <EOL> test . build ( '<STR_LIT>' , chdir = '<STR_LIT>' ) <EOL> expect1 = \"\"\"<STR_LIT>\"\"\" <EOL> expect2 = \"\"\"<STR_LIT>\"\"\" <EOL>"}
{"rec_id": "7940", "recitation_code": "expect3 = \" \" \" \" \" \"", "input_code_id": 63021, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import TestGyp <EOL> test = TestGyp . TestGyp ( ) <EOL> test . run_gyp ( '<STR_LIT>' , chdir = '<STR_LIT:src>' ) <EOL> test . relocate ( '<STR_LIT:src>' , '<STR_LIT>' ) <EOL> test . build ( '<STR_LIT>' , test . ALL , chdir = '<STR_LIT>' ) <EOL> expect1 = \"\"\"<STR_LIT>\"\"\" <EOL> expect2 = \"\"\"<STR_LIT>\"\"\" <EOL>"}
{"rec_id": "7977", "recitation_code": "open mock . assert called once with ( ' ' , ' r ' )", "input_code_id": 7977, "input": "<s> from test import CollectorTestCase <EOL> from test import get_collector_config <EOL> from test import unittest <EOL> from mock import Mock <EOL> from mock import patch <EOL> try : <EOL> from cStringIO import StringIO <EOL> except ImportError : <EOL> from StringIO import StringIO <EOL> from diamond . collector import Collector <EOL> from proc import ProcessStatCollector <EOL> class TestProcessStatCollector ( CollectorTestCase ) : <EOL> def setUp ( self ) : <EOL> config = get_collector_config ( '<STR_LIT>' , { <EOL> '<STR_LIT>' : <NUM_LIT:1> <EOL> } ) <EOL> self . collector = ProcessStatCollector ( config , None ) <EOL> def test_import ( self ) : <EOL> self . assertTrue ( ProcessStatCollector ) <EOL> @ patch ( '<STR_LIT>' ) <EOL> @ patch ( '<STR_LIT>' , Mock ( return_value = True ) ) <EOL> @ patch . object ( Collector , '<STR_LIT>' ) <EOL> def test_should_open_proc_stat ( self , publish_mock , open_mock ) : <EOL> open_mock . return_value = StringIO ( '<STR_LIT>' ) <EOL> self . collector . collect ( ) <EOL>"}
{"rec_id": "7977", "recitation_code": "open mock . assert called once with ( ' ' , ' r ' )", "input_code_id": 8230, "input": "<s> from test import CollectorTestCase <EOL> from test import get_collector_config <EOL> from test import unittest <EOL> from mock import Mock <EOL> from mock import patch <EOL> try : <EOL> from cStringIO import StringIO <EOL> except ImportError : <EOL> from StringIO import StringIO <EOL> from diamond . collector import Collector <EOL> from proc import ProcessStatCollector <EOL> class TestProcessStatCollector ( CollectorTestCase ) : <EOL> def setUp ( self ) : <EOL> config = get_collector_config ( '<STR_LIT>' , { <EOL> '<STR_LIT>' : <NUM_LIT:1> <EOL> } ) <EOL> self . collector = ProcessStatCollector ( config , None ) <EOL> def test_import ( self ) : <EOL> self . assertTrue ( ProcessStatCollector ) <EOL> @ patch ( '<STR_LIT>' ) <EOL> @ patch ( '<STR_LIT>' , Mock ( return_value = True ) ) <EOL> @ patch . object ( Collector , '<STR_LIT>' ) <EOL> def test_should_open_proc_stat ( self , publish_mock , open_mock ) : <EOL> open_mock . return_value = StringIO ( '<STR_LIT>' ) <EOL> self . collector . collect ( ) <EOL>"}
{"rec_id": "7977", "recitation_code": "open mock . assert called once with ( ' ' , ' r ' )", "input_code_id": 39069, "input": "<s> from test import CollectorTestCase <EOL> from test import get_collector_config <EOL> from test import unittest <EOL> from mock import Mock <EOL> from mock import patch <EOL> try : <EOL> from cStringIO import StringIO <EOL> except ImportError : <EOL> from StringIO import StringIO <EOL> from diamond . collector import Collector <EOL> from memory import MemoryCollector <EOL> class TestMemoryCollector ( CollectorTestCase ) : <EOL> def setUp ( self ) : <EOL> config = get_collector_config ( '<STR_LIT>' , { <EOL> '<STR_LIT>' : <NUM_LIT:10> , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } ) <EOL> self . collector = MemoryCollector ( config , None ) <EOL> def test_import ( self ) : <EOL> self . assertTrue ( MemoryCollector ) <EOL> @ patch ( '<STR_LIT>' ) <EOL> @ patch ( '<STR_LIT>' , Mock ( return_value = True ) ) <EOL> @ patch . object ( Collector , '<STR_LIT>' ) <EOL> def test_should_open_proc_meminfo ( self , publish_mock , open_mock ) : <EOL> open_mock . return_value = StringIO ( '<STR_LIT>' ) <EOL> self . collector . collect ( ) <EOL>"}
{"rec_id": "8133", "recitation_code": "o2 = Constant ( NoneTypeT ( ) , None , name = ' ' )", "input_code_id": 8133, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import theano <EOL> from theano . gof import Constant <EOL> from theano . tensor . type_other import MakeSlice , make_slice , NoneTypeT , NoneConst <EOL> def test_make_slice_merge ( ) : <EOL> i = theano . tensor . iscalar ( ) <EOL> s1 = make_slice ( <NUM_LIT:0> , i ) <EOL> s2 = make_slice ( <NUM_LIT:0> , i ) <EOL> f = theano . function ( [ i ] , [ s1 , s2 ] ) <EOL> nodes = f . maker . fgraph . apply_nodes <EOL> assert len ( [ n for n in nodes if isinstance ( n . op , MakeSlice ) ] ) == <NUM_LIT:1> <EOL> theano . printing . debugprint ( f ) <EOL> def test_none_Constant ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> o1 = Constant ( NoneTypeT ( ) , None , name = '<STR_LIT>' ) <EOL>"}
{"rec_id": "8133", "recitation_code": "o2 = Constant ( NoneTypeT ( ) , None , name = ' ' )", "input_code_id": 42611, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import , print_function , division <EOL> import theano <EOL> from theano . gof import Constant <EOL> from theano . tensor . type_other import MakeSlice , make_slice , NoneTypeT , NoneConst <EOL> def test_make_slice_merge ( ) : <EOL> i = theano . tensor . iscalar ( ) <EOL> s1 = make_slice ( <NUM_LIT:0> , i ) <EOL> s2 = make_slice ( <NUM_LIT:0> , i ) <EOL> f = theano . function ( [ i ] , [ s1 , s2 ] ) <EOL> nodes = f . maker . fgraph . apply_nodes <EOL> assert len ( [ n for n in nodes if isinstance ( n . op , MakeSlice ) ] ) == <NUM_LIT:1> <EOL> theano . printing . debugprint ( f ) <EOL> def test_none_Constant ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> o1 = Constant ( NoneTypeT ( ) , None , name = '<STR_LIT>' ) <EOL>"}
{"rec_id": "8134", "recitation_code": "self . vao . unbind ( )", "input_code_id": 8134, "input": "<s> import textwrap <EOL> import numpy <EOL> from OpenGL import GL <EOL> from pygly . shader import Shader , VertexShader , FragmentShader , ShaderProgram <EOL> from pygly . vertex_buffer import VertexBuffer , BufferAttributes , GenericAttribute , VertexAttribute , TextureCoordAttribute <EOL> from pygly . vertex_array import VertexArray <EOL> from pyrr import geometry <EOL> vertices , indices = geometry . create_quad ( scale = ( <NUM_LIT> , <NUM_LIT> ) , st = True , dtype = '<STR_LIT>' ) <EOL> vertices = vertices [ indices ] <EOL> vertices . dtype = [ <EOL> ( '<STR_LIT>' , '<STR_LIT>' , ( <NUM_LIT:3> , ) ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' , ( <NUM_LIT:2> , ) ) , <EOL> ] <EOL> def create ( core_profile = True ) : <EOL> if core_profile : <EOL> return CoreQuad ( ) <EOL> else : <EOL> return LegacyQuad ( ) <EOL> class CoreQuad ( object ) : <EOL> vertex_shader = textwrap . dedent ( \"\"\"<STR_LIT>\"\"\" ) <EOL> fragment_shader = textwrap . dedent ( \"\"\"<STR_LIT>\"\"\" ) <EOL> def __init__ ( self ) : <EOL> super ( CoreQuad , self ) . __init__ ( ) <EOL> global vertices <EOL> self . shader = ShaderProgram ( <EOL> VertexShader ( self . vertex_shader ) , <EOL> FragmentShader ( self . fragment_shader ) <EOL> ) <EOL> self . buffer = VertexBuffer ( <EOL> GL . GL_ARRAY_BUFFER , <EOL> GL . GL_STATIC_DRAW , <EOL> data = vertices , <EOL> ) <EOL> self . buffer_attributes = BufferAttributes ( ) <EOL> self . buffer_attributes [ '<STR_LIT>' ] = GenericAttribute . from_dtype ( <EOL> self . buffer , <EOL> vertices . dtype , <EOL> '<STR_LIT>' , <EOL> location = self . shader . attributes [ '<STR_LIT>' ] <EOL> ) <EOL> self . buffer_attributes [ '<STR_LIT>' ] = GenericAttribute . from_dtype ( <EOL> self . buffer , <EOL> vertices . dtype , <EOL> '<STR_LIT>' , <EOL> location = self . shader . attributes [ '<STR_LIT>' ] <EOL> ) <EOL> self . vao = VertexArray ( ) <EOL> self . vao . bind ( ) <EOL> self . buffer . bind ( ) <EOL> self . buffer_attributes . set ( ) <EOL> self . buffer . unbind ( ) <EOL>"}
{"rec_id": "8134", "recitation_code": "self . vao . unbind ( )", "input_code_id": 83431, "input": "<s> import textwrap <EOL> import numpy <EOL> from OpenGL import GL <EOL> from pygly . shader import Shader , VertexShader , FragmentShader , ShaderProgram <EOL> from pygly . vertex_buffer import VertexBuffer , BufferAttributes , GenericAttribute , VertexAttribute <EOL> from pygly . vertex_array import VertexArray <EOL> from pyrr import geometry <EOL> vertices , indices = geometry . create_cube ( scale = ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) , dtype = '<STR_LIT>' ) <EOL> vertices = vertices [ indices ] <EOL> vertices . dtype = [ ( '<STR_LIT>' , '<STR_LIT>' , ( <NUM_LIT:3> , ) ) , ] <EOL> def create ( core_profile = True ) : <EOL> if core_profile : <EOL> return CoreColourCube ( ) <EOL> else : <EOL> return LegacyColourCube ( ) <EOL> class CoreColourCube ( object ) : <EOL> vertex_shader = textwrap . dedent ( \"\"\"<STR_LIT>\"\"\" ) <EOL> fragment_shader = textwrap . dedent ( \"\"\"<STR_LIT>\"\"\" ) <EOL> def __init__ ( self ) : <EOL> super ( CoreColourCube , self ) . __init__ ( ) <EOL> global vertices <EOL> self . shader = ShaderProgram ( <EOL> VertexShader ( self . vertex_shader ) , <EOL> FragmentShader ( self . fragment_shader ) <EOL> ) <EOL> self . buffer = VertexBuffer ( <EOL> GL . GL_ARRAY_BUFFER , <EOL> GL . GL_STATIC_DRAW , <EOL> data = vertices , <EOL> ) <EOL> self . buffer_attributes = BufferAttributes ( ) <EOL> self . buffer_attributes [ '<STR_LIT>' ] = GenericAttribute . from_dtype ( <EOL> self . buffer , <EOL> vertices . dtype , <EOL> '<STR_LIT>' , <EOL> location = self . shader . attributes [ '<STR_LIT>' ] <EOL> ) <EOL> self . vao = VertexArray ( ) <EOL> self . vao . bind ( ) <EOL> self . buffer . bind ( ) <EOL> self . buffer_attributes . set ( ) <EOL> self . buffer . unbind ( ) <EOL> self . vao . unbind ( ) <EOL>"}
{"rec_id": "8240", "recitation_code": "with self . temporary workdir ( ) as workdir :", "input_code_id": 8240, "input": "<s> from __future__ import ( absolute_import , division , generators , nested_scopes , print_function , <EOL> unicode_literals , with_statement ) <EOL> import os <EOL> import time <EOL> from pants_test . pants_run_integration_test import PantsRunIntegrationTest <EOL> class ExportClasspathIntegrationTest ( PantsRunIntegrationTest ) : <EOL> def test_export_manifest_jar ( self ) : <EOL> ctimes = [ ] <EOL> manifest_jar_path = \"<STR_LIT>\" <EOL>"}
{"rec_id": "8240", "recitation_code": "with self . temporary workdir ( ) as workdir :", "input_code_id": 18105, "input": "<s> from __future__ import ( absolute_import , division , generators , nested_scopes , print_function , <EOL> unicode_literals , with_statement ) <EOL> import os <EOL> from textwrap import dedent <EOL> from twitter . common . collections import OrderedSet <EOL> from pants . backend . codegen . register import build_file_aliases as register_codegen <EOL> from pants . backend . codegen . tasks . protobuf_gen import ProtobufGen <EOL> from pants . backend . jvm . register import build_file_aliases as register_jvm <EOL> from pants . build_graph . register import build_file_aliases as register_core <EOL> from pants_test . tasks . task_test_base import TaskTestBase <EOL> class ProtobufGenTest ( TaskTestBase ) : <EOL> def setUp ( self ) : <EOL> super ( ProtobufGenTest , self ) . setUp ( ) <EOL> self . set_options ( pants_bootstrapdir = '<STR_LIT>' , <EOL> max_subprocess_args = <NUM_LIT:100> , <EOL> pants_support_fetch_timeout_secs = <NUM_LIT:1> , <EOL> pants_support_baseurls = [ '<STR_LIT>' ] ) <EOL> @ classmethod <EOL> def task_type ( cls ) : <EOL> return ProtobufGen <EOL> @ property <EOL> def alias_groups ( self ) : <EOL> return register_core ( ) . merge ( register_jvm ( ) ) . merge ( register_codegen ( ) ) <EOL> def test_protos_extracted_under_build_root ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> extracted_source_path = os . path . join ( self . build_root , '<STR_LIT>' , '<STR_LIT:src>' , '<STR_LIT>' ) <EOL> sample_proto_path = os . path . join ( extracted_source_path , '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . create_file ( sample_proto_path , dedent ( \"\"\"<STR_LIT>\"\"\" ) ) <EOL> self . add_to_build_file ( '<STR_LIT>' , dedent ( \"\"\"<STR_LIT>\"\"\" ) . format ( sample_proto_path = sample_proto_path ) ) <EOL> self . add_to_build_file ( '<STR_LIT>' , dedent ( \"\"\"<STR_LIT>\"\"\" ) . format ( sample_proto_path = sample_proto_path ) ) <EOL> target = self . target ( '<STR_LIT>' ) <EOL>"}
{"rec_id": "8297", "recitation_code": "Name . Constant : RED ,", "input_code_id": 8297, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from pygments . style import Style <EOL> from pygments . token import Keyword , Name , Comment , String , Error , Text , Number , Operator , Generic , Whitespace , Punctuation , Other , Literal <EOL> BACKGROUND = \"<STR_LIT>\" <EOL> CURRENT_LINE = \"<STR_LIT>\" <EOL> SELECTION = \"<STR_LIT>\" <EOL> FOREGROUND = \"<STR_LIT>\" <EOL> COMMENT = \"<STR_LIT>\" <EOL> RED = \"<STR_LIT>\" <EOL> ORANGE = \"<STR_LIT>\" <EOL> YELLOW = \"<STR_LIT>\" <EOL> GREEN = \"<STR_LIT>\" <EOL> AQUA = \"<STR_LIT>\" <EOL> BLUE = \"<STR_LIT>\" <EOL> PURPLE = \"<STR_LIT>\" <EOL> class base16_railscasts_dark ( Style ) : <EOL> default_style = '<STR_LIT>' <EOL> background_color = BACKGROUND <EOL> highlight_color = SELECTION <EOL> background_color = BACKGROUND <EOL> highlight_color = SELECTION <EOL> styles = { <EOL> Text : FOREGROUND , <EOL> Whitespace : \"<STR_LIT>\" , <EOL> Error : RED , <EOL> Other : \"<STR_LIT>\" , <EOL> Comment : COMMENT , <EOL> Comment . Multiline : \"<STR_LIT>\" , <EOL> Comment . Preproc : \"<STR_LIT>\" , <EOL> Comment . Single : \"<STR_LIT>\" , <EOL> Comment . Special : \"<STR_LIT>\" , <EOL> Keyword : PURPLE , <EOL> Keyword . Constant : \"<STR_LIT>\" , <EOL> Keyword . Declaration : \"<STR_LIT>\" , <EOL> Keyword . Namespace : AQUA , <EOL> Keyword . Pseudo : \"<STR_LIT>\" , <EOL> Keyword . Reserved : \"<STR_LIT>\" , <EOL> Keyword . Type : YELLOW , <EOL> Operator : AQUA , <EOL> Operator . Word : \"<STR_LIT>\" , <EOL> Punctuation : FOREGROUND , <EOL> Name : FOREGROUND , <EOL> Name . Attribute : BLUE , <EOL> Name . Builtin : \"<STR_LIT>\" , <EOL> Name . Builtin . Pseudo : \"<STR_LIT>\" , <EOL> Name . Class : YELLOW , <EOL>"}
{"rec_id": "8297", "recitation_code": "Name . Constant : RED ,", "input_code_id": 5518, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from pygments . style import Style <EOL> from pygments . token import Keyword , Name , Comment , String , Error , Text , Number , Operator , Generic , Whitespace , Punctuation , Other , Literal <EOL> BACKGROUND = \"<STR_LIT>\" <EOL> CURRENT_LINE = \"<STR_LIT>\" <EOL> SELECTION = \"<STR_LIT>\" <EOL> FOREGROUND = \"<STR_LIT>\" <EOL> COMMENT = \"<STR_LIT>\" <EOL> RED = \"<STR_LIT>\" <EOL> ORANGE = \"<STR_LIT>\" <EOL> YELLOW = \"<STR_LIT>\" <EOL> GREEN = \"<STR_LIT>\" <EOL> AQUA = \"<STR_LIT>\" <EOL> BLUE = \"<STR_LIT>\" <EOL> PURPLE = \"<STR_LIT>\" <EOL> class base16_mocha_light ( Style ) : <EOL> default_style = '<STR_LIT>' <EOL> background_color = BACKGROUND <EOL> highlight_color = SELECTION <EOL> background_color = BACKGROUND <EOL> highlight_color = SELECTION <EOL> styles = { <EOL> Text : FOREGROUND , <EOL> Whitespace : \"<STR_LIT>\" , <EOL> Error : RED , <EOL> Other : \"<STR_LIT>\" , <EOL> Comment : COMMENT , <EOL> Comment . Multiline : \"<STR_LIT>\" , <EOL> Comment . Preproc : \"<STR_LIT>\" , <EOL> Comment . Single : \"<STR_LIT>\" , <EOL> Comment . Special : \"<STR_LIT>\" , <EOL> Keyword : PURPLE , <EOL> Keyword . Constant : \"<STR_LIT>\" , <EOL> Keyword . Declaration : \"<STR_LIT>\" , <EOL> Keyword . Namespace : AQUA , <EOL> Keyword . Pseudo : \"<STR_LIT>\" , <EOL> Keyword . Reserved : \"<STR_LIT>\" , <EOL> Keyword . Type : YELLOW , <EOL> Operator : AQUA , <EOL> Operator . Word : \"<STR_LIT>\" , <EOL> Punctuation : FOREGROUND , <EOL> Name : FOREGROUND , <EOL> Name . Attribute : BLUE , <EOL> Name . Builtin : \"<STR_LIT>\" , <EOL> Name . Builtin . Pseudo : \"<STR_LIT>\" , <EOL> Name . Class : YELLOW , <EOL>"}
{"rec_id": "8297", "recitation_code": "Name . Constant : RED ,", "input_code_id": 15807, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from pygments . style import Style <EOL> from pygments . token import Keyword , Name , Comment , String , Error , Text , Number , Operator , Generic , Whitespace , Punctuation , Other , Literal <EOL> BACKGROUND = \"<STR_LIT>\" <EOL> CURRENT_LINE = \"<STR_LIT>\" <EOL> SELECTION = \"<STR_LIT>\" <EOL> FOREGROUND = \"<STR_LIT>\" <EOL> COMMENT = \"<STR_LIT>\" <EOL> RED = \"<STR_LIT>\" <EOL> ORANGE = \"<STR_LIT>\" <EOL> YELLOW = \"<STR_LIT>\" <EOL> GREEN = \"<STR_LIT>\" <EOL> AQUA = \"<STR_LIT>\" <EOL> BLUE = \"<STR_LIT>\" <EOL> PURPLE = \"<STR_LIT>\" <EOL> class base16_chalk_dark ( Style ) : <EOL> default_style = '<STR_LIT>' <EOL> background_color = BACKGROUND <EOL> highlight_color = SELECTION <EOL> background_color = BACKGROUND <EOL> highlight_color = SELECTION <EOL> styles = { <EOL> Text : FOREGROUND , <EOL> Whitespace : \"<STR_LIT>\" , <EOL> Error : RED , <EOL> Other : \"<STR_LIT>\" , <EOL> Comment : COMMENT , <EOL> Comment . Multiline : \"<STR_LIT>\" , <EOL> Comment . Preproc : \"<STR_LIT>\" , <EOL> Comment . Single : \"<STR_LIT>\" , <EOL> Comment . Special : \"<STR_LIT>\" , <EOL> Keyword : PURPLE , <EOL> Keyword . Constant : \"<STR_LIT>\" , <EOL> Keyword . Declaration : \"<STR_LIT>\" , <EOL> Keyword . Namespace : AQUA , <EOL> Keyword . Pseudo : \"<STR_LIT>\" , <EOL> Keyword . Reserved : \"<STR_LIT>\" , <EOL> Keyword . Type : YELLOW , <EOL> Operator : AQUA , <EOL> Operator . Word : \"<STR_LIT>\" , <EOL> Punctuation : FOREGROUND , <EOL> Name : FOREGROUND , <EOL> Name . Attribute : BLUE , <EOL> Name . Builtin : \"<STR_LIT>\" , <EOL> Name . Builtin . Pseudo : \"<STR_LIT>\" , <EOL> Name . Class : YELLOW , <EOL>"}
{"rec_id": "8297", "recitation_code": "Name . Constant : RED ,", "input_code_id": 26021, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from pygments . style import Style <EOL> from pygments . token import Keyword , Name , Comment , String , Error , Text , Number , Operator , Generic , Whitespace , Punctuation , Other , Literal <EOL> BACKGROUND = \"<STR_LIT>\" <EOL> CURRENT_LINE = \"<STR_LIT>\" <EOL> SELECTION = \"<STR_LIT>\" <EOL> FOREGROUND = \"<STR_LIT>\" <EOL> COMMENT = \"<STR_LIT>\" <EOL> RED = \"<STR_LIT>\" <EOL> ORANGE = \"<STR_LIT>\" <EOL> YELLOW = \"<STR_LIT>\" <EOL> GREEN = \"<STR_LIT>\" <EOL> AQUA = \"<STR_LIT>\" <EOL> BLUE = \"<STR_LIT>\" <EOL> PURPLE = \"<STR_LIT>\" <EOL> class base16_applepips_light ( Style ) : <EOL> default_style = '<STR_LIT>' <EOL> background_color = BACKGROUND <EOL> highlight_color = SELECTION <EOL> background_color = BACKGROUND <EOL> highlight_color = SELECTION <EOL> styles = { <EOL> Text : FOREGROUND , <EOL> Whitespace : \"<STR_LIT>\" , <EOL> Error : RED , <EOL> Other : \"<STR_LIT>\" , <EOL> Comment : COMMENT , <EOL> Comment . Multiline : \"<STR_LIT>\" , <EOL> Comment . Preproc : \"<STR_LIT>\" , <EOL> Comment . Single : \"<STR_LIT>\" , <EOL> Comment . Special : \"<STR_LIT>\" , <EOL> Keyword : PURPLE , <EOL> Keyword . Constant : \"<STR_LIT>\" , <EOL> Keyword . Declaration : \"<STR_LIT>\" , <EOL> Keyword . Namespace : AQUA , <EOL> Keyword . Pseudo : \"<STR_LIT>\" , <EOL> Keyword . Reserved : \"<STR_LIT>\" , <EOL> Keyword . Type : YELLOW , <EOL> Operator : AQUA , <EOL> Operator . Word : \"<STR_LIT>\" , <EOL> Punctuation : FOREGROUND , <EOL> Name : FOREGROUND , <EOL> Name . Attribute : BLUE , <EOL> Name . Builtin : \"<STR_LIT>\" , <EOL> Name . Builtin . Pseudo : \"<STR_LIT>\" , <EOL> Name . Class : YELLOW , <EOL>"}
{"rec_id": "8297", "recitation_code": "Name . Constant : RED ,", "input_code_id": 36318, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from pygments . style import Style <EOL> from pygments . token import Keyword , Name , Comment , String , Error , Text , Number , Operator , Generic , Whitespace , Punctuation , Other , Literal <EOL> BACKGROUND = \"<STR_LIT>\" <EOL> CURRENT_LINE = \"<STR_LIT>\" <EOL> SELECTION = \"<STR_LIT>\" <EOL> FOREGROUND = \"<STR_LIT>\" <EOL> COMMENT = \"<STR_LIT>\" <EOL> RED = \"<STR_LIT>\" <EOL> ORANGE = \"<STR_LIT>\" <EOL> YELLOW = \"<STR_LIT>\" <EOL> GREEN = \"<STR_LIT>\" <EOL> AQUA = \"<STR_LIT>\" <EOL> BLUE = \"<STR_LIT>\" <EOL> PURPLE = \"<STR_LIT>\" <EOL> class base16_eighties_dark ( Style ) : <EOL> default_style = '<STR_LIT>' <EOL> background_color = BACKGROUND <EOL> highlight_color = SELECTION <EOL> background_color = BACKGROUND <EOL> highlight_color = SELECTION <EOL> styles = { <EOL> Text : FOREGROUND , <EOL> Whitespace : \"<STR_LIT>\" , <EOL> Error : RED , <EOL> Other : \"<STR_LIT>\" , <EOL> Comment : COMMENT , <EOL> Comment . Multiline : \"<STR_LIT>\" , <EOL> Comment . Preproc : \"<STR_LIT>\" , <EOL> Comment . Single : \"<STR_LIT>\" , <EOL> Comment . Special : \"<STR_LIT>\" , <EOL> Keyword : PURPLE , <EOL> Keyword . Constant : \"<STR_LIT>\" , <EOL> Keyword . Declaration : \"<STR_LIT>\" , <EOL> Keyword . Namespace : AQUA , <EOL> Keyword . Pseudo : \"<STR_LIT>\" , <EOL> Keyword . Reserved : \"<STR_LIT>\" , <EOL> Keyword . Type : YELLOW , <EOL> Operator : AQUA , <EOL> Operator . Word : \"<STR_LIT>\" , <EOL> Punctuation : FOREGROUND , <EOL> Name : FOREGROUND , <EOL> Name . Attribute : BLUE , <EOL> Name . Builtin : \"<STR_LIT>\" , <EOL> Name . Builtin . Pseudo : \"<STR_LIT>\" , <EOL> Name . Class : YELLOW , <EOL>"}
{"rec_id": "8297", "recitation_code": "Name . Constant : RED ,", "input_code_id": 46517, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from pygments . style import Style <EOL> from pygments . token import Keyword , Name , Comment , String , Error , Text , Number , Operator , Generic , Whitespace , Punctuation , Other , Literal <EOL> BACKGROUND = \"<STR_LIT>\" <EOL> CURRENT_LINE = \"<STR_LIT>\" <EOL> SELECTION = \"<STR_LIT>\" <EOL> FOREGROUND = \"<STR_LIT>\" <EOL> COMMENT = \"<STR_LIT>\" <EOL> RED = \"<STR_LIT>\" <EOL> ORANGE = \"<STR_LIT>\" <EOL> YELLOW = \"<STR_LIT>\" <EOL> GREEN = \"<STR_LIT>\" <EOL> AQUA = \"<STR_LIT>\" <EOL> BLUE = \"<STR_LIT>\" <EOL> PURPLE = \"<STR_LIT>\" <EOL> class base16_chalk_light ( Style ) : <EOL> default_style = '<STR_LIT>' <EOL> background_color = BACKGROUND <EOL> highlight_color = SELECTION <EOL> background_color = BACKGROUND <EOL> highlight_color = SELECTION <EOL> styles = { <EOL> Text : FOREGROUND , <EOL> Whitespace : \"<STR_LIT>\" , <EOL> Error : RED , <EOL> Other : \"<STR_LIT>\" , <EOL> Comment : COMMENT , <EOL> Comment . Multiline : \"<STR_LIT>\" , <EOL> Comment . Preproc : \"<STR_LIT>\" , <EOL> Comment . Single : \"<STR_LIT>\" , <EOL> Comment . Special : \"<STR_LIT>\" , <EOL> Keyword : PURPLE , <EOL> Keyword . Constant : \"<STR_LIT>\" , <EOL> Keyword . Declaration : \"<STR_LIT>\" , <EOL> Keyword . Namespace : AQUA , <EOL> Keyword . Pseudo : \"<STR_LIT>\" , <EOL> Keyword . Reserved : \"<STR_LIT>\" , <EOL> Keyword . Type : YELLOW , <EOL> Operator : AQUA , <EOL> Operator . Word : \"<STR_LIT>\" , <EOL> Punctuation : FOREGROUND , <EOL> Name : FOREGROUND , <EOL> Name . Attribute : BLUE , <EOL> Name . Builtin : \"<STR_LIT>\" , <EOL> Name . Builtin . Pseudo : \"<STR_LIT>\" , <EOL> Name . Class : YELLOW , <EOL>"}
{"rec_id": "8297", "recitation_code": "Name . Constant : RED ,", "input_code_id": 56540, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from pygments . style import Style <EOL> from pygments . token import Keyword , Name , Comment , String , Error , Text , Number , Operator , Generic , Whitespace , Punctuation , Other , Literal <EOL> BACKGROUND = \"<STR_LIT>\" <EOL> CURRENT_LINE = \"<STR_LIT>\" <EOL> SELECTION = \"<STR_LIT>\" <EOL> FOREGROUND = \"<STR_LIT>\" <EOL> COMMENT = \"<STR_LIT>\" <EOL> RED = \"<STR_LIT>\" <EOL> ORANGE = \"<STR_LIT>\" <EOL> YELLOW = \"<STR_LIT>\" <EOL> GREEN = \"<STR_LIT>\" <EOL> AQUA = \"<STR_LIT>\" <EOL> BLUE = \"<STR_LIT>\" <EOL> PURPLE = \"<STR_LIT>\" <EOL> class base16_mocha_dark ( Style ) : <EOL> default_style = '<STR_LIT>' <EOL> background_color = BACKGROUND <EOL> highlight_color = SELECTION <EOL> background_color = BACKGROUND <EOL> highlight_color = SELECTION <EOL> styles = { <EOL> Text : FOREGROUND , <EOL> Whitespace : \"<STR_LIT>\" , <EOL> Error : RED , <EOL> Other : \"<STR_LIT>\" , <EOL> Comment : COMMENT , <EOL> Comment . Multiline : \"<STR_LIT>\" , <EOL> Comment . Preproc : \"<STR_LIT>\" , <EOL> Comment . Single : \"<STR_LIT>\" , <EOL> Comment . Special : \"<STR_LIT>\" , <EOL> Keyword : PURPLE , <EOL> Keyword . Constant : \"<STR_LIT>\" , <EOL> Keyword . Declaration : \"<STR_LIT>\" , <EOL> Keyword . Namespace : AQUA , <EOL> Keyword . Pseudo : \"<STR_LIT>\" , <EOL> Keyword . Reserved : \"<STR_LIT>\" , <EOL> Keyword . Type : YELLOW , <EOL> Operator : AQUA , <EOL> Operator . Word : \"<STR_LIT>\" , <EOL> Punctuation : FOREGROUND , <EOL> Name : FOREGROUND , <EOL> Name . Attribute : BLUE , <EOL> Name . Builtin : \"<STR_LIT>\" , <EOL> Name . Builtin . Pseudo : \"<STR_LIT>\" , <EOL> Name . Class : YELLOW , <EOL>"}
{"rec_id": "8297", "recitation_code": "Name . Constant : RED ,", "input_code_id": 66770, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from pygments . style import Style <EOL> from pygments . token import Keyword , Name , Comment , String , Error , Text , Number , Operator , Generic , Whitespace , Punctuation , Other , Literal <EOL> BACKGROUND = \"<STR_LIT>\" <EOL> CURRENT_LINE = \"<STR_LIT>\" <EOL> SELECTION = \"<STR_LIT>\" <EOL> FOREGROUND = \"<STR_LIT>\" <EOL> COMMENT = \"<STR_LIT>\" <EOL> RED = \"<STR_LIT>\" <EOL> ORANGE = \"<STR_LIT>\" <EOL> YELLOW = \"<STR_LIT>\" <EOL> GREEN = \"<STR_LIT>\" <EOL> AQUA = \"<STR_LIT>\" <EOL> BLUE = \"<STR_LIT>\" <EOL> PURPLE = \"<STR_LIT>\" <EOL> class base16_ocean_light ( Style ) : <EOL> default_style = '<STR_LIT>' <EOL> background_color = BACKGROUND <EOL> highlight_color = SELECTION <EOL> background_color = BACKGROUND <EOL> highlight_color = SELECTION <EOL> styles = { <EOL> Text : FOREGROUND , <EOL> Whitespace : \"<STR_LIT>\" , <EOL> Error : RED , <EOL> Other : \"<STR_LIT>\" , <EOL> Comment : COMMENT , <EOL> Comment . Multiline : \"<STR_LIT>\" , <EOL> Comment . Preproc : \"<STR_LIT>\" , <EOL> Comment . Single : \"<STR_LIT>\" , <EOL> Comment . Special : \"<STR_LIT>\" , <EOL> Keyword : PURPLE , <EOL> Keyword . Constant : \"<STR_LIT>\" , <EOL> Keyword . Declaration : \"<STR_LIT>\" , <EOL> Keyword . Namespace : AQUA , <EOL> Keyword . Pseudo : \"<STR_LIT>\" , <EOL> Keyword . Reserved : \"<STR_LIT>\" , <EOL> Keyword . Type : YELLOW , <EOL> Operator : AQUA , <EOL> Operator . Word : \"<STR_LIT>\" , <EOL> Punctuation : FOREGROUND , <EOL> Name : FOREGROUND , <EOL> Name . Attribute : BLUE , <EOL> Name . Builtin : \"<STR_LIT>\" , <EOL> Name . Builtin . Pseudo : \"<STR_LIT>\" , <EOL> Name . Class : YELLOW , <EOL>"}
{"rec_id": "8297", "recitation_code": "Name . Constant : RED ,", "input_code_id": 76985, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from pygments . style import Style <EOL> from pygments . token import Keyword , Name , Comment , String , Error , Text , Number , Operator , Generic , Whitespace , Punctuation , Other , Literal <EOL> BACKGROUND = \"<STR_LIT>\" <EOL> CURRENT_LINE = \"<STR_LIT>\" <EOL> SELECTION = \"<STR_LIT>\" <EOL> FOREGROUND = \"<STR_LIT>\" <EOL> COMMENT = \"<STR_LIT>\" <EOL> RED = \"<STR_LIT>\" <EOL> ORANGE = \"<STR_LIT>\" <EOL> YELLOW = \"<STR_LIT>\" <EOL> GREEN = \"<STR_LIT>\" <EOL> AQUA = \"<STR_LIT>\" <EOL> BLUE = \"<STR_LIT>\" <EOL> PURPLE = \"<STR_LIT>\" <EOL> class base16_greenscreen_light ( Style ) : <EOL> default_style = '<STR_LIT>' <EOL> background_color = BACKGROUND <EOL> highlight_color = SELECTION <EOL> background_color = BACKGROUND <EOL> highlight_color = SELECTION <EOL> styles = { <EOL> Text : FOREGROUND , <EOL> Whitespace : \"<STR_LIT>\" , <EOL> Error : RED , <EOL> Other : \"<STR_LIT>\" , <EOL> Comment : COMMENT , <EOL> Comment . Multiline : \"<STR_LIT>\" , <EOL> Comment . Preproc : \"<STR_LIT>\" , <EOL> Comment . Single : \"<STR_LIT>\" , <EOL> Comment . Special : \"<STR_LIT>\" , <EOL> Keyword : PURPLE , <EOL> Keyword . Constant : \"<STR_LIT>\" , <EOL> Keyword . Declaration : \"<STR_LIT>\" , <EOL> Keyword . Namespace : AQUA , <EOL> Keyword . Pseudo : \"<STR_LIT>\" , <EOL> Keyword . Reserved : \"<STR_LIT>\" , <EOL> Keyword . Type : YELLOW , <EOL> Operator : AQUA , <EOL> Operator . Word : \"<STR_LIT>\" , <EOL> Punctuation : FOREGROUND , <EOL> Name : FOREGROUND , <EOL> Name . Attribute : BLUE , <EOL> Name . Builtin : \"<STR_LIT>\" , <EOL> Name . Builtin . Pseudo : \"<STR_LIT>\" , <EOL> Name . Class : YELLOW , <EOL>"}
{"rec_id": "8297", "recitation_code": "Name . Constant : RED ,", "input_code_id": 87190, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from pygments . style import Style <EOL> from pygments . token import Keyword , Name , Comment , String , Error , Text , Number , Operator , Generic , Whitespace , Punctuation , Other , Literal <EOL> BACKGROUND = \"<STR_LIT>\" <EOL> CURRENT_LINE = \"<STR_LIT>\" <EOL> SELECTION = \"<STR_LIT>\" <EOL> FOREGROUND = \"<STR_LIT>\" <EOL> COMMENT = \"<STR_LIT>\" <EOL> RED = \"<STR_LIT>\" <EOL> ORANGE = \"<STR_LIT>\" <EOL> YELLOW = \"<STR_LIT>\" <EOL> GREEN = \"<STR_LIT>\" <EOL> AQUA = \"<STR_LIT>\" <EOL> BLUE = \"<STR_LIT>\" <EOL> PURPLE = \"<STR_LIT>\" <EOL> class base16_3024_dark ( Style ) : <EOL> default_style = '<STR_LIT>' <EOL> background_color = BACKGROUND <EOL> highlight_color = SELECTION <EOL> background_color = BACKGROUND <EOL> highlight_color = SELECTION <EOL> styles = { <EOL> Text : FOREGROUND , <EOL> Whitespace : \"<STR_LIT>\" , <EOL> Error : RED , <EOL> Other : \"<STR_LIT>\" , <EOL> Comment : COMMENT , <EOL> Comment . Multiline : \"<STR_LIT>\" , <EOL> Comment . Preproc : \"<STR_LIT>\" , <EOL> Comment . Single : \"<STR_LIT>\" , <EOL> Comment . Special : \"<STR_LIT>\" , <EOL> Keyword : PURPLE , <EOL> Keyword . Constant : \"<STR_LIT>\" , <EOL> Keyword . Declaration : \"<STR_LIT>\" , <EOL> Keyword . Namespace : AQUA , <EOL> Keyword . Pseudo : \"<STR_LIT>\" , <EOL> Keyword . Reserved : \"<STR_LIT>\" , <EOL> Keyword . Type : YELLOW , <EOL> Operator : AQUA , <EOL> Operator . Word : \"<STR_LIT>\" , <EOL> Punctuation : FOREGROUND , <EOL> Name : FOREGROUND , <EOL> Name . Attribute : BLUE , <EOL> Name . Builtin : \"<STR_LIT>\" , <EOL> Name . Builtin . Pseudo : \"<STR_LIT>\" , <EOL> Name . Class : YELLOW , <EOL>"}
{"rec_id": "8297", "recitation_code": "Name . Constant : RED ,", "input_code_id": 87191, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from pygments . style import Style <EOL> from pygments . token import Keyword , Name , Comment , String , Error , Text , Number , Operator , Generic , Whitespace , Punctuation , Other , Literal <EOL> BACKGROUND = \"<STR_LIT>\" <EOL> CURRENT_LINE = \"<STR_LIT>\" <EOL> SELECTION = \"<STR_LIT>\" <EOL> FOREGROUND = \"<STR_LIT>\" <EOL> COMMENT = \"<STR_LIT>\" <EOL> RED = \"<STR_LIT>\" <EOL> ORANGE = \"<STR_LIT>\" <EOL> YELLOW = \"<STR_LIT>\" <EOL> GREEN = \"<STR_LIT>\" <EOL> AQUA = \"<STR_LIT>\" <EOL> BLUE = \"<STR_LIT>\" <EOL> PURPLE = \"<STR_LIT>\" <EOL> class base16_tomorrow_dark ( Style ) : <EOL> default_style = '<STR_LIT>' <EOL> background_color = BACKGROUND <EOL> highlight_color = SELECTION <EOL> background_color = BACKGROUND <EOL> highlight_color = SELECTION <EOL> styles = { <EOL> Text : FOREGROUND , <EOL> Whitespace : \"<STR_LIT>\" , <EOL> Error : RED , <EOL> Other : \"<STR_LIT>\" , <EOL> Comment : COMMENT , <EOL> Comment . Multiline : \"<STR_LIT>\" , <EOL> Comment . Preproc : \"<STR_LIT>\" , <EOL> Comment . Single : \"<STR_LIT>\" , <EOL> Comment . Special : \"<STR_LIT>\" , <EOL> Keyword : PURPLE , <EOL> Keyword . Constant : \"<STR_LIT>\" , <EOL> Keyword . Declaration : \"<STR_LIT>\" , <EOL> Keyword . Namespace : AQUA , <EOL> Keyword . Pseudo : \"<STR_LIT>\" , <EOL> Keyword . Reserved : \"<STR_LIT>\" , <EOL> Keyword . Type : YELLOW , <EOL> Operator : AQUA , <EOL> Operator . Word : \"<STR_LIT>\" , <EOL> Punctuation : FOREGROUND , <EOL> Name : FOREGROUND , <EOL> Name . Attribute : BLUE , <EOL> Name . Builtin : \"<STR_LIT>\" , <EOL> Name . Builtin . Pseudo : \"<STR_LIT>\" , <EOL> Name . Class : YELLOW , <EOL>"}
{"rec_id": "8330", "recitation_code": "text = fh . read ( )", "input_code_id": 8330, "input": "<s> import random , unittest <EOL> from ofs . remote . reststore import RESTOFS <EOL> from ofs import OFSException <EOL> from StringIO import StringIO <EOL> import os <EOL> TEST_TEXT = \"\"\"<STR_LIT>\"\"\" <EOL> BINARY_FILE_NAME = os . path . join ( os . path . dirname ( __file__ ) , '<STR_LIT>' ) <EOL> class TestRESTOFS ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . bucket_name = '<STR_LIT>' <EOL> self . host_name = '<STR_LIT>' <EOL> self . ofs = RESTOFS ( self . host_name ) <EOL> self . ofs . claim_bucket ( self . bucket_name ) <EOL> def tearDown ( self ) : <EOL> self . ofs . _del_bucket ( self . bucket_name ) <EOL> def _makefp ( self ) : <EOL> return StringIO ( TEST_TEXT ) <EOL> def test_exists ( self ) : <EOL> self . assertTrue ( self . ofs . exists ( self . bucket_name ) ) <EOL> def test_claim_bucket ( self ) : <EOL> bucket_name = '<STR_LIT>' <EOL> self . ofs . _del_bucket ( bucket_name ) <EOL> self . assertFalse ( self . ofs . exists ( bucket_name ) ) <EOL> self . assertTrue ( self . ofs . claim_bucket ( bucket_name ) ) <EOL> self . assertTrue ( self . ofs . exists ( bucket_name ) ) <EOL> self . assertFalse ( self . ofs . claim_bucket ( bucket_name ) ) <EOL> self . ofs . _del_bucket ( bucket_name ) <EOL> self . assertFalse ( self . ofs . exists ( bucket_name ) ) <EOL> def test_list_buckets ( self ) : <EOL> buckets = [ b for b in self . ofs . list_buckets ( ) ] <EOL> assert len ( buckets ) > <NUM_LIT:0> , len ( buckets ) <EOL> assert self . bucket_name in buckets , buckets <EOL> def test_stream_write_and_read ( self ) : <EOL> name = \"<STR_LIT>\" <EOL> self . ofs . put_stream ( self . bucket_name , name , self . _makefp ( ) ) <EOL> text = self . ofs . get_stream ( self . bucket_name , name ) . read ( ) <EOL> assert text == TEST_TEXT , text <EOL> text = self . ofs . get_stream ( self . bucket_name , name , as_stream = False ) <EOL> assert text == TEST_TEXT , text <EOL> def test_binary_write_and_read ( self ) : <EOL> name = \"<STR_LIT>\" <EOL> fh = file ( BINARY_FILE_NAME , '<STR_LIT:rb>' ) <EOL>"}
{"rec_id": "8330", "recitation_code": "text = fh . read ( )", "input_code_id": 28628, "input": "<s> import logging <EOL> from pdfminer . pdfinterp import PDFResourceManager , PDFPageInterpreter <EOL> from pdfminer . converter import PDFPageAggregator <EOL> from pdfminer . layout import LAParams , LTTextBox , LTTextLine , LTFigure , LTImage <EOL> from pdfminer . pdfpage import PDFPage <EOL> from pdfminer . pdfparser import PDFParser , PDFSyntaxError <EOL> from pdfminer . pdfdocument import PDFDocument <EOL> from extractors . util import safe_text , text_fragments <EOL> from extractors . tesseract import _extract_image_page <EOL> log = logging . getLogger ( __name__ ) <EOL> OCR_MIN_WIDTH = <NUM_LIT:200> <EOL> OCR_MIN_HEIGHT = <NUM_LIT:50> <EOL> def _find_objects ( objects , cls ) : <EOL> for lt_obj in objects : <EOL> if isinstance ( lt_obj , cls ) : <EOL> yield lt_obj <EOL> elif isinstance ( lt_obj , LTFigure ) : <EOL> for obj in _find_objects ( lt_obj . _objs , cls ) : <EOL> yield obj <EOL> def _convert_page ( layout , path , page_no , languages ) : <EOL> text_content = [ ] <EOL> for text_obj in _find_objects ( layout . _objs , ( LTTextBox , LTTextLine ) ) : <EOL> text_content . append ( text_obj . get_text ( ) ) <EOL> text = text_fragments ( text_content ) <EOL> if len ( text ) < <NUM_LIT:2> : <EOL> if len ( list ( _find_objects ( layout . _objs , LTImage ) ) ) : <EOL> log . debug ( \"<STR_LIT>\" , path , page_no ) <EOL> text = _extract_image_page ( path , page_no , languages ) <EOL> return text <EOL> def extract_pdf ( path , languages = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> with open ( path , '<STR_LIT:rb>' ) as fh : <EOL>"}
{"rec_id": "8330", "recitation_code": "text = fh . read ( )", "input_code_id": 40702, "input": "<s> import collections <EOL> import raco . algebra <EOL> import raco . scheme as scheme <EOL> import raco . myrial . myrial_test as myrial_test <EOL> from raco import types <EOL> class ReachableTest ( myrial_test . MyrialTestCase ) : <EOL> edge_table = collections . Counter ( [ <EOL> ( <NUM_LIT:1> , <NUM_LIT:2> ) , <EOL> ( <NUM_LIT:2> , <NUM_LIT:3> ) , <EOL> ( <NUM_LIT:3> , <NUM_LIT:4> ) , <EOL> ( <NUM_LIT:4> , <NUM_LIT:3> ) , <EOL> ( <NUM_LIT:3> , <NUM_LIT:5> ) , <EOL> ( <NUM_LIT:4> , <NUM_LIT> ) , <EOL> ( <NUM_LIT:5> , <NUM_LIT:4> ) , <EOL> ( <NUM_LIT:1> , <NUM_LIT:9> ) , <EOL> ( <NUM_LIT:7> , <NUM_LIT:1> ) , <EOL> ( <NUM_LIT:6> , <NUM_LIT:1> ) , <EOL> ( <NUM_LIT:10> , <NUM_LIT:11> ) , <EOL> ( <NUM_LIT:11> , <NUM_LIT:12> ) , <EOL> ( <NUM_LIT:12> , <NUM_LIT:10> ) , <EOL> ( <NUM_LIT> , <NUM_LIT:4> ) , <EOL> ( <NUM_LIT:10> , <NUM_LIT:1> ) ] ) <EOL> edge_schema = scheme . Scheme ( [ ( \"<STR_LIT:src>\" , types . LONG_TYPE ) , <EOL> ( \"<STR_LIT>\" , types . LONG_TYPE ) ] ) <EOL> edge_key = \"<STR_LIT>\" <EOL> def setUp ( self ) : <EOL> super ( ReachableTest , self ) . setUp ( ) <EOL> self . db . ingest ( ReachableTest . edge_key , <EOL> ReachableTest . edge_table , <EOL> ReachableTest . edge_schema ) <EOL> def test_reachable ( self ) : <EOL> with open ( '<STR_LIT>' ) as fh : <EOL>"}
{"rec_id": "8355", "recitation_code": "assert isinstance ( A . nonexistant proxy , ProxyProperty )", "input_code_id": 8355, "input": "<s> '''<STR_LIT>''' <EOL> import uuid <EOL> from python_toolbox import cute_testing <EOL> from python_toolbox . misc_tools import ProxyProperty <EOL> class Object ( object ) : <EOL> pass <EOL> def test ( ) : <EOL> class A ( object ) : <EOL> y = '<STR_LIT:y>' <EOL> def __init__ ( self ) : <EOL> self . x = '<STR_LIT:x>' <EOL> self . obj = Object ( ) <EOL> self . obj . z = '<STR_LIT:z>' <EOL> self . uuid = uuid . uuid4 ( ) <EOL> x_proxy = ProxyProperty ( '<STR_LIT>' ) <EOL> y_proxy = ProxyProperty ( <EOL> '<STR_LIT>' , <EOL> doc = '<STR_LIT>' <EOL> ) <EOL> z_proxy = ProxyProperty ( '<STR_LIT>' , doc = '<STR_LIT>' ) <EOL> uuid_proxy = ProxyProperty ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ) <EOL> nonexistant_proxy = ProxyProperty ( '<STR_LIT>' ) <EOL> assert isinstance ( A . x_proxy , ProxyProperty ) <EOL> assert isinstance ( A . y_proxy , ProxyProperty ) <EOL> assert isinstance ( A . z_proxy , ProxyProperty ) <EOL> assert isinstance ( A . uuid_proxy , ProxyProperty ) <EOL> assert isinstance ( A . nonexistant_proxy , ProxyProperty ) <EOL>"}
{"rec_id": "8355", "recitation_code": "assert isinstance ( A . nonexistant proxy , ProxyProperty )", "input_code_id": 54652, "input": "<s> '''<STR_LIT>''' <EOL> import uuid <EOL> from python_toolbox import cute_testing <EOL> from python_toolbox . misc_tools import ProxyProperty <EOL> class Object : <EOL> pass <EOL> def test ( ) : <EOL> class A : <EOL> y = '<STR_LIT:y>' <EOL> def __init__ ( self ) : <EOL> self . x = '<STR_LIT:x>' <EOL> self . obj = Object ( ) <EOL> self . obj . z = '<STR_LIT:z>' <EOL> self . uuid = uuid . uuid4 ( ) <EOL> x_proxy = ProxyProperty ( '<STR_LIT>' ) <EOL> y_proxy = ProxyProperty ( <EOL> '<STR_LIT>' , <EOL> doc = '<STR_LIT>' <EOL> ) <EOL> z_proxy = ProxyProperty ( '<STR_LIT>' , doc = '<STR_LIT>' ) <EOL> uuid_proxy = ProxyProperty ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ) <EOL> nonexistant_proxy = ProxyProperty ( '<STR_LIT>' ) <EOL> assert isinstance ( A . x_proxy , ProxyProperty ) <EOL> assert isinstance ( A . y_proxy , ProxyProperty ) <EOL> assert isinstance ( A . z_proxy , ProxyProperty ) <EOL> assert isinstance ( A . uuid_proxy , ProxyProperty ) <EOL> assert isinstance ( A . nonexistant_proxy , ProxyProperty ) <EOL>"}
{"rec_id": "8373", "recitation_code": "infile = open ( sys . argv [ 1 ] , ' rb ' )", "input_code_id": 8373, "input": "<s> r\"\"\"<STR_LIT>\"\"\" <EOL> import simplejson <EOL> def main ( ) : <EOL> import sys <EOL> if len ( sys . argv ) == <NUM_LIT:1> : <EOL> infile = sys . stdin <EOL> outfile = sys . stdout <EOL> elif len ( sys . argv ) == <NUM_LIT:2> : <EOL> infile = open ( sys . argv [ <NUM_LIT:1> ] , '<STR_LIT:rb>' ) <EOL> outfile = sys . stdout <EOL> elif len ( sys . argv ) == <NUM_LIT:3> : <EOL>"}
{"rec_id": "8373", "recitation_code": "infile = open ( sys . argv [ 1 ] , ' rb ' )", "input_code_id": 85218, "input": "<s> r\"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> import simplejson <EOL> def main ( ) : <EOL> if len ( sys . argv ) == <NUM_LIT:1> : <EOL> infile = sys . stdin <EOL> outfile = sys . stdout <EOL> elif len ( sys . argv ) == <NUM_LIT:2> : <EOL> infile = open ( sys . argv [ <NUM_LIT:1> ] , '<STR_LIT:rb>' ) <EOL> outfile = sys . stdout <EOL> elif len ( sys . argv ) == <NUM_LIT:3> : <EOL>"}
{"rec_id": "8395", "recitation_code": "self . expand = expand", "input_code_id": 8395, "input": "<s> from msrest . serialization import Model <EOL> class JobListOptions ( Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , filter = None , select = None , expand = None , max_results = None , timeout = <NUM_LIT:30> , client_request_id = None , return_client_request_id = None , ocp_date = None ) : <EOL> self . filter = filter <EOL> self . select = select <EOL>"}
{"rec_id": "8395", "recitation_code": "self . expand = expand", "input_code_id": 61523, "input": "<s> from msrest . serialization import Model <EOL> class TaskListOptions ( Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , filter = None , select = None , expand = None , max_results = None , timeout = <NUM_LIT:30> , client_request_id = None , return_client_request_id = None , ocp_date = None ) : <EOL> self . filter = filter <EOL> self . select = select <EOL>"}
{"rec_id": "8436", "recitation_code": "p = Parser ( \" \" )", "input_code_id": 8436, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from unittest import TestCase <EOL> from django . template import ( TokenParser , FilterExpression , Parser , Variable , <EOL> TemplateSyntaxError ) <EOL> class ParserTests ( TestCase ) : <EOL> def test_token_parsing ( self ) : <EOL> p = TokenParser ( \"<STR_LIT>\" ) <EOL> self . assertEqual ( p . tagname , \"<STR_LIT>\" ) <EOL> self . assertEqual ( p . value ( ) , \"<STR_LIT>\" ) <EOL> self . assertTrue ( p . more ( ) ) <EOL> self . assertEqual ( p . tag ( ) , \"<STR_LIT>\" ) <EOL> self . assertFalse ( p . more ( ) ) <EOL> p = TokenParser ( '<STR_LIT>' ) <EOL> self . assertEqual ( p . tagname , \"<STR_LIT>\" ) <EOL> self . assertEqual ( p . value ( ) , '<STR_LIT>' ) <EOL> self . assertTrue ( p . more ( ) ) <EOL> self . assertEqual ( p . tag ( ) , \"<STR_LIT>\" ) <EOL> self . assertFalse ( p . more ( ) ) <EOL> p = TokenParser ( \"<STR_LIT>\" ) <EOL> self . assertEqual ( p . tagname , \"<STR_LIT>\" ) <EOL> self . assertEqual ( p . value ( ) , \"<STR_LIT>\" ) <EOL> self . assertTrue ( p . more ( ) ) <EOL> self . assertEqual ( p . tag ( ) , \"<STR_LIT>\" ) <EOL> self . assertFalse ( p . more ( ) ) <EOL> def test_filter_parsing ( self ) : <EOL> c = { \"<STR_LIT>\" : { \"<STR_LIT>\" : u\"<STR_LIT>\" } } <EOL> p = Parser ( \"<STR_LIT>\" ) <EOL> def fe_test ( s , val ) : <EOL> self . assertEqual ( FilterExpression ( s , p ) . resolve ( c ) , val ) <EOL>"}
{"rec_id": "8436", "recitation_code": "p = Parser ( \" \" )", "input_code_id": 10495, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import unicode_literals <EOL> from django . template import ( TokenParser , FilterExpression , Parser , Variable , <EOL> TemplateSyntaxError ) <EOL> from django . utils . unittest import TestCase <EOL> class ParserTests ( TestCase ) : <EOL> def test_token_parsing ( self ) : <EOL> p = TokenParser ( \"<STR_LIT>\" ) <EOL> self . assertEqual ( p . tagname , \"<STR_LIT>\" ) <EOL> self . assertEqual ( p . value ( ) , \"<STR_LIT>\" ) <EOL> self . assertTrue ( p . more ( ) ) <EOL> self . assertEqual ( p . tag ( ) , \"<STR_LIT>\" ) <EOL> self . assertFalse ( p . more ( ) ) <EOL> p = TokenParser ( '<STR_LIT>' ) <EOL> self . assertEqual ( p . tagname , \"<STR_LIT>\" ) <EOL> self . assertEqual ( p . value ( ) , '<STR_LIT>' ) <EOL> self . assertTrue ( p . more ( ) ) <EOL> self . assertEqual ( p . tag ( ) , \"<STR_LIT>\" ) <EOL> self . assertFalse ( p . more ( ) ) <EOL> p = TokenParser ( \"<STR_LIT>\" ) <EOL> self . assertEqual ( p . tagname , \"<STR_LIT>\" ) <EOL> self . assertEqual ( p . value ( ) , \"<STR_LIT>\" ) <EOL> self . assertTrue ( p . more ( ) ) <EOL> self . assertEqual ( p . tag ( ) , \"<STR_LIT>\" ) <EOL> self . assertFalse ( p . more ( ) ) <EOL> def test_filter_parsing ( self ) : <EOL> c = { \"<STR_LIT>\" : { \"<STR_LIT>\" : \"<STR_LIT>\" } } <EOL> p = Parser ( \"<STR_LIT>\" ) <EOL> def fe_test ( s , val ) : <EOL> self . assertEqual ( FilterExpression ( s , p ) . resolve ( c ) , val ) <EOL>"}
{"rec_id": "8436", "recitation_code": "p = Parser ( \" \" )", "input_code_id": 81871, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from django . template import ( TokenParser , FilterExpression , Parser , Variable , <EOL> TemplateSyntaxError ) <EOL> from django . utils . unittest import TestCase <EOL> class ParserTests ( TestCase ) : <EOL> def test_token_parsing ( self ) : <EOL> p = TokenParser ( \"<STR_LIT>\" ) <EOL> self . assertEqual ( p . tagname , \"<STR_LIT>\" ) <EOL> self . assertEqual ( p . value ( ) , \"<STR_LIT>\" ) <EOL> self . assertTrue ( p . more ( ) ) <EOL> self . assertEqual ( p . tag ( ) , \"<STR_LIT>\" ) <EOL> self . assertFalse ( p . more ( ) ) <EOL> p = TokenParser ( '<STR_LIT>' ) <EOL> self . assertEqual ( p . tagname , \"<STR_LIT>\" ) <EOL> self . assertEqual ( p . value ( ) , '<STR_LIT>' ) <EOL> self . assertTrue ( p . more ( ) ) <EOL> self . assertEqual ( p . tag ( ) , \"<STR_LIT>\" ) <EOL> self . assertFalse ( p . more ( ) ) <EOL> p = TokenParser ( \"<STR_LIT>\" ) <EOL> self . assertEqual ( p . tagname , \"<STR_LIT>\" ) <EOL> self . assertEqual ( p . value ( ) , \"<STR_LIT>\" ) <EOL> self . assertTrue ( p . more ( ) ) <EOL> self . assertEqual ( p . tag ( ) , \"<STR_LIT>\" ) <EOL> self . assertFalse ( p . more ( ) ) <EOL> def test_filter_parsing ( self ) : <EOL> c = { \"<STR_LIT>\" : { \"<STR_LIT>\" : u\"<STR_LIT>\" } } <EOL> p = Parser ( \"<STR_LIT>\" ) <EOL> def fe_test ( s , val ) : <EOL> self . assertEqual ( FilterExpression ( s , p ) . resolve ( c ) , val ) <EOL>"}
{"rec_id": "8463", "recitation_code": "return ThreadedComment", "input_code_id": 8463, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __version__ = \"<STR_LIT>\" <EOL> def get_model ( ) : <EOL> from threadedcomments . models import ThreadedComment <EOL>"}
{"rec_id": "8463", "recitation_code": "return ThreadedComment", "input_code_id": 29844, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import unicode_literals <EOL> def get_model ( ) : <EOL> from mezzanine . generic . models import ThreadedComment <EOL>"}
{"rec_id": "8497", "recitation_code": "return criteria", "input_code_id": 16, "input": "<s> from django . contrib . contenttypes . models import ContentType <EOL> from lfs . core . utils import import_symbol <EOL> class Criteria ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def is_valid ( self , request , product = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for criterion in self . get_criteria ( ) : <EOL> criterion . request = request <EOL> criterion . product = product <EOL> if not criterion . is_valid ( ) : <EOL> return False <EOL> return True <EOL> def get_criteria ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> content_type = ContentType . objects . get_for_model ( self ) <EOL> criteria = [ ] <EOL> from lfs . criteria . models import Criterion <EOL> for criterion in Criterion . objects . filter ( content_id = self . id , content_type = content_type ) : <EOL> criteria . append ( criterion . get_content_object ( ) ) <EOL>"}
{"rec_id": "8497", "recitation_code": "return criteria", "input_code_id": 8497, "input": "<s> from braintree . credit_card_verification import CreditCardVerification <EOL> from braintree . credit_card_verification_search import CreditCardVerificationSearch <EOL> from braintree . exceptions . not_found_error import NotFoundError <EOL> from braintree . ids_search import IdsSearch <EOL> from braintree . resource_collection import ResourceCollection <EOL> from braintree . error_result import ErrorResult <EOL> from braintree . successful_result import SuccessfulResult <EOL> class CreditCardVerificationGateway ( object ) : <EOL> def __init__ ( self , gateway ) : <EOL> self . gateway = gateway <EOL> self . config = gateway . config <EOL> def find ( self , verification_id ) : <EOL> try : <EOL> if verification_id is None or verification_id . strip ( ) == \"<STR_LIT>\" : <EOL> raise NotFoundError ( ) <EOL> response = self . config . http ( ) . get ( self . config . base_merchant_path ( ) + \"<STR_LIT>\" + verification_id ) <EOL> return CreditCardVerification ( self . gateway , response [ \"<STR_LIT>\" ] ) <EOL> except NotFoundError : <EOL> raise NotFoundError ( \"<STR_LIT>\" + repr ( verification_id ) + \"<STR_LIT>\" ) <EOL> def __criteria ( self , query ) : <EOL> criteria = { } <EOL> for term in query : <EOL> if criteria . get ( term . name ) : <EOL> criteria [ term . name ] = dict ( list ( criteria [ term . name ] . items ( ) ) + list ( term . to_param ( ) . items ( ) ) ) <EOL>"}
{"rec_id": "8611", "recitation_code": "self . experiment . state = Experiment . ENABLED STATE", "input_code_id": 8611, "input": "<s> from __future__ import with_statement <EOL> import logging <EOL> l = logging . getLogger ( __name__ ) <EOL> from datetime import timedelta <EOL> from django . conf import settings <EOL> from django . core . management . base import CommandError <EOL> from django_lean . experiments . models import ( Experiment , DailyEngagementReport , <EOL> DailyConversionReport ) <EOL> from django_lean . experiments . management . commands import ( <EOL> update_experiment_reports <EOL> ) <EOL> from django_lean . experiments . tests . utils import patch , TestCase <EOL> class TestManagement ( TestCase ) : <EOL> def setUp ( self ) : <EOL> self . experiment = Experiment ( name = \"<STR_LIT>\" ) <EOL> self . experiment . save ( ) <EOL>"}
{"rec_id": "8611", "recitation_code": "self . experiment . state = Experiment . ENABLED STATE", "input_code_id": 62357, "input": "<s> from __future__ import with_statement <EOL> import logging <EOL> l = logging . getLogger ( __name__ ) <EOL> from datetime import timedelta <EOL> from django . conf import settings <EOL> from django . core . management . base import CommandError <EOL> from easy_split . experiments . models import ( Experiment , DailyEngagementReport , <EOL> DailyConversionReport ) <EOL> from easy_split . experiments . management . commands import ( <EOL> update_experiment_reports <EOL> ) <EOL> from easy_split . experiments . tests . utils import patch , TestCase <EOL> class TestManagement ( TestCase ) : <EOL> def setUp ( self ) : <EOL> self . experiment = Experiment ( name = \"<STR_LIT>\" ) <EOL> self . experiment . save ( ) <EOL>"}
{"rec_id": "8639", "recitation_code": "def parse each field ( key , value ) :", "input_code_id": 8639, "input": "<s> import json <EOL> class PipelineDefinitionError ( Exception ) : <EOL> def __init__ ( self , msg , definition ) : <EOL> full_msg = ( <EOL> \"<STR_LIT>\" % msg ) <EOL> super ( PipelineDefinitionError , self ) . __init__ ( full_msg ) <EOL> self . msg = msg <EOL> self . definition = definition <EOL> def api_to_definition ( definition ) : <EOL> if '<STR_LIT>' in definition : <EOL> definition [ '<STR_LIT>' ] = _api_to_objects_definition ( <EOL> definition . pop ( '<STR_LIT>' ) ) <EOL> if '<STR_LIT>' in definition : <EOL> definition [ '<STR_LIT>' ] = _api_to_parameters_definition ( <EOL> definition . pop ( '<STR_LIT>' ) ) <EOL> if '<STR_LIT>' in definition : <EOL> definition [ '<STR_LIT>' ] = _api_to_values_definition ( <EOL> definition . pop ( '<STR_LIT>' ) ) <EOL> return definition <EOL> def definition_to_api_objects ( definition ) : <EOL> if '<STR_LIT>' not in definition : <EOL> raise PipelineDefinitionError ( '<STR_LIT>' , definition ) <EOL> api_elements = [ ] <EOL> for element in definition [ '<STR_LIT>' ] : <EOL> try : <EOL> element_id = element . pop ( '<STR_LIT:id>' ) <EOL> except KeyError : <EOL> raise PipelineDefinitionError ( '<STR_LIT>' % <EOL> json . dumps ( element ) , definition ) <EOL> api_object = { '<STR_LIT:id>' : element_id } <EOL> name = element . pop ( '<STR_LIT:name>' , element_id ) <EOL> api_object [ '<STR_LIT:name>' ] = name <EOL> fields = [ ] <EOL> for key , value in sorted ( element . items ( ) ) : <EOL> fields . extend ( _parse_each_field ( key , value ) ) <EOL> api_object [ '<STR_LIT>' ] = fields <EOL> api_elements . append ( api_object ) <EOL> return api_elements <EOL> def definition_to_api_parameters ( definition ) : <EOL> if '<STR_LIT>' not in definition : <EOL> return None <EOL> parameter_objects = [ ] <EOL> for element in definition [ '<STR_LIT>' ] : <EOL> try : <EOL> parameter_id = element . pop ( '<STR_LIT:id>' ) <EOL> except KeyError : <EOL> raise PipelineDefinitionError ( '<STR_LIT>' % <EOL> json . dumps ( element ) , definition ) <EOL> parameter_object = { '<STR_LIT:id>' : parameter_id } <EOL> attributes = [ ] <EOL> for key , value in sorted ( element . items ( ) ) : <EOL> attributes . extend ( _parse_each_field ( key , value ) ) <EOL> parameter_object [ '<STR_LIT>' ] = attributes <EOL> parameter_objects . append ( parameter_object ) <EOL> return parameter_objects <EOL> def definition_to_parameter_values ( definition ) : <EOL> if '<STR_LIT>' not in definition : <EOL> return None <EOL> parameter_values = [ ] <EOL> for key in definition [ '<STR_LIT>' ] : <EOL> parameter_values . extend ( <EOL> _convert_single_parameter_value ( key , definition [ '<STR_LIT>' ] [ key ] ) ) <EOL> return parameter_values <EOL>"}
{"rec_id": "8639", "recitation_code": "def parse each field ( key , value ) :", "input_code_id": 53780, "input": "<s> import json <EOL> from awscli . clidriver import CLIOperationCaller <EOL> class PipelineDefinitionError ( Exception ) : <EOL> def __init__ ( self , msg , definition ) : <EOL> full_msg = ( <EOL> \"<STR_LIT>\" % msg ) <EOL> super ( PipelineDefinitionError , self ) . __init__ ( full_msg ) <EOL> self . msg = msg <EOL> self . definition = definition <EOL> def dict_to_string ( dictionary , indent = <NUM_LIT:2> ) : <EOL> return json . dumps ( dictionary , indent = indent ) <EOL> def get_region ( session , parsed_globals ) : <EOL> region = parsed_globals . region <EOL> if region is None : <EOL> region = session . get_config_variable ( '<STR_LIT>' ) <EOL> return region <EOL> def remove_cli_error_event ( client ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> client . meta . events . unregister ( <EOL> '<STR_LIT>' , unique_id = '<STR_LIT>' ) <EOL> def display_response ( session , operation_name , result , parsed_globals ) : <EOL> cli_operation_caller = CLIOperationCaller ( session ) <EOL> cli_operation_caller . _display_response ( <EOL> operation_name , result , parsed_globals ) <EOL> def api_to_definition ( definition ) : <EOL> if '<STR_LIT>' in definition : <EOL> definition [ '<STR_LIT>' ] = _api_to_objects_definition ( <EOL> definition . pop ( '<STR_LIT>' ) ) <EOL> if '<STR_LIT>' in definition : <EOL> definition [ '<STR_LIT>' ] = _api_to_parameters_definition ( <EOL> definition . pop ( '<STR_LIT>' ) ) <EOL> if '<STR_LIT>' in definition : <EOL> definition [ '<STR_LIT>' ] = _api_to_values_definition ( <EOL> definition . pop ( '<STR_LIT>' ) ) <EOL> return definition <EOL> def definition_to_api_objects ( definition ) : <EOL> if '<STR_LIT>' not in definition : <EOL> raise PipelineDefinitionError ( '<STR_LIT>' , definition ) <EOL> api_elements = [ ] <EOL> for element in definition [ '<STR_LIT>' ] : <EOL> try : <EOL> element_id = element . pop ( '<STR_LIT:id>' ) <EOL> except KeyError : <EOL> raise PipelineDefinitionError ( '<STR_LIT>' % <EOL> json . dumps ( element ) , definition ) <EOL> api_object = { '<STR_LIT:id>' : element_id } <EOL> name = element . pop ( '<STR_LIT:name>' , element_id ) <EOL> api_object [ '<STR_LIT:name>' ] = name <EOL> fields = [ ] <EOL> for key , value in sorted ( element . items ( ) ) : <EOL> fields . extend ( _parse_each_field ( key , value ) ) <EOL> api_object [ '<STR_LIT>' ] = fields <EOL> api_elements . append ( api_object ) <EOL> return api_elements <EOL> def definition_to_api_parameters ( definition ) : <EOL> if '<STR_LIT>' not in definition : <EOL> return None <EOL> parameter_objects = [ ] <EOL> for element in definition [ '<STR_LIT>' ] : <EOL> try : <EOL> parameter_id = element . pop ( '<STR_LIT:id>' ) <EOL> except KeyError : <EOL> raise PipelineDefinitionError ( '<STR_LIT>' % <EOL> json . dumps ( element ) , definition ) <EOL> parameter_object = { '<STR_LIT:id>' : parameter_id } <EOL> attributes = [ ] <EOL> for key , value in sorted ( element . items ( ) ) : <EOL> attributes . extend ( _parse_each_field ( key , value ) ) <EOL> parameter_object [ '<STR_LIT>' ] = attributes <EOL> parameter_objects . append ( parameter_object ) <EOL> return parameter_objects <EOL>"}
{"rec_id": "8789", "recitation_code": "inModel . lowerCoefficientBounds . append ( None )", "input_code_id": 8789, "input": "<s> from __future__ import print_function <EOL> from __future__ import unicode_literals <EOL> from __future__ import absolute_import <EOL> import pyeq2 <EOL> from . import IExtendedVersionHandler <EOL> import numpy <EOL> numpy . seterr ( all = '<STR_LIT:ignore>' ) <EOL> class ExtendedVersionHandler_ExponentialGrowth ( IExtendedVersionHandler . IExtendedVersionHandler ) : <EOL> def AssembleDisplayHTML ( self , inModel ) : <EOL> x_or_xy = '<STR_LIT>' <EOL> if inModel . GetDimensionality ( ) == <NUM_LIT:2> : <EOL> x_or_xy = '<STR_LIT:x>' <EOL> if inModel . baseEquationHasGlobalMultiplierOrDivisor_UsedInExtendedVersions : <EOL> return inModel . _HTML + '<STR_LIT>' + inModel . _leftSideHTML + '<STR_LIT>' + inModel . _leftSideHTML + '<STR_LIT>' + x_or_xy + '<STR_LIT:)>' <EOL> else : <EOL> try : <EOL> cd = inModel . GetCoefficientDesignators ( ) <EOL> return inModel . _HTML + '<STR_LIT>' + inModel . _leftSideHTML + '<STR_LIT>' + inModel . _leftSideHTML + '<STR_LIT>' + cd [ - <NUM_LIT:1> ] + '<STR_LIT>' + x_or_xy + '<STR_LIT>' <EOL> except : <EOL> return inModel . _HTML + '<STR_LIT>' + inModel . _leftSideHTML + '<STR_LIT>' + inModel . _leftSideHTML + '<STR_LIT>' + x_or_xy + '<STR_LIT>' <EOL> def AssembleDisplayName ( self , inModel ) : <EOL> return inModel . _baseName + '<STR_LIT>' <EOL> def AssembleSourceCodeName ( self , inModel ) : <EOL> return inModel . __module__ . split ( '<STR_LIT:.>' ) [ - <NUM_LIT:1> ] + '<STR_LIT:_>' + inModel . __class__ . __name__ + \"<STR_LIT>\" <EOL> def AssembleCoefficientDesignators ( self , inModel ) : <EOL> if inModel . baseEquationHasGlobalMultiplierOrDivisor_UsedInExtendedVersions : <EOL> return inModel . _coefficientDesignators <EOL> else : <EOL> return inModel . _coefficientDesignators + [ inModel . listOfAdditionalCoefficientDesignators [ len ( inModel . _coefficientDesignators ) ] ] <EOL> def AppendAdditionalCoefficientBounds ( self , inModel ) : <EOL> if inModel . baseEquationHasGlobalMultiplierOrDivisor_UsedInExtendedVersions : <EOL> return <EOL> else : <EOL> if inModel . upperCoefficientBounds != [ ] : <EOL> inModel . upperCoefficientBounds . append ( None ) <EOL> if inModel . lowerCoefficientBounds != [ ] : <EOL>"}
{"rec_id": "8789", "recitation_code": "inModel . lowerCoefficientBounds . append ( None )", "input_code_id": 50985, "input": "<s> from __future__ import print_function <EOL> from __future__ import unicode_literals <EOL> from __future__ import absolute_import <EOL> import pyeq2 <EOL> from . import IExtendedVersionHandler <EOL> class ExtendedVersionHandler_LinearDecay ( IExtendedVersionHandler . IExtendedVersionHandler ) : <EOL> def AssembleDisplayHTML ( self , inModel ) : <EOL> x_or_xy = '<STR_LIT>' <EOL> if inModel . GetDimensionality ( ) == <NUM_LIT:2> : <EOL> x_or_xy = '<STR_LIT:x>' <EOL> if inModel . baseEquationHasGlobalMultiplierOrDivisor_UsedInExtendedVersions : <EOL> return inModel . _HTML + '<STR_LIT>' + inModel . _leftSideHTML + '<STR_LIT>' + inModel . _leftSideHTML + '<STR_LIT>' + x_or_xy <EOL> else : <EOL> try : <EOL> cd = inModel . GetCoefficientDesignators ( ) <EOL> return inModel . _HTML + '<STR_LIT>' + inModel . _leftSideHTML + '<STR_LIT>' + inModel . _leftSideHTML + '<STR_LIT>' + cd [ - <NUM_LIT:1> ] + '<STR_LIT>' + x_or_xy + '<STR_LIT:)>' <EOL> except : <EOL> return inModel . _HTML + '<STR_LIT>' + inModel . _leftSideHTML + '<STR_LIT>' + inModel . _leftSideHTML + '<STR_LIT>' + x_or_xy + '<STR_LIT:)>' <EOL> def AssembleDisplayName ( self , inModel ) : <EOL> return inModel . _baseName + '<STR_LIT>' <EOL> def AssembleSourceCodeName ( self , inModel ) : <EOL> return inModel . __module__ . split ( '<STR_LIT:.>' ) [ - <NUM_LIT:1> ] + '<STR_LIT:_>' + inModel . __class__ . __name__ + \"<STR_LIT>\" <EOL> def AssembleCoefficientDesignators ( self , inModel ) : <EOL> if inModel . baseEquationHasGlobalMultiplierOrDivisor_UsedInExtendedVersions : <EOL> return inModel . _coefficientDesignators <EOL> else : <EOL> return inModel . _coefficientDesignators + [ inModel . listOfAdditionalCoefficientDesignators [ len ( inModel . _coefficientDesignators ) ] ] <EOL> def AppendAdditionalCoefficientBounds ( self , inModel ) : <EOL> if inModel . baseEquationHasGlobalMultiplierOrDivisor_UsedInExtendedVersions : <EOL> return <EOL> else : <EOL> if inModel . upperCoefficientBounds != [ ] : <EOL> inModel . upperCoefficientBounds . append ( None ) <EOL> if inModel . lowerCoefficientBounds != [ ] : <EOL>"}
{"rec_id": "8789", "recitation_code": "inModel . lowerCoefficientBounds . append ( None )", "input_code_id": 61251, "input": "<s> from __future__ import print_function <EOL> from __future__ import unicode_literals <EOL> from __future__ import absolute_import <EOL> import pyeq2 <EOL> from . import IExtendedVersionHandler <EOL> import numpy <EOL> numpy . seterr ( all = '<STR_LIT:ignore>' ) <EOL> class ExtendedVersionHandler_ExponentialDecay ( IExtendedVersionHandler . IExtendedVersionHandler ) : <EOL> def AssembleDisplayHTML ( self , inModel ) : <EOL> x_or_xy = '<STR_LIT>' <EOL> if inModel . GetDimensionality ( ) == <NUM_LIT:2> : <EOL> x_or_xy = '<STR_LIT:x>' <EOL> if inModel . baseEquationHasGlobalMultiplierOrDivisor_UsedInExtendedVersions : <EOL> return inModel . _HTML + '<STR_LIT>' + inModel . _leftSideHTML + '<STR_LIT>' + inModel . _leftSideHTML + '<STR_LIT>' + x_or_xy + '<STR_LIT:)>' <EOL> else : <EOL> try : <EOL> cd = inModel . GetCoefficientDesignators ( ) <EOL> return inModel . _HTML + '<STR_LIT>' + inModel . _leftSideHTML + '<STR_LIT>' + inModel . _leftSideHTML + '<STR_LIT>' + cd [ - <NUM_LIT:1> ] + '<STR_LIT>' + x_or_xy + '<STR_LIT>' <EOL> except : <EOL> return inModel . _HTML + '<STR_LIT>' + inModel . _leftSideHTML + '<STR_LIT>' + inModel . _leftSideHTML + '<STR_LIT>' + x_or_xy + '<STR_LIT>' <EOL> def AssembleDisplayName ( self , inModel ) : <EOL> return inModel . _baseName + '<STR_LIT>' <EOL> def AssembleSourceCodeName ( self , inModel ) : <EOL> return inModel . __module__ . split ( '<STR_LIT:.>' ) [ - <NUM_LIT:1> ] + '<STR_LIT:_>' + inModel . __class__ . __name__ + \"<STR_LIT>\" <EOL> def AssembleCoefficientDesignators ( self , inModel ) : <EOL> if inModel . baseEquationHasGlobalMultiplierOrDivisor_UsedInExtendedVersions : <EOL> return inModel . _coefficientDesignators <EOL> else : <EOL> return inModel . _coefficientDesignators + [ inModel . listOfAdditionalCoefficientDesignators [ len ( inModel . _coefficientDesignators ) ] ] <EOL> def AppendAdditionalCoefficientBounds ( self , inModel ) : <EOL> if inModel . baseEquationHasGlobalMultiplierOrDivisor_UsedInExtendedVersions : <EOL> return <EOL> else : <EOL> if inModel . upperCoefficientBounds != [ ] : <EOL> inModel . upperCoefficientBounds . append ( None ) <EOL> if inModel . lowerCoefficientBounds != [ ] : <EOL>"}
{"rec_id": "8821", "recitation_code": "from rx . internal import extensionclassmethod", "input_code_id": 8821, "input": "<s> from rx import Observable <EOL> from rx . internal import extensionmethod <EOL> from rx . joins import Pattern <EOL>"}
{"rec_id": "8821", "recitation_code": "from rx . internal import extensionclassmethod", "input_code_id": 52359, "input": "<s> from rx import Observable <EOL> from rx . internal import extensionmethod <EOL> from rx . joins import Pattern <EOL>"}
{"rec_id": "8842", "recitation_code": "registry . Boolean ( False , ( \" \" \" \" \" \" ) ) )", "input_code_id": 1883, "input": "<s> import supybot . conf as conf <EOL> import supybot . registry as registry <EOL> from supybot . i18n import PluginInternationalization , internationalizeDocstring <EOL> _ = PluginInternationalization ( '<STR_LIT>' ) <EOL> def configure ( advanced ) : <EOL> from supybot . questions import expect , anything , something , yn <EOL> Web = conf . registerPlugin ( '<STR_LIT>' , True ) <EOL> if yn ( \"\"\"<STR_LIT>\"\"\" , default = False ) : <EOL> Web . titleSnarfer . setValue ( True ) <EOL> Web = conf . registerPlugin ( '<STR_LIT>' ) <EOL> conf . registerChannelValue ( Web , '<STR_LIT>' , <EOL> registry . Boolean ( False , _ ( \"\"\"<STR_LIT>\"\"\" ) ) ) <EOL> conf . registerChannelValue ( Web , '<STR_LIT>' , <EOL>"}
{"rec_id": "8842", "recitation_code": "registry . Boolean ( False , ( \" \" \" \" \" \" ) ) )", "input_code_id": 8842, "input": "<s> import supybot . conf as conf <EOL> import supybot . registry as registry <EOL> from supybot . i18n import PluginInternationalization , internationalizeDocstring <EOL> _ = PluginInternationalization ( '<STR_LIT>' ) <EOL> def configure ( advanced ) : <EOL> from supybot . questions import expect , anything , something , yn <EOL> conf . registerPlugin ( '<STR_LIT>' , True ) <EOL> AutoMode = conf . registerPlugin ( '<STR_LIT>' ) <EOL> conf . registerChannelValue ( AutoMode , '<STR_LIT>' , <EOL> registry . Boolean ( True , _ ( \"\"\"<STR_LIT>\"\"\" ) ) ) <EOL> conf . registerGlobalValue ( AutoMode , '<STR_LIT>' , <EOL> registry . Boolean ( False , _ ( \"\"\"<STR_LIT>\"\"\" ) ) ) <EOL> conf . registerChannelValue ( AutoMode , '<STR_LIT>' , <EOL> registry . Boolean ( True , _ ( \"\"\"<STR_LIT>\"\"\" ) ) ) <EOL> conf . registerChannelValue ( AutoMode , '<STR_LIT>' , <EOL>"}
{"rec_id": "8905", "recitation_code": "env = CartPoleEnvironment ( )", "input_code_id": 8905, "input": "<s> __author__ = \"<STR_LIT>\" <EOL> __version__ = '<STR_LIT>' <EOL> from pybrain . tools . example_tools import ExTools <EOL> from pybrain . tools . shortcuts import buildNetwork <EOL> from pybrain . rl . environments . cartpole import CartPoleEnvironment , BalanceTask <EOL> from pybrain . rl . agents import OptimizationAgent <EOL> from pybrain . optimization import PGPE <EOL> from pybrain . rl . experiments import EpisodicExperiment <EOL> batch = <NUM_LIT:1> <EOL> prnts = <NUM_LIT:100> <EOL> epis = <NUM_LIT> / batch / prnts <EOL> numbExp = <NUM_LIT:10> <EOL> et = ExTools ( batch , prnts ) <EOL>"}
{"rec_id": "8905", "recitation_code": "env = CartPoleEnvironment ( )", "input_code_id": 8092, "input": "<s> __author__ = \"<STR_LIT>\" <EOL> from pybrain . tools . example_tools import ExTools <EOL> from pybrain . tools . shortcuts import buildNetwork <EOL> from pybrain . rl . environments . cartpole import CartPoleEnvironment , BalanceTask <EOL> from pybrain . rl . agents import OptimizationAgent <EOL> from pybrain . optimization import CMAES <EOL> from pybrain . rl . experiments import EpisodicExperiment <EOL> batch = <NUM_LIT:2> <EOL> prnts = <NUM_LIT:100> <EOL> epis = <NUM_LIT> / batch / prnts <EOL> numbExp = <NUM_LIT:10> <EOL> et = ExTools ( batch , prnts ) <EOL>"}
{"rec_id": "8906", "recitation_code": "updated user team associations = [ ]", "input_code_id": 8906, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from googleads import dfp <EOL> USER_ID = '<STR_LIT>' <EOL> def main ( client , user_id ) : <EOL> user_team_association_service = client . GetService ( <EOL> '<STR_LIT>' , version = '<STR_LIT>' ) <EOL> values = [ { <EOL> '<STR_LIT:key>' : '<STR_LIT>' , <EOL> '<STR_LIT:value>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:value>' : user_id <EOL> } <EOL> } ] <EOL> query = '<STR_LIT>' <EOL> statement = dfp . FilterStatement ( query , values ) <EOL> response = user_team_association_service . getUserTeamAssociationsByStatement ( <EOL> statement . ToStatement ( ) ) <EOL> if '<STR_LIT>' in response : <EOL>"}
{"rec_id": "8906", "recitation_code": "updated user team associations = [ ]", "input_code_id": 56255, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from googleads import dfp <EOL> USER_ID = '<STR_LIT>' <EOL> def main ( client , user_id ) : <EOL> user_team_association_service = client . GetService ( <EOL> '<STR_LIT>' , version = '<STR_LIT>' ) <EOL> values = [ { <EOL> '<STR_LIT:key>' : '<STR_LIT>' , <EOL> '<STR_LIT:value>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:value>' : user_id <EOL> } <EOL> } ] <EOL> query = '<STR_LIT>' <EOL> statement = dfp . FilterStatement ( query , values ) <EOL> response = user_team_association_service . getUserTeamAssociationsByStatement ( <EOL> statement . ToStatement ( ) ) <EOL> if '<STR_LIT>' in response : <EOL>"}
{"rec_id": "9062", "recitation_code": "response = test get and post form (", "input_code_id": 9062, "input": "<s> import getpass , os <EOL> import re <EOL> from StringIO import StringIO <EOL> from paramiko . rsakey import RSAKey <EOL> from django . test import TestCase <EOL> from django . contrib . auth . models import User <EOL> from django . core . urlresolvers import reverse <EOL> from expedient . clearinghouse . slice . models import Slice <EOL> from expedient . common . permissions . models import ExpedientPermission <EOL> from expedient . clearinghouse . project . models import Project <EOL> from expedient . common . tests . client import test_get_and_post_form <EOL> from sshaggregate . views import aggregate_add_servers , aggregate_crud <EOL> from sshaggregate . models import SSHAggregate , SSHServer , SSHServerSliver , SSHSliceInfo <EOL> class Tests ( TestCase ) : <EOL> CREATED_USER_FNAME = \"<STR_LIT>\" <EOL> '''<STR_LIT>''' <EOL> DELETED_USER_FNAME = \"<STR_LIT>\" <EOL> '''<STR_LIT>''' <EOL> PUBKEY_USER_FNAME = \"<STR_LIT>\" <EOL> '''<STR_LIT>''' <EOL> TEST_SSH_KEY_NAME = \"<STR_LIT>\" <EOL> TEST_KEY_COMMENT = \"<STR_LIT>\" <EOL> def create_test_ssh_key ( self ) : <EOL> self . test_key = RSAKey . generate ( <NUM_LIT> ) <EOL> self . test_pubkey = \"<STR_LIT>\" % ( self . test_key . get_base64 ( ) , Tests . TEST_KEY_COMMENT ) <EOL> f = open ( os . path . expanduser ( \"<STR_LIT>\" ) , \"<STR_LIT:a>\" ) <EOL> f . write ( self . test_pubkey ) <EOL> f . close ( ) <EOL> def delete_test_ssh_key ( self ) : <EOL> f = open ( os . path . expanduser ( \"<STR_LIT>\" ) , \"<STR_LIT:r>\" ) <EOL> auth_keys = f . read ( ) <EOL> f . close ( ) <EOL> new_auth_keys = re . sub ( <EOL> r\"<STR_LIT>\" % Tests . TEST_KEY_COMMENT , \"<STR_LIT>\" , auth_keys ) <EOL> f = open ( os . path . expanduser ( \"<STR_LIT>\" ) , \"<STR_LIT:w>\" ) <EOL> f . write ( new_auth_keys ) <EOL> f . close ( ) <EOL> def setUp ( self ) : <EOL> self . su = User . objects . create_superuser ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:password>\" ) <EOL> ExpedientPermission . objects . disable_checks ( ) <EOL> for f in Tests . CREATED_USER_FNAME , Tests . DELETED_USER_FNAME , Tests . PUBKEY_USER_FNAME : <EOL> if os . access ( f , os . F_OK ) : <EOL> os . unlink ( f ) <EOL> self . create_test_ssh_key ( ) <EOL> self . client . login ( username = \"<STR_LIT>\" , password = \"<STR_LIT:password>\" ) <EOL> def tearDown ( self ) : <EOL> for f in Tests . CREATED_USER_FNAME , Tests . DELETED_USER_FNAME , Tests . PUBKEY_USER_FNAME : <EOL> if os . access ( f , os . F_OK ) : <EOL> os . unlink ( f ) <EOL> self . delete_test_ssh_key ( ) <EOL> ExpedientPermission . objects . enable_checks ( ) <EOL> def test_add_aggregate ( self ) : <EOL> self . assertEqual ( SSHAggregate . objects . count ( ) , <NUM_LIT:0> ) <EOL> pkey_f = StringIO ( ) <EOL> self . test_key . write_private_key ( pkey_f ) <EOL> pkey = pkey_f . getvalue ( ) <EOL> pkey_f . close ( ) <EOL> response = test_get_and_post_form ( <EOL> self . client , <EOL> url = reverse ( aggregate_crud ) , <EOL> params = dict ( <EOL> name = \"<STR_LIT>\" , <EOL> description = \"<STR_LIT>\" , <EOL> location = \"<STR_LIT>\" , <EOL> admin_username = getpass . getuser ( ) , <EOL> private_key = pkey , <EOL> add_user_command = \"<STR_LIT>\" + <EOL> Tests . CREATED_USER_FNAME + \"<STR_LIT:'>\" , <EOL> del_user_command = \"<STR_LIT>\" + <EOL> Tests . DELETED_USER_FNAME + \"<STR_LIT:'>\" , <EOL> add_pubkey_user_command = \"<STR_LIT>\" + <EOL> Tests . PUBKEY_USER_FNAME + \"<STR_LIT:'>\" , <EOL> ) , <EOL> ) <EOL> self . assertEqual ( SSHAggregate . objects . count ( ) , <NUM_LIT:1> ) <EOL> next_url = reverse ( aggregate_add_servers , args = [ <NUM_LIT:1> ] ) <EOL>"}
{"rec_id": "9062", "recitation_code": "response = test get and post form (", "input_code_id": 66057, "input": "<s> from django . conf import settings <EOL> from expedient . common . tests . manager import SettingsTestCase <EOL> from django . core . urlresolvers import reverse <EOL> import logging <EOL> from django . contrib . auth . models import User <EOL> from openflow . optin_manager . opts . models import UserFlowSpace , Experiment , ExperimentFLowSpace , UserOpts , OptsFlowSpace , MatchStruct <EOL> import random <EOL> from openflow . optin_manager . xmlrpc_server . ch_api import om_ch_translate <EOL> from expedient . common . tests . client import Browser , test_get_and_post_form <EOL> from openflow . optin_manager . users . models import UserProfile , Priority <EOL> from openflow . optin_manager . dummyfv . models import DummyFV , DummyFVRule <EOL> from openflow . optin_manager . xmlrpc_server . models import FVServerProxy <EOL> logger = logging . getLogger ( \"<STR_LIT>\" ) <EOL> SCHEME = \"<STR_LIT:test>\" <EOL> HOST = \"<STR_LIT>\" <EOL> USE_RANDOM = False <EOL> class Tests ( SettingsTestCase ) : <EOL> def setUp ( self ) : <EOL> self . test_user = User . objects . create_user ( <EOL> \"<STR_LIT:user>\" , \"<STR_LIT>\" , \"<STR_LIT:password>\" ) <EOL> profile = UserProfile . get_or_create_profile ( self . test_user ) <EOL> self . test_admin = User . objects . create_superuser ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:password>\" ) <EOL> self . user_ip_src_s = random . randint ( <NUM_LIT:0> , <NUM_LIT> ) & <NUM_LIT> <EOL> self . user_ip_src_e = random . randint ( <NUM_LIT> , <NUM_LIT> ) & <NUM_LIT> <EOL> self . exp_ip_src_s = random . randint ( <NUM_LIT:0> , <NUM_LIT> ) & <NUM_LIT> <EOL> self . exp_ip_src_e = random . randint ( <NUM_LIT> , <NUM_LIT> ) & <NUM_LIT> <EOL> fields = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> random . shuffle ( fields ) <EOL> ( to_str , from_str , width , om_name , of_name ) = om_ch_translate . attr_funcs [ fields [ <NUM_LIT:0> ] ] <EOL> self . user_field_name = om_name <EOL> self . user_field_s = random . randint ( <NUM_LIT:0> , <NUM_LIT:2> ** width - <NUM_LIT:3> ) <EOL> self . user_field_e = self . user_field_s + <NUM_LIT:1> <EOL> ( to_str , from_str , width , om_name , of_name ) = om_ch_translate . attr_funcs [ fields [ <NUM_LIT:1> ] ] <EOL> self . exp_field_name = om_name <EOL> self . exp_field_s = random . randint ( <NUM_LIT:0> , <NUM_LIT:2> ** width - <NUM_LIT:3> ) <EOL> self . exp_field_e = self . exp_field_s + <NUM_LIT:1> <EOL> ufs = UserFlowSpace ( user = self . test_user , ip_src_s = self . user_ip_src_s , <EOL> ip_src_e = self . user_ip_src_e , approver = self . test_admin ) <EOL> setattr ( ufs , \"<STR_LIT>\" % self . user_field_name , self . user_field_s ) <EOL> setattr ( ufs , \"<STR_LIT>\" % self . user_field_name , self . user_field_e ) <EOL> ufs . save ( ) <EOL> exp = Experiment . objects . create ( slice_id = \"<STR_LIT>\" , project_name = \"<STR_LIT>\" , <EOL> project_desc = \"<STR_LIT>\" , slice_name = \"<STR_LIT>\" , <EOL> slice_desc = \"<STR_LIT>\" , controller_url = \"<STR_LIT>\" , <EOL> owner_email = \"<STR_LIT>\" , owner_password = \"<STR_LIT>\" ) <EOL> expfs = ExperimentFLowSpace . objects . create ( exp = exp , dpid = \"<STR_LIT>\" , <EOL> ip_src_s = self . exp_ip_src_s , <EOL> ip_src_e = self . exp_ip_src_e , <EOL> ) <EOL> setattr ( expfs , \"<STR_LIT>\" % self . exp_field_name , self . exp_field_s ) <EOL> setattr ( expfs , \"<STR_LIT>\" % self . exp_field_name , self . exp_field_e ) <EOL> expfs . save ( ) <EOL> fv = DummyFV . objects . create ( ) <EOL> fv . populateTopology ( <NUM_LIT:10> , <NUM_LIT:20> , use_random = USE_RANDOM ) <EOL> username = \"<STR_LIT>\" <EOL> password = \"<STR_LIT:password>\" <EOL> u = User . objects . create ( username = username ) <EOL> u . set_password ( password ) <EOL> u . save ( ) <EOL> FVServerProxy . objects . create ( <EOL> name = \"<STR_LIT>\" , <EOL> username = username , <EOL> password = password , <EOL> url = SCHEME + \"<STR_LIT>\" % ( <EOL> HOST , fv . id , <EOL> ) , <EOL> ) <EOL> logged = self . client . login ( username = \"<STR_LIT:user>\" , password = \"<STR_LIT:password>\" ) <EOL> self . assertEqual ( logged , True ) <EOL> def test_user_optin ( self ) : <EOL> '''<STR_LIT>''' <EOL> all_exps = Experiment . objects . all ( ) <EOL> self . assertEqual ( all_exps . count ( ) , <NUM_LIT:1> ) <EOL> response = test_get_and_post_form ( <EOL> self . client , <EOL> reverse ( \"<STR_LIT>\" ) , <EOL> { \"<STR_LIT>\" : all_exps [ <NUM_LIT:0> ] . id } , <EOL> ) <EOL> self . assertContains ( response , \"<STR_LIT>\" ) <EOL> uopt = UserOpts . objects . filter ( user__username__exact = \"<STR_LIT:user>\" ) <EOL> self . assertEqual ( len ( uopt ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( uopt [ <NUM_LIT:0> ] . experiment . slice_name , \"<STR_LIT>\" ) <EOL> optfs = OptsFlowSpace . objects . filter ( opt = uopt [ <NUM_LIT:0> ] ) <EOL> self . assertEqual ( len ( optfs ) , <NUM_LIT:1> ) <EOL> self . num_fv_rules = MatchStruct . objects . filter ( optfs = optfs [ <NUM_LIT:0> ] ) . count ( ) <EOL> actual_fv_rules_count = DummyFVRule . objects . all ( ) . count ( ) <EOL> self . assertEqual ( actual_fv_rules_count , self . num_fv_rules ) <EOL> self . assertEqual ( optfs [ <NUM_LIT:0> ] . ip_src_s , max ( self . user_ip_src_s , self . exp_ip_src_s ) ) <EOL> self . assertEqual ( optfs [ <NUM_LIT:0> ] . ip_src_e , min ( self . user_ip_src_e , self . exp_ip_src_e ) ) <EOL> self . assertEqual ( getattr ( optfs [ <NUM_LIT:0> ] , \"<STR_LIT>\" % self . user_field_name ) , self . user_field_s ) <EOL> self . assertEqual ( getattr ( optfs [ <NUM_LIT:0> ] , \"<STR_LIT>\" % self . user_field_name ) , self . user_field_e ) <EOL> self . assertEqual ( getattr ( optfs [ <NUM_LIT:0> ] , \"<STR_LIT>\" % self . exp_field_name ) , self . exp_field_s ) <EOL> self . assertEqual ( getattr ( optfs [ <NUM_LIT:0> ] , \"<STR_LIT>\" % self . exp_field_name ) , self . exp_field_e ) <EOL> def test_user_optin_invalid ( self ) : <EOL> '''<STR_LIT>''' <EOL> response = test_get_and_post_form ( <EOL> self . client , <EOL> reverse ( \"<STR_LIT>\" ) , <EOL> { \"<STR_LIT>\" : <NUM_LIT> } , <EOL> ) <EOL> self . assertNotContains ( response , \"<STR_LIT>\" ) <EOL> uopt = UserOpts . objects . filter ( user__username__exact = \"<STR_LIT:user>\" ) <EOL> self . assertEqual ( len ( uopt ) , <NUM_LIT:0> ) <EOL> actual_fv_rules_count = DummyFVRule . objects . all ( ) . count ( ) <EOL> self . assertEqual ( actual_fv_rules_count , <NUM_LIT:0> ) <EOL> def test_user_optin_invalid_fv ( self ) : <EOL> fv_server_proxy = FVServerProxy . objects . all ( ) [ <NUM_LIT:0> ] <EOL> fv_server_proxy . username = \"<STR_LIT>\" <EOL> fv_server_proxy . save ( ) <EOL>"}
{"rec_id": "9079", "recitation_code": "output . write ( latest . read ( ) )", "input_code_id": 9079, "input": "<s> import os <EOL> import sys <EOL> import urllib2 <EOL> import subprocess <EOL> installationPath = os . path . expanduser ( '<STR_LIT>' ) + '<STR_LIT>' <EOL> serverLocalLocation = installationPath + '<STR_LIT>' <EOL> serverWebLocation = '<STR_LIT>' <EOL> try : <EOL> print '<STR_LIT>' <EOL> if not os . path . isdir ( installationPath ) : <EOL> os . makedirs ( installationPath ) <EOL> print '<STR_LIT>' <EOL> latest = urllib2 . urlopen ( serverWebLocation ) <EOL> output = open ( serverLocalLocation , '<STR_LIT:wb>' ) <EOL>"}
{"rec_id": "9079", "recitation_code": "output . write ( latest . read ( ) )", "input_code_id": 49318, "input": "<s> __author__ = '<STR_LIT>' <EOL> __license__ = '<STR_LIT>' <EOL> __version__ = '<STR_LIT>' <EOL> import os <EOL> import sys <EOL> import time <EOL> import urllib2 <EOL> import subprocess <EOL> from argparse import ArgumentParser , RawTextHelpFormatter <EOL> from Paths import Paths <EOL> from HttpServer import HttpServerHandler , HttpServerThread <EOL> def main ( ) : <EOL> parser = ArgumentParser ( description = '<STR_LIT>' , formatter_class = RawTextHelpFormatter ) <EOL> parser . add_argument ( '<STR_LIT>' , '<STR_LIT>' , action = '<STR_LIT:version>' , version = __version__ ) <EOL> parser . add_argument ( '<STR_LIT>' , '<STR_LIT>' , action = '<STR_LIT:store_true>' , help = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , '<STR_LIT>' , type = str , default = '<STR_LIT:localhost>' , help = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , '<STR_LIT>' , type = int , default = <NUM_LIT> , help = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , action = '<STR_LIT:store_true>' , help = '<STR_LIT>' ) <EOL> args = parser . parse_args ( ) <EOL> try : <EOL> paths = Paths ( ) <EOL> if ( args . update ) : <EOL> update ( paths , args . verbose ) <EOL> else : <EOL> checkYoutubedl ( paths , args . verbose ) <EOL> runServer ( args . server , args . port , args . verbose ) <EOL> except KeyboardInterrupt : <EOL> sys . exit ( <NUM_LIT:0> ) <EOL> def update ( paths , v ) : <EOL> _update ( paths , v ) <EOL> sys . exit ( <NUM_LIT:0> ) <EOL> def _update ( paths , v ) : <EOL> show ( '<STR_LIT>' , v ) <EOL> try : <EOL> latest = urllib2 . urlopen ( '<STR_LIT>' + paths . getYdlName ( ) , context = paths . getSslCtx ( ) ) <EOL> if not os . path . isdir ( paths . getYdlPath ( ) ) : <EOL> os . makedirs ( paths . getYdlPath ( ) ) <EOL> output = open ( paths . getYdlLocation ( ) , '<STR_LIT:wb>' ) <EOL>"}
{"rec_id": "9095", "recitation_code": "class TagAdmin ( admin . ModelAdmin ) :", "input_code_id": 9095, "input": "<s> from django . contrib import admin <EOL> from tagging . models import Tag , TaggedItem <EOL> from tagging . forms import TagAdminForm <EOL>"}
{"rec_id": "9095", "recitation_code": "class TagAdmin ( admin . ModelAdmin ) :", "input_code_id": 55860, "input": "<s> from django . contrib import admin <EOL> from taggit . admin import TaggedItemInline <EOL> from taggit_suggest . models import TagKeyword , TagRegex <EOL> from taggit . models import Tag <EOL> class TagKeywordInline ( admin . StackedInline ) : <EOL> model = TagKeyword <EOL> class TagRegxInline ( admin . StackedInline ) : <EOL> model = TagRegex <EOL>"}
{"rec_id": "9203", "recitation_code": "queryset = Note . objects . all ( )", "input_code_id": 9203, "input": "<s> from django . contrib . auth . models import User <EOL> from tastypie import fields <EOL> from tastypie . resources import NamespacedModelResource <EOL> from tastypie . authorization import Authorization <EOL> from basic . models import Note <EOL> class NamespacedUserResource ( NamespacedModelResource ) : <EOL> class Meta : <EOL> resource_name = '<STR_LIT>' <EOL>"}
{"rec_id": "9203", "recitation_code": "queryset = Note . objects . all ( )", "input_code_id": 68145, "input": "<s> from django . contrib . auth . models import User <EOL> from tastypie import fields <EOL> from tastypie . resources import ModelResource , NamespacedModelResource <EOL> from tastypie . authorization import Authorization <EOL> from basic . models import Note <EOL> class NamespacedUserResource ( NamespacedModelResource ) : <EOL> class Meta : <EOL> resource_name = '<STR_LIT>' <EOL>"}
{"rec_id": "9218", "recitation_code": "ch . setLevel ( logging . DEBUG )", "input_code_id": 1914, "input": "<s> import logging <EOL> def get_logger ( LOGFILE ) : <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> logger . setLevel ( logging . DEBUG ) <EOL> fh = logging . FileHandler ( LOGFILE ) <EOL> fh . setLevel ( logging . DEBUG ) <EOL> ch = logging . StreamHandler ( ) <EOL>"}
{"rec_id": "9218", "recitation_code": "ch . setLevel ( logging . DEBUG )", "input_code_id": 9218, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import logging <EOL> import os <EOL> import sys <EOL> from cloud_handler import CloudLoggingHandler <EOL> from cron_executor import Executor <EOL> PROJECT = '<STR_LIT>' <EOL> TOPIC = '<STR_LIT:test>' <EOL> script_path = os . path . abspath ( os . path . join ( os . getcwd ( ) , '<STR_LIT>' ) ) <EOL> sample_task = \"<STR_LIT>\" % script_path <EOL> root_logger = logging . getLogger ( '<STR_LIT>' ) <EOL> root_logger . setLevel ( logging . DEBUG ) <EOL> ch = logging . StreamHandler ( sys . stderr ) <EOL>"}
{"rec_id": "9218", "recitation_code": "ch . setLevel ( logging . DEBUG )", "input_code_id": 13883, "input": "<s> import logging <EOL> logger = logging . getLogger ( \"<STR_LIT>\" ) <EOL> logger . setLevel ( logging . DEBUG ) <EOL> ch = logging . StreamHandler ( ) <EOL>"}
{"rec_id": "9218", "recitation_code": "ch . setLevel ( logging . DEBUG )", "input_code_id": 33614, "input": "<s> import logging <EOL> logger = logging . getLogger ( \"<STR_LIT>\" ) <EOL> logger . setLevel ( logging . DEBUG ) <EOL> ch = logging . StreamHandler ( ) <EOL>"}
{"rec_id": "9222", "recitation_code": "def get headers ( ) :", "input_code_id": 9222, "input": "<s> from datetime import timedelta <EOL> from flask import make_response , request , current_app <EOL> from functools import update_wrapper <EOL> def crossdomain ( origin = None , methods = None , headers = None , expose_headers = None , <EOL> max_age = <NUM_LIT> , attach_to_all = True , <EOL> automatic_options = True , credentials = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if methods is not None : <EOL> methods = '<STR_LIT:U+002CU+0020>' . join ( sorted ( x . upper ( ) for x in methods ) ) <EOL> if headers is not None and not isinstance ( headers , str ) : <EOL> headers = '<STR_LIT:U+002CU+0020>' . join ( x . upper ( ) for x in headers ) <EOL> if expose_headers is not None and not isinstance ( expose_headers , str ) : <EOL> expose_headers = '<STR_LIT:U+002CU+0020>' . join ( x . upper ( ) for x in expose_headers ) <EOL> if not isinstance ( origin , str ) : <EOL> origin = '<STR_LIT:U+002CU+0020>' . join ( origin ) <EOL> if isinstance ( max_age , timedelta ) : <EOL> max_age = max_age . total_seconds ( ) <EOL> def get_methods ( ) : <EOL> if methods is not None : <EOL> return methods <EOL> options_resp = current_app . make_default_options_response ( ) <EOL> return options_resp . headers [ '<STR_LIT>' ] <EOL>"}
{"rec_id": "9222", "recitation_code": "def get headers ( ) :", "input_code_id": 84785, "input": "<s> import numpy as np <EOL> from datetime import timedelta <EOL> from functools import update_wrapper , wraps <EOL> from math import sin <EOL> from random import random <EOL> from six import string_types <EOL> from bokeh . plotting import figure , show , output_file <EOL> from bokeh . models . sources import AjaxDataSource <EOL> output_file ( \"<STR_LIT>\" , title = \"<STR_LIT>\" ) <EOL> source = AjaxDataSource ( data_url = '<STR_LIT>' , <EOL> polling_interval = <NUM_LIT:100> ) <EOL> p = figure ( ) <EOL> p . circle ( '<STR_LIT:x>' , '<STR_LIT:y>' , source = source ) <EOL> p . x_range . follow = \"<STR_LIT:end>\" <EOL> p . x_range . follow_interval = <NUM_LIT:10> <EOL> try : <EOL> from flask import Flask , jsonify , make_response , request , current_app <EOL> except ImportError : <EOL> raise ImportError ( \"<STR_LIT>\" ) <EOL> show ( p ) <EOL> def crossdomain ( origin = None , methods = None , headers = None , <EOL> max_age = <NUM_LIT> , attach_to_all = True , <EOL> automatic_options = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if methods is not None : <EOL> methods = '<STR_LIT:U+002CU+0020>' . join ( sorted ( x . upper ( ) for x in methods ) ) <EOL> if headers is not None and not isinstance ( headers , string_types ) : <EOL> headers = '<STR_LIT:U+002CU+0020>' . join ( x . upper ( ) for x in headers ) <EOL> if not isinstance ( origin , string_types ) : <EOL> origin = '<STR_LIT:U+002CU+0020>' . join ( origin ) <EOL> if isinstance ( max_age , timedelta ) : <EOL> max_age = max_age . total_seconds ( ) <EOL> def get_methods ( ) : <EOL> options_resp = current_app . make_default_options_response ( ) <EOL> return options_resp . headers [ '<STR_LIT>' ] <EOL>"}
{"rec_id": "9254", "recitation_code": "u = UserList ( \" \" )", "input_code_id": 9254, "input": "<s> from UserList import UserList <EOL> from test import test_support , list_tests <EOL> class UserListTest ( list_tests . CommonTest ) : <EOL> type2test = UserList <EOL> def test_getslice ( self ) : <EOL> super ( UserListTest , self ) . test_getslice ( ) <EOL> l = [ <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ] <EOL> u = self . type2test ( l ) <EOL> for i in range ( - <NUM_LIT:3> , <NUM_LIT:6> ) : <EOL> self . assertEqual ( u [ : i ] , l [ : i ] ) <EOL> self . assertEqual ( u [ i : ] , l [ i : ] ) <EOL> for j in xrange ( - <NUM_LIT:3> , <NUM_LIT:6> ) : <EOL> self . assertEqual ( u [ i : j ] , l [ i : j ] ) <EOL> def test_add_specials ( self ) : <EOL> u = UserList ( \"<STR_LIT>\" ) <EOL> u2 = u + \"<STR_LIT>\" <EOL> self . assertEqual ( u2 , list ( \"<STR_LIT>\" ) ) <EOL> def test_radd_specials ( self ) : <EOL> u = UserList ( \"<STR_LIT>\" ) <EOL> u2 = \"<STR_LIT>\" + u <EOL> self . assertEqual ( u2 , list ( \"<STR_LIT>\" ) ) <EOL> u2 = u . __radd__ ( UserList ( \"<STR_LIT>\" ) ) <EOL> self . assertEqual ( u2 , list ( \"<STR_LIT>\" ) ) <EOL> def test_iadd ( self ) : <EOL>"}
{"rec_id": "9254", "recitation_code": "u = UserList ( \" \" )", "input_code_id": 4347, "input": "<s> from UserList import UserList <EOL> from test import test_support , list_tests <EOL> class UserListTest ( list_tests . CommonTest ) : <EOL> type2test = UserList <EOL> def test_getslice ( self ) : <EOL> super ( UserListTest , self ) . test_getslice ( ) <EOL> l = [ <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ] <EOL> u = self . type2test ( l ) <EOL> for i in range ( - <NUM_LIT:3> , <NUM_LIT:6> ) : <EOL> self . assertEqual ( u [ : i ] , l [ : i ] ) <EOL> self . assertEqual ( u [ i : ] , l [ i : ] ) <EOL> for j in xrange ( - <NUM_LIT:3> , <NUM_LIT:6> ) : <EOL> self . assertEqual ( u [ i : j ] , l [ i : j ] ) <EOL> def test_add_specials ( self ) : <EOL> u = UserList ( \"<STR_LIT>\" ) <EOL> u2 = u + \"<STR_LIT>\" <EOL> self . assertEqual ( u2 , list ( \"<STR_LIT>\" ) ) <EOL> def test_radd_specials ( self ) : <EOL> u = UserList ( \"<STR_LIT>\" ) <EOL> u2 = \"<STR_LIT>\" + u <EOL> self . assertEqual ( u2 , list ( \"<STR_LIT>\" ) ) <EOL> u2 = u . __radd__ ( UserList ( \"<STR_LIT>\" ) ) <EOL> self . assertEqual ( u2 , list ( \"<STR_LIT>\" ) ) <EOL> def test_iadd ( self ) : <EOL>"}
{"rec_id": "9254", "recitation_code": "u = UserList ( \" \" )", "input_code_id": 22512, "input": "<s> from collections import UserList <EOL> from test import support , list_tests <EOL> class UserListTest ( list_tests . CommonTest ) : <EOL> type2test = UserList <EOL> def test_getslice ( self ) : <EOL> super ( ) . test_getslice ( ) <EOL> l = [ <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ] <EOL> u = self . type2test ( l ) <EOL> for i in range ( - <NUM_LIT:3> , <NUM_LIT:6> ) : <EOL> self . assertEqual ( u [ : i ] , l [ : i ] ) <EOL> self . assertEqual ( u [ i : ] , l [ i : ] ) <EOL> for j in range ( - <NUM_LIT:3> , <NUM_LIT:6> ) : <EOL> self . assertEqual ( u [ i : j ] , l [ i : j ] ) <EOL> def test_add_specials ( self ) : <EOL> u = UserList ( \"<STR_LIT>\" ) <EOL> u2 = u + \"<STR_LIT>\" <EOL> self . assertEqual ( u2 , list ( \"<STR_LIT>\" ) ) <EOL> def test_radd_specials ( self ) : <EOL> u = UserList ( \"<STR_LIT>\" ) <EOL> u2 = \"<STR_LIT>\" + u <EOL> self . assertEqual ( u2 , list ( \"<STR_LIT>\" ) ) <EOL> u2 = u . __radd__ ( UserList ( \"<STR_LIT>\" ) ) <EOL> self . assertEqual ( u2 , list ( \"<STR_LIT>\" ) ) <EOL> def test_iadd ( self ) : <EOL> super ( ) . test_iadd ( ) <EOL>"}
{"rec_id": "9255", "recitation_code": "def download file curl ( url , target ) :", "input_code_id": 9255, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> import shutil <EOL> import sys <EOL> import tempfile <EOL> import tarfile <EOL> import optparse <EOL> import subprocess <EOL> import platform <EOL> from distutils import log <EOL> try : <EOL> from site import USER_SITE <EOL> except ImportError : <EOL> USER_SITE = None <EOL> DEFAULT_VERSION = \"<STR_LIT:1.0>\" <EOL> DEFAULT_URL = \"<STR_LIT>\" <EOL> def _python_cmd ( * args ) : <EOL> args = ( sys . executable , ) + args <EOL> return subprocess . call ( args ) == <NUM_LIT:0> <EOL> def _check_call_py24 ( cmd , * args , ** kwargs ) : <EOL> res = subprocess . call ( cmd , * args , ** kwargs ) <EOL> class CalledProcessError ( Exception ) : <EOL> pass <EOL> if not res == <NUM_LIT:0> : <EOL> msg = \"<STR_LIT>\" % ( cmd , res ) <EOL> raise CalledProcessError ( msg ) <EOL> vars ( subprocess ) . setdefault ( '<STR_LIT>' , _check_call_py24 ) <EOL> def _install ( tarball , install_args = ( ) ) : <EOL> tmpdir = tempfile . mkdtemp ( ) <EOL> log . warn ( '<STR_LIT>' , tmpdir ) <EOL> old_wd = os . getcwd ( ) <EOL> try : <EOL> os . chdir ( tmpdir ) <EOL> tar = tarfile . open ( tarball ) <EOL> _extractall ( tar ) <EOL> tar . close ( ) <EOL> subdir = os . path . join ( tmpdir , os . listdir ( tmpdir ) [ <NUM_LIT:0> ] ) <EOL> os . chdir ( subdir ) <EOL> log . warn ( '<STR_LIT>' , subdir ) <EOL> log . warn ( '<STR_LIT>' ) <EOL> if not _python_cmd ( '<STR_LIT>' , '<STR_LIT>' , * install_args ) : <EOL> log . warn ( '<STR_LIT>' ) <EOL> log . warn ( '<STR_LIT>' ) <EOL> return <NUM_LIT:2> <EOL> finally : <EOL> os . chdir ( old_wd ) <EOL> shutil . rmtree ( tmpdir ) <EOL> def _build_egg ( egg , tarball , to_dir ) : <EOL> tmpdir = tempfile . mkdtemp ( ) <EOL> log . warn ( '<STR_LIT>' , tmpdir ) <EOL> old_wd = os . getcwd ( ) <EOL> try : <EOL> os . chdir ( tmpdir ) <EOL> tar = tarfile . open ( tarball ) <EOL> _extractall ( tar ) <EOL> tar . close ( ) <EOL> subdir = os . path . join ( tmpdir , os . listdir ( tmpdir ) [ <NUM_LIT:0> ] ) <EOL> os . chdir ( subdir ) <EOL> log . warn ( '<STR_LIT>' , subdir ) <EOL> log . warn ( '<STR_LIT>' , to_dir ) <EOL> _python_cmd ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , to_dir ) <EOL> finally : <EOL> os . chdir ( old_wd ) <EOL> shutil . rmtree ( tmpdir ) <EOL> log . warn ( egg ) <EOL> if not os . path . exists ( egg ) : <EOL> raise IOError ( '<STR_LIT>' ) <EOL> def _do_download ( version , download_base , to_dir , download_delay ) : <EOL> egg = os . path . join ( to_dir , '<STR_LIT>' <EOL> % ( version , sys . version_info [ <NUM_LIT:0> ] , sys . version_info [ <NUM_LIT:1> ] ) ) <EOL> if not os . path . exists ( egg ) : <EOL> tarball = download_setuptools ( version , download_base , <EOL> to_dir , download_delay ) <EOL> _build_egg ( egg , tarball , to_dir ) <EOL> sys . path . insert ( <NUM_LIT:0> , egg ) <EOL> if '<STR_LIT>' in sys . modules : <EOL> del sys . modules [ '<STR_LIT>' ] <EOL> import setuptools <EOL> setuptools . bootstrap_install_from = egg <EOL> def use_setuptools ( version = DEFAULT_VERSION , download_base = DEFAULT_URL , <EOL> to_dir = os . curdir , download_delay = <NUM_LIT:15> ) : <EOL> to_dir = os . path . abspath ( to_dir ) <EOL> was_imported = '<STR_LIT>' in sys . modules or '<STR_LIT>' in sys . modules <EOL> try : <EOL> import pkg_resources <EOL> except ImportError : <EOL> return _do_download ( version , download_base , to_dir , download_delay ) <EOL> try : <EOL> pkg_resources . require ( \"<STR_LIT>\" + version ) <EOL> return <EOL> except pkg_resources . VersionConflict : <EOL> e = sys . exc_info ( ) [ <NUM_LIT:1> ] <EOL> if was_imported : <EOL> sys . stderr . write ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % ( version , e . args [ <NUM_LIT:0> ] ) ) <EOL> sys . exit ( <NUM_LIT:2> ) <EOL> else : <EOL> del pkg_resources , sys . modules [ '<STR_LIT>' ] <EOL> return _do_download ( version , download_base , to_dir , <EOL> download_delay ) <EOL> except pkg_resources . DistributionNotFound : <EOL> return _do_download ( version , download_base , to_dir , <EOL> download_delay ) <EOL> def download_file_powershell ( url , target ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> target = os . path . abspath ( target ) <EOL> cmd = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> \"<STR_LIT>\" % vars ( ) , <EOL> ] <EOL> subprocess . check_call ( cmd ) <EOL> def has_powershell ( ) : <EOL> if platform . system ( ) != '<STR_LIT>' : <EOL> return False <EOL> cmd = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> devnull = open ( os . path . devnull , '<STR_LIT:wb>' ) <EOL> try : <EOL> subprocess . check_call ( cmd , stdout = devnull , stderr = devnull ) <EOL> except : <EOL> return False <EOL> finally : <EOL> devnull . close ( ) <EOL> return True <EOL> download_file_powershell . viable = has_powershell <EOL>"}
{"rec_id": "9255", "recitation_code": "def download file curl ( url , target ) :", "input_code_id": 74456, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> import shutil <EOL> import sys <EOL> import tempfile <EOL> import tarfile <EOL> import optparse <EOL> import subprocess <EOL> import platform <EOL> import textwrap <EOL> from distutils import log <EOL> try : <EOL> from site import USER_SITE <EOL> except ImportError : <EOL> USER_SITE = None <EOL> DEFAULT_VERSION = \"<STR_LIT>\" <EOL> DEFAULT_URL = \"<STR_LIT>\" <EOL> def _python_cmd ( * args ) : <EOL> args = ( sys . executable , ) + args <EOL> return subprocess . call ( args ) == <NUM_LIT:0> <EOL> def _install ( tarball , install_args = ( ) ) : <EOL> tmpdir = tempfile . mkdtemp ( ) <EOL> log . warn ( '<STR_LIT>' , tmpdir ) <EOL> old_wd = os . getcwd ( ) <EOL> try : <EOL> os . chdir ( tmpdir ) <EOL> tar = tarfile . open ( tarball ) <EOL> _extractall ( tar ) <EOL> tar . close ( ) <EOL> subdir = os . path . join ( tmpdir , os . listdir ( tmpdir ) [ <NUM_LIT:0> ] ) <EOL> os . chdir ( subdir ) <EOL> log . warn ( '<STR_LIT>' , subdir ) <EOL> log . warn ( '<STR_LIT>' ) <EOL> if not _python_cmd ( '<STR_LIT>' , '<STR_LIT>' , * install_args ) : <EOL> log . warn ( '<STR_LIT>' ) <EOL> log . warn ( '<STR_LIT>' ) <EOL> return <NUM_LIT:2> <EOL> finally : <EOL> os . chdir ( old_wd ) <EOL> shutil . rmtree ( tmpdir ) <EOL> def _build_egg ( egg , tarball , to_dir ) : <EOL> tmpdir = tempfile . mkdtemp ( ) <EOL> log . warn ( '<STR_LIT>' , tmpdir ) <EOL> old_wd = os . getcwd ( ) <EOL> try : <EOL> os . chdir ( tmpdir ) <EOL> tar = tarfile . open ( tarball ) <EOL> _extractall ( tar ) <EOL> tar . close ( ) <EOL> subdir = os . path . join ( tmpdir , os . listdir ( tmpdir ) [ <NUM_LIT:0> ] ) <EOL> os . chdir ( subdir ) <EOL> log . warn ( '<STR_LIT>' , subdir ) <EOL> log . warn ( '<STR_LIT>' , to_dir ) <EOL> _python_cmd ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , to_dir ) <EOL> finally : <EOL> os . chdir ( old_wd ) <EOL> shutil . rmtree ( tmpdir ) <EOL> log . warn ( egg ) <EOL> if not os . path . exists ( egg ) : <EOL> raise IOError ( '<STR_LIT>' ) <EOL> def _do_download ( version , download_base , to_dir , download_delay ) : <EOL> egg = os . path . join ( to_dir , '<STR_LIT>' <EOL> % ( version , sys . version_info [ <NUM_LIT:0> ] , sys . version_info [ <NUM_LIT:1> ] ) ) <EOL> if not os . path . exists ( egg ) : <EOL> tarball = download_setuptools ( version , download_base , <EOL> to_dir , download_delay ) <EOL> _build_egg ( egg , tarball , to_dir ) <EOL> sys . path . insert ( <NUM_LIT:0> , egg ) <EOL> if '<STR_LIT>' in sys . modules : <EOL> del sys . modules [ '<STR_LIT>' ] <EOL> import setuptools <EOL> setuptools . bootstrap_install_from = egg <EOL> def use_setuptools ( version = DEFAULT_VERSION , download_base = DEFAULT_URL , <EOL> to_dir = os . curdir , download_delay = <NUM_LIT:15> ) : <EOL> to_dir = os . path . abspath ( to_dir ) <EOL> rep_modules = '<STR_LIT>' , '<STR_LIT>' <EOL> imported = set ( sys . modules ) . intersection ( rep_modules ) <EOL> try : <EOL> import pkg_resources <EOL> except ImportError : <EOL> return _do_download ( version , download_base , to_dir , download_delay ) <EOL> try : <EOL> pkg_resources . require ( \"<STR_LIT>\" + version ) <EOL> return <EOL> except pkg_resources . DistributionNotFound : <EOL> return _do_download ( version , download_base , to_dir , download_delay ) <EOL> except pkg_resources . VersionConflict as VC_err : <EOL> if imported : <EOL> msg = textwrap . dedent ( \"\"\"<STR_LIT>\"\"\" ) . format ( VC_err = VC_err , version = version ) <EOL> sys . stderr . write ( msg ) <EOL> sys . exit ( <NUM_LIT:2> ) <EOL> del pkg_resources , sys . modules [ '<STR_LIT>' ] <EOL> return _do_download ( version , download_base , to_dir , download_delay ) <EOL> def _clean_check ( cmd , target ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> subprocess . check_call ( cmd ) <EOL> except subprocess . CalledProcessError : <EOL> if os . access ( target , os . F_OK ) : <EOL> os . unlink ( target ) <EOL> raise <EOL> def download_file_powershell ( url , target ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> target = os . path . abspath ( target ) <EOL> cmd = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> \"<STR_LIT>\" % vars ( ) , <EOL> ] <EOL> _clean_check ( cmd , target ) <EOL> def has_powershell ( ) : <EOL> if platform . system ( ) != '<STR_LIT>' : <EOL> return False <EOL> cmd = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> devnull = open ( os . path . devnull , '<STR_LIT:wb>' ) <EOL> try : <EOL> try : <EOL> subprocess . check_call ( cmd , stdout = devnull , stderr = devnull ) <EOL> except : <EOL> return False <EOL> finally : <EOL> devnull . close ( ) <EOL> return True <EOL> download_file_powershell . viable = has_powershell <EOL>"}
{"rec_id": "9266", "recitation_code": "toolbar . show ( )", "input_code_id": 9266, "input": "<s> import pygtk <EOL> pygtk . require ( '<STR_LIT>' ) <EOL> import gtk <EOL> class ToolbarExample : <EOL> def delete_event ( self , widget , event = None ) : <EOL> gtk . main_quit ( ) <EOL> return False <EOL> def radio_event ( self , widget , toolbar ) : <EOL> if self . text_button . get_active ( ) : <EOL> toolbar . set_style ( gtk . TOOLBAR_TEXT ) <EOL> elif self . icon_button . get_active ( ) : <EOL> toolbar . set_style ( gtk . TOOLBAR_ICONS ) <EOL> elif self . both_button . get_active ( ) : <EOL> toolbar . set_style ( gtk . TOOLBAR_BOTH ) <EOL> def toggle_event ( self , widget , toolbar ) : <EOL> toolbar . set_tooltips ( widget . get_active ( ) ) <EOL> def __init__ ( self ) : <EOL> dialog = gtk . Dialog ( ) <EOL> dialog . set_title ( \"<STR_LIT>\" ) <EOL> dialog . set_size_request ( <NUM_LIT> , <NUM_LIT> ) <EOL> dialog . set_resizable ( True ) <EOL> dialog . connect ( \"<STR_LIT>\" , self . delete_event ) <EOL> handlebox = gtk . HandleBox ( ) <EOL> dialog . vbox . pack_start ( handlebox , False , False , <NUM_LIT:5> ) <EOL> toolbar = gtk . Toolbar ( ) <EOL> toolbar . set_orientation ( gtk . ORIENTATION_HORIZONTAL ) <EOL> toolbar . set_style ( gtk . TOOLBAR_BOTH ) <EOL> toolbar . set_border_width ( <NUM_LIT:5> ) <EOL> handlebox . add ( toolbar ) <EOL> iconw = gtk . Image ( ) <EOL> iconw . set_from_file ( \"<STR_LIT>\" ) <EOL> close_button = toolbar . append_item ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> iconw , <EOL> self . delete_event ) <EOL> toolbar . append_space ( ) <EOL> iconw = gtk . Image ( ) <EOL> iconw . set_from_file ( \"<STR_LIT>\" ) <EOL> icon_button = toolbar . append_element ( <EOL> gtk . TOOLBAR_CHILD_RADIOBUTTON , <EOL> None , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> iconw , <EOL> self . radio_event , <EOL> toolbar ) <EOL> toolbar . append_space ( ) <EOL> self . icon_button = icon_button <EOL>"}
{"rec_id": "9266", "recitation_code": "toolbar . show ( )", "input_code_id": 28735, "input": "<s> import pygtk <EOL> pygtk . require ( '<STR_LIT>' ) <EOL> import gtk <EOL> class ToolbarExample : <EOL> def delete_event ( self , widget , event = None ) : <EOL> gtk . main_quit ( ) <EOL> return False <EOL> def radio_event ( self , widget , toolbar ) : <EOL> if self . text_button . get_active ( ) : <EOL> toolbar . set_style ( gtk . TOOLBAR_TEXT ) <EOL> elif self . icon_button . get_active ( ) : <EOL> toolbar . set_style ( gtk . TOOLBAR_ICONS ) <EOL> elif self . both_button . get_active ( ) : <EOL> toolbar . set_style ( gtk . TOOLBAR_BOTH ) <EOL> def toggle_event ( self , widget , toolbar ) : <EOL> toolbar . set_tooltips ( widget . get_active ( ) ) <EOL> def __init__ ( self ) : <EOL> dialog = gtk . Dialog ( ) <EOL> dialog . set_title ( \"<STR_LIT>\" ) <EOL> dialog . set_size_request ( <NUM_LIT> , <NUM_LIT> ) <EOL> dialog . set_resizable ( True ) <EOL> dialog . connect ( \"<STR_LIT>\" , self . delete_event ) <EOL> handlebox = gtk . HandleBox ( ) <EOL> dialog . vbox . pack_start ( handlebox , False , False , <NUM_LIT:5> ) <EOL> toolbar = gtk . Toolbar ( ) <EOL> toolbar . set_orientation ( gtk . ORIENTATION_HORIZONTAL ) <EOL> toolbar . set_style ( gtk . TOOLBAR_BOTH ) <EOL> toolbar . set_border_width ( <NUM_LIT:5> ) <EOL> handlebox . add ( toolbar ) <EOL> iconw = gtk . Image ( ) <EOL> iconw . set_from_file ( \"<STR_LIT>\" ) <EOL> close_button = toolbar . append_item ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> iconw , <EOL> self . delete_event ) <EOL> toolbar . append_space ( ) <EOL> iconw = gtk . Image ( ) <EOL> iconw . set_from_file ( \"<STR_LIT>\" ) <EOL> icon_button = toolbar . append_element ( <EOL> gtk . TOOLBAR_CHILD_RADIOBUTTON , <EOL> None , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> iconw , <EOL> self . radio_event , <EOL> toolbar ) <EOL> toolbar . append_space ( ) <EOL> self . icon_button = icon_button <EOL>"}
{"rec_id": "9385", "recitation_code": "p . line ( x , y , legend = \" \" )", "input_code_id": 9385, "input": "<s> import numpy as np <EOL> from bokeh . plotting import output_file , figure , show <EOL> x = np . linspace ( <NUM_LIT:0> , <NUM_LIT:4> * np . pi , <NUM_LIT:100> ) <EOL> y = np . sin ( x ) <EOL> output_file ( \"<STR_LIT>\" ) <EOL> p = figure ( ) <EOL> p . circle ( x , y , legend = \"<STR_LIT>\" ) <EOL> p . line ( x , y , legend = \"<STR_LIT>\" ) <EOL>"}
{"rec_id": "9385", "recitation_code": "p . line ( x , y , legend = \" \" )", "input_code_id": 33880, "input": "<s> import numpy as np <EOL> from bokeh . plotting import output_file , figure , show <EOL> x = np . linspace ( <NUM_LIT:0> , <NUM_LIT:4> * np . pi , <NUM_LIT:100> ) <EOL> y = np . sin ( x ) <EOL> output_file ( \"<STR_LIT>\" ) <EOL> p = figure ( ) <EOL> p . circle ( x , y , legend = \"<STR_LIT>\" ) <EOL> p . line ( x , y , legend = \"<STR_LIT>\" ) <EOL>"}
{"rec_id": "9385", "recitation_code": "p . line ( x , y , legend = \" \" )", "input_code_id": 54075, "input": "<s> import numpy as np <EOL> from bokeh . plotting import output_file , figure , show <EOL> x = np . linspace ( <NUM_LIT:0> , <NUM_LIT:4> * np . pi , <NUM_LIT:100> ) <EOL> y = np . sin ( x ) <EOL> output_file ( \"<STR_LIT>\" ) <EOL> p = figure ( ) <EOL> p . circle ( x , y , legend = \"<STR_LIT>\" ) <EOL> p . line ( x , y , legend = \"<STR_LIT>\" ) <EOL>"}
{"rec_id": "9495", "recitation_code": "def get WaterMarkTemplateId ( self ) :", "input_code_id": 9495, "input": "<s> from aliyunsdkcore . request import RpcRequest <EOL> class SearchWaterMarkTemplateRequest ( RpcRequest ) : <EOL> def __init__ ( self ) : <EOL> RpcRequest . __init__ ( self , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def get_OwnerId ( self ) : <EOL> return self . get_query_params ( ) . get ( '<STR_LIT>' ) <EOL> def set_OwnerId ( self , OwnerId ) : <EOL> self . add_query_param ( '<STR_LIT>' , OwnerId ) <EOL> def get_ResourceOwnerAccount ( self ) : <EOL> return self . get_query_params ( ) . get ( '<STR_LIT>' ) <EOL> def set_ResourceOwnerAccount ( self , ResourceOwnerAccount ) : <EOL> self . add_query_param ( '<STR_LIT>' , ResourceOwnerAccount ) <EOL> def get_ResourceOwnerId ( self ) : <EOL> return self . get_query_params ( ) . get ( '<STR_LIT>' ) <EOL> def set_ResourceOwnerId ( self , ResourceOwnerId ) : <EOL> self . add_query_param ( '<STR_LIT>' , ResourceOwnerId ) <EOL>"}
{"rec_id": "9495", "recitation_code": "def get WaterMarkTemplateId ( self ) :", "input_code_id": 73488, "input": "<s> from aliyunsdkcore . request import RpcRequest <EOL> class UpdateWaterMarkTemplateRequest ( RpcRequest ) : <EOL> def __init__ ( self ) : <EOL> RpcRequest . __init__ ( self , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def get_OwnerId ( self ) : <EOL> return self . get_query_params ( ) . get ( '<STR_LIT>' ) <EOL> def set_OwnerId ( self , OwnerId ) : <EOL> self . add_query_param ( '<STR_LIT>' , OwnerId ) <EOL> def get_ResourceOwnerAccount ( self ) : <EOL> return self . get_query_params ( ) . get ( '<STR_LIT>' ) <EOL> def set_ResourceOwnerAccount ( self , ResourceOwnerAccount ) : <EOL> self . add_query_param ( '<STR_LIT>' , ResourceOwnerAccount ) <EOL> def get_ResourceOwnerId ( self ) : <EOL> return self . get_query_params ( ) . get ( '<STR_LIT>' ) <EOL> def set_ResourceOwnerId ( self , ResourceOwnerId ) : <EOL> self . add_query_param ( '<STR_LIT>' , ResourceOwnerId ) <EOL>"}
{"rec_id": "9698", "recitation_code": "if not path spec . HasParent ( ) :", "input_code_id": 2991, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import abc <EOL> from dfvfs . lib import errors <EOL> from dfvfs . vfs import file_system <EOL> class RootOnlyFileSystem ( file_system . FileSystem ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _Close ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return <EOL> def _Open ( self , path_spec , mode = '<STR_LIT:rb>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>"}
{"rec_id": "9698", "recitation_code": "if not path spec . HasParent ( ) :", "input_code_id": 9698, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from dfvfs . lib import definitions <EOL> from dfvfs . lib import errors <EOL> from dfvfs . path import encrypted_stream_path_spec <EOL> from dfvfs . vfs import encrypted_stream_file_entry <EOL> from dfvfs . vfs import root_only_file_system <EOL> class EncryptedStreamFileSystem ( root_only_file_system . RootOnlyFileSystem ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> TYPE_INDICATOR = definitions . TYPE_INDICATOR_ENCRYPTED_STREAM <EOL> def __init__ ( self , resolver_context ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> super ( EncryptedStreamFileSystem , self ) . __init__ ( resolver_context ) <EOL> self . _encryption_method = None <EOL> def _Close ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _encryption_method = None <EOL> def _Open ( self , path_spec , mode = '<STR_LIT:rb>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>"}
{"rec_id": "9709", "recitation_code": "self . assertTrue ( ret val . id )", "input_code_id": 9709, "input": "<s> from openstack_dashboard import api <EOL> from openstack_dashboard . test import helpers as test <EOL> from neutronclient . v2_0 . client import Client as neutronclient <EOL> class FwaasApiTests ( test . APITestCase ) : <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_rule_create ( self ) : <EOL> rule1 = self . fw_rules . first ( ) <EOL> rule1_dict = self . api_fw_rules . first ( ) <EOL> form_data = { '<STR_LIT:name>' : rule1 . name , <EOL> '<STR_LIT:description>' : rule1 . description , <EOL> '<STR_LIT>' : rule1 . protocol , <EOL> '<STR_LIT:action>' : rule1 . action , <EOL> '<STR_LIT>' : rule1 . source_ip_address , <EOL> '<STR_LIT>' : rule1 . source_port , <EOL> '<STR_LIT>' : rule1 . destination_ip_address , <EOL> '<STR_LIT>' : rule1 . destination_port , <EOL> '<STR_LIT>' : rule1 . shared , <EOL> '<STR_LIT>' : rule1 . enabled <EOL> } <EOL> form_dict = { '<STR_LIT>' : form_data } <EOL> ret_dict = { '<STR_LIT>' : rule1_dict } <EOL> neutronclient . create_firewall_rule ( form_dict ) . AndReturn ( ret_dict ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . fwaas . rule_create ( self . request , ** form_data ) <EOL> self . assertIsInstance ( ret_val , api . fwaas . Rule ) <EOL> self . assertEqual ( rule1 . name , ret_val . name ) <EOL> self . assertTrue ( ret_val . id ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , <EOL> '<STR_LIT>' ) } ) <EOL> def test_rule_list ( self ) : <EOL> exp_rules = self . fw_rules . list ( ) <EOL> api_rules = { '<STR_LIT>' : self . api_fw_rules . list ( ) } <EOL> api_policies = { '<STR_LIT>' : self . api_fw_policies . list ( ) } <EOL> neutronclient . list_firewall_rules ( ) . AndReturn ( api_rules ) <EOL> neutronclient . list_firewall_policies ( ) . AndReturn ( api_policies ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . fwaas . rule_list ( self . request ) <EOL> for ( v , d ) in zip ( ret_val , exp_rules ) : <EOL> self . assertIsInstance ( v , api . fwaas . Rule ) <EOL> self . assertEqual ( d . name , v . name ) <EOL> self . assertTrue ( v . id ) <EOL> if d . policy : <EOL> self . assertEqual ( d . firewall_policy_id , v . policy . id , ) <EOL> self . assertEqual ( d . policy . name , v . policy . name ) <EOL> else : <EOL> self . assertIsNone ( v . policy ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , <EOL> '<STR_LIT>' ) } ) <EOL> def test_rule_get ( self ) : <EOL> exp_rule = self . fw_rules . first ( ) <EOL> ret_dict = { '<STR_LIT>' : self . api_fw_rules . first ( ) } <EOL> policy_dict = { '<STR_LIT>' : self . api_fw_policies . first ( ) } <EOL> neutronclient . show_firewall_rule ( exp_rule . id ) . AndReturn ( ret_dict ) <EOL> neutronclient . show_firewall_policy ( <EOL> exp_rule . firewall_policy_id ) . AndReturn ( policy_dict ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . fwaas . rule_get ( self . request , exp_rule . id ) <EOL> self . assertIsInstance ( ret_val , api . fwaas . Rule ) <EOL> self . assertEqual ( exp_rule . name , ret_val . name ) <EOL> self . assertTrue ( ret_val . id ) <EOL> self . assertEqual ( exp_rule . firewall_policy_id , ret_val . policy . id ) <EOL> self . assertEqual ( exp_rule . policy . name , ret_val . policy . name ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_rule_update ( self ) : <EOL> rule = self . fw_rules . first ( ) <EOL> rule_dict = self . api_fw_rules . first ( ) <EOL> rule . name = '<STR_LIT>' <EOL> rule . description = '<STR_LIT>' <EOL> rule . protocol = '<STR_LIT>' <EOL> rule . action = '<STR_LIT>' <EOL> rule . shared = True <EOL> rule . enabled = False <EOL> rule_dict [ '<STR_LIT:name>' ] = '<STR_LIT>' <EOL> rule_dict [ '<STR_LIT:description>' ] = '<STR_LIT>' <EOL> rule_dict [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> rule_dict [ '<STR_LIT:action>' ] = '<STR_LIT>' <EOL> rule_dict [ '<STR_LIT>' ] = True <EOL> rule_dict [ '<STR_LIT>' ] = False <EOL> form_data = { '<STR_LIT:name>' : rule . name , <EOL> '<STR_LIT:description>' : rule . description , <EOL> '<STR_LIT>' : rule . protocol , <EOL> '<STR_LIT:action>' : rule . action , <EOL> '<STR_LIT>' : rule . shared , <EOL> '<STR_LIT>' : rule . enabled <EOL> } <EOL> form_dict = { '<STR_LIT>' : form_data } <EOL> ret_dict = { '<STR_LIT>' : rule_dict } <EOL> neutronclient . update_firewall_rule ( <EOL> rule . id , form_dict ) . AndReturn ( ret_dict ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . fwaas . rule_update ( self . request , <EOL> rule . id , ** form_data ) <EOL> self . assertIsInstance ( ret_val , api . fwaas . Rule ) <EOL> self . assertEqual ( rule . name , ret_val . name ) <EOL> self . assertTrue ( ret_val . id ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_policy_create ( self ) : <EOL> policy1 = self . fw_policies . first ( ) <EOL> policy1_dict = self . api_fw_policies . first ( ) <EOL> form_data = { '<STR_LIT:name>' : policy1 . name , <EOL> '<STR_LIT:description>' : policy1 . description , <EOL> '<STR_LIT>' : policy1 . firewall_rules , <EOL> '<STR_LIT>' : policy1 . shared , <EOL> '<STR_LIT>' : policy1 . audited <EOL> } <EOL> form_dict = { '<STR_LIT>' : form_data } <EOL> ret_dict = { '<STR_LIT>' : policy1_dict } <EOL> neutronclient . create_firewall_policy ( form_dict ) . AndReturn ( ret_dict ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . fwaas . policy_create ( self . request , ** form_data ) <EOL> self . assertIsInstance ( ret_val , api . fwaas . Policy ) <EOL> self . assertEqual ( policy1 . name , ret_val . name ) <EOL> self . assertTrue ( ret_val . id ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , <EOL> '<STR_LIT>' ) } ) <EOL> def test_policy_list ( self ) : <EOL> exp_policies = self . fw_policies . list ( ) <EOL> policies_dict = { '<STR_LIT>' : self . api_fw_policies . list ( ) } <EOL> rules_dict = { '<STR_LIT>' : self . api_fw_rules . list ( ) } <EOL> neutronclient . list_firewall_policies ( ) . AndReturn ( policies_dict ) <EOL> neutronclient . list_firewall_rules ( ) . AndReturn ( rules_dict ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . fwaas . policy_list ( self . request ) <EOL> for ( v , d ) in zip ( ret_val , exp_policies ) : <EOL> self . assertIsInstance ( v , api . fwaas . Policy ) <EOL> self . assertEqual ( d . name , v . name ) <EOL> self . assertTrue ( v . id ) <EOL> self . assertEqual ( len ( d . firewall_rules ) , len ( v . rules ) ) <EOL> self . assertEqual ( len ( d . firewall_rules ) , len ( v . firewall_rules ) ) <EOL> for ( r , exp_r ) in zip ( v . rules , d . rules ) : <EOL> self . assertEqual ( exp_r . id , r . id ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , <EOL> '<STR_LIT>' ) } ) <EOL> def test_policy_get ( self ) : <EOL> exp_policy = self . fw_policies . first ( ) <EOL> policy_dict = self . api_fw_policies . first ( ) <EOL> api_rules = self . api_fw_rules . list ( ) [ : <NUM_LIT:2> ] <EOL> ret_dict = { '<STR_LIT>' : policy_dict } <EOL> neutronclient . show_firewall_policy ( exp_policy . id ) . AndReturn ( ret_dict ) <EOL> filters = { '<STR_LIT>' : exp_policy . id } <EOL> ret_dict = { '<STR_LIT>' : api_rules } <EOL> neutronclient . list_firewall_rules ( ** filters ) . AndReturn ( ret_dict ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . fwaas . policy_get ( self . request , exp_policy . id ) <EOL> self . assertIsInstance ( ret_val , api . fwaas . Policy ) <EOL> self . assertEqual ( exp_policy . name , ret_val . name ) <EOL>"}
{"rec_id": "9709", "recitation_code": "self . assertTrue ( ret val . id )", "input_code_id": 82588, "input": "<s> from openstack_dashboard import api <EOL> from openstack_dashboard . test import helpers as test <EOL> from neutronclient . v2_0 . client import Client as neutronclient <EOL> class FwaasApiTests ( test . APITestCase ) : <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_rule_create ( self ) : <EOL> rule1 = self . fw_rules . first ( ) <EOL> rule1_dict = self . api_fw_rules . first ( ) <EOL> form_data = { '<STR_LIT:name>' : rule1 . name , <EOL> '<STR_LIT:description>' : rule1 . description , <EOL> '<STR_LIT>' : rule1 . protocol , <EOL> '<STR_LIT:action>' : rule1 . action , <EOL> '<STR_LIT>' : rule1 . source_ip_address , <EOL> '<STR_LIT>' : rule1 . source_port , <EOL> '<STR_LIT>' : rule1 . destination_ip_address , <EOL> '<STR_LIT>' : rule1 . destination_port , <EOL> '<STR_LIT>' : rule1 . shared , <EOL> '<STR_LIT>' : rule1 . enabled <EOL> } <EOL> form_dict = { '<STR_LIT>' : form_data } <EOL> ret_dict = { '<STR_LIT>' : rule1_dict } <EOL> neutronclient . create_firewall_rule ( form_dict ) . AndReturn ( ret_dict ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . fwaas . rule_create ( self . request , ** form_data ) <EOL> self . assertIsInstance ( ret_val , api . fwaas . Rule ) <EOL> self . assertEqual ( rule1 . name , ret_val . name ) <EOL> self . assertTrue ( ret_val . id ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , <EOL> '<STR_LIT>' ) } ) <EOL> def test_rules_list ( self ) : <EOL> exp_rules = self . fw_rules . list ( ) <EOL> api_rules = { '<STR_LIT>' : self . api_fw_rules . list ( ) } <EOL> api_policies = { '<STR_LIT>' : self . api_fw_policies . list ( ) } <EOL> neutronclient . list_firewall_rules ( ) . AndReturn ( api_rules ) <EOL> neutronclient . list_firewall_policies ( ) . AndReturn ( api_policies ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . fwaas . rules_list ( self . request ) <EOL> for ( v , d ) in zip ( ret_val , exp_rules ) : <EOL> self . assertIsInstance ( v , api . fwaas . Rule ) <EOL> self . assertEqual ( v . name , d . name ) <EOL> self . assertTrue ( v . id ) <EOL> if d . policy : <EOL> self . assertEqual ( v . policy . id , d . firewall_policy_id ) <EOL> self . assertEqual ( v . policy . name , d . policy . name ) <EOL> else : <EOL> self . assertIsNone ( v . policy ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , <EOL> '<STR_LIT>' ) } ) <EOL> def test_rule_get ( self ) : <EOL> exp_rule = self . fw_rules . first ( ) <EOL> ret_dict = { '<STR_LIT>' : self . api_fw_rules . first ( ) } <EOL> policy_dict = { '<STR_LIT>' : self . api_fw_policies . first ( ) } <EOL> neutronclient . show_firewall_rule ( exp_rule . id ) . AndReturn ( ret_dict ) <EOL> neutronclient . show_firewall_policy ( <EOL> exp_rule . firewall_policy_id ) . AndReturn ( policy_dict ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . fwaas . rule_get ( self . request , exp_rule . id ) <EOL> self . assertIsInstance ( ret_val , api . fwaas . Rule ) <EOL> self . assertEqual ( exp_rule . name , ret_val . name ) <EOL> self . assertTrue ( ret_val . id ) <EOL> self . assertEqual ( ret_val . policy . id , exp_rule . firewall_policy_id ) <EOL> self . assertEqual ( ret_val . policy . name , exp_rule . policy . name ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_rule_update ( self ) : <EOL> rule = self . fw_rules . first ( ) <EOL> rule_dict = self . api_fw_rules . first ( ) <EOL> rule . name = '<STR_LIT>' <EOL> rule . description = '<STR_LIT>' <EOL> rule . protocol = '<STR_LIT>' <EOL> rule . action = '<STR_LIT>' <EOL> rule . shared = True <EOL> rule . enabled = False <EOL> rule_dict [ '<STR_LIT:name>' ] = '<STR_LIT>' <EOL> rule_dict [ '<STR_LIT:description>' ] = '<STR_LIT>' <EOL> rule_dict [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> rule_dict [ '<STR_LIT:action>' ] = '<STR_LIT>' <EOL> rule_dict [ '<STR_LIT>' ] = True <EOL> rule_dict [ '<STR_LIT>' ] = False <EOL> form_data = { '<STR_LIT:name>' : rule . name , <EOL> '<STR_LIT:description>' : rule . description , <EOL> '<STR_LIT>' : rule . protocol , <EOL> '<STR_LIT:action>' : rule . action , <EOL> '<STR_LIT>' : rule . shared , <EOL> '<STR_LIT>' : rule . enabled <EOL> } <EOL> form_dict = { '<STR_LIT>' : form_data } <EOL> ret_dict = { '<STR_LIT>' : rule_dict } <EOL> neutronclient . update_firewall_rule ( <EOL> rule . id , form_dict ) . AndReturn ( ret_dict ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . fwaas . rule_update ( self . request , <EOL> rule . id , ** form_data ) <EOL> self . assertIsInstance ( ret_val , api . fwaas . Rule ) <EOL> self . assertEqual ( rule . name , ret_val . name ) <EOL> self . assertTrue ( ret_val . id ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_policy_create ( self ) : <EOL> policy1 = self . fw_policies . first ( ) <EOL> policy1_dict = self . api_fw_policies . first ( ) <EOL> form_data = { '<STR_LIT:name>' : policy1 . name , <EOL> '<STR_LIT:description>' : policy1 . description , <EOL> '<STR_LIT>' : policy1 . firewall_rules , <EOL> '<STR_LIT>' : policy1 . shared , <EOL> '<STR_LIT>' : policy1 . audited <EOL> } <EOL> form_dict = { '<STR_LIT>' : form_data } <EOL> ret_dict = { '<STR_LIT>' : policy1_dict } <EOL> neutronclient . create_firewall_policy ( form_dict ) . AndReturn ( ret_dict ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . fwaas . policy_create ( self . request , ** form_data ) <EOL> self . assertIsInstance ( ret_val , api . fwaas . Policy ) <EOL> self . assertEqual ( policy1 . name , ret_val . name ) <EOL> self . assertTrue ( ret_val . id ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , <EOL> '<STR_LIT>' ) } ) <EOL> def test_policies_list ( self ) : <EOL> exp_policies = self . fw_policies . list ( ) <EOL> policies_dict = { '<STR_LIT>' : self . api_fw_policies . list ( ) } <EOL> rules_dict = { '<STR_LIT>' : self . api_fw_rules . list ( ) } <EOL> neutronclient . list_firewall_policies ( ) . AndReturn ( policies_dict ) <EOL> neutronclient . list_firewall_rules ( ) . AndReturn ( rules_dict ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . fwaas . policies_list ( self . request ) <EOL> for ( v , d ) in zip ( ret_val , exp_policies ) : <EOL> self . assertIsInstance ( v , api . fwaas . Policy ) <EOL> self . assertEqual ( v . name , d . name ) <EOL> self . assertTrue ( v . id ) <EOL> self . assertEqual ( len ( d . firewall_rules ) , len ( v . rules ) ) <EOL> self . assertEqual ( len ( d . firewall_rules ) , len ( v . firewall_rules ) ) <EOL> for ( r , exp_r ) in zip ( v . rules , d . rules ) : <EOL> self . assertEqual ( r . id , exp_r . id ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , <EOL> '<STR_LIT>' ) } ) <EOL> def test_policy_get ( self ) : <EOL> exp_policy = self . fw_policies . first ( ) <EOL> policy_dict = self . api_fw_policies . first ( ) <EOL> api_rules = self . api_fw_rules . list ( ) [ : <NUM_LIT:2> ] <EOL> ret_dict = { '<STR_LIT>' : policy_dict } <EOL> neutronclient . show_firewall_policy ( exp_policy . id ) . AndReturn ( ret_dict ) <EOL> filters = { '<STR_LIT>' : exp_policy . id } <EOL> ret_dict = { '<STR_LIT>' : api_rules } <EOL> neutronclient . list_firewall_rules ( ** filters ) . AndReturn ( ret_dict ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . fwaas . policy_get ( self . request , exp_policy . id ) <EOL> self . assertIsInstance ( ret_val , api . fwaas . Policy ) <EOL> self . assertEqual ( exp_policy . name , ret_val . name ) <EOL>"}
{"rec_id": "9718", "recitation_code": "vbox . pack start ( toolbar , False )", "input_code_id": 9718, "input": "<s> import pygtk <EOL> pygtk . require ( '<STR_LIT>' ) <EOL> import gtk <EOL> class UIManagerExample : <EOL> ui = '''<STR_LIT>''' <EOL> def __init__ ( self ) : <EOL> window = gtk . Window ( ) <EOL> window . connect ( '<STR_LIT>' , lambda w : gtk . main_quit ( ) ) <EOL> window . set_size_request ( <NUM_LIT> , - <NUM_LIT:1> ) <EOL> vbox = gtk . VBox ( ) <EOL> window . add ( vbox ) <EOL> uimanager = gtk . UIManager ( ) <EOL> accelgroup = uimanager . get_accel_group ( ) <EOL> window . add_accel_group ( accelgroup ) <EOL> actiongroup = gtk . ActionGroup ( '<STR_LIT>' ) <EOL> self . actiongroup = actiongroup <EOL> actiongroup . add_toggle_actions ( [ ( '<STR_LIT>' , None , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , self . mute_cb ) ] ) <EOL> actiongroup . add_actions ( [ ( '<STR_LIT>' , gtk . STOCK_QUIT , '<STR_LIT>' , None , <EOL> '<STR_LIT>' , self . quit_cb ) , <EOL> ( '<STR_LIT>' , None , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , None , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , None , '<STR_LIT>' ) ] ) <EOL> actiongroup . get_action ( '<STR_LIT>' ) . set_property ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> actiongroup . add_radio_actions ( [ ( '<STR_LIT>' , None , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , <NUM_LIT:0> ) , <EOL> ( '<STR_LIT>' , None , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , <NUM_LIT:1> ) , <EOL> ( '<STR_LIT>' , None , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , <NUM_LIT:2> ) , <EOL> ] , <NUM_LIT:0> , self . radioband_cb ) <EOL> uimanager . insert_action_group ( actiongroup , <NUM_LIT:0> ) <EOL> uimanager . add_ui_from_string ( self . ui ) <EOL> menubar = uimanager . get_widget ( '<STR_LIT>' ) <EOL> vbox . pack_start ( menubar , False ) <EOL> toolbar = uimanager . get_widget ( '<STR_LIT>' ) <EOL> vbox . pack_start ( toolbar , False ) <EOL>"}
{"rec_id": "9718", "recitation_code": "vbox . pack start ( toolbar , False )", "input_code_id": 69488, "input": "<s> import pygtk <EOL> pygtk . require ( '<STR_LIT>' ) <EOL> import gtk <EOL> class UIMergeExample : <EOL> ui0 = '''<STR_LIT>''' <EOL> ui1 = '''<STR_LIT>''' <EOL> def __init__ ( self ) : <EOL> window = gtk . Window ( ) <EOL> window . connect ( '<STR_LIT>' , lambda w : gtk . main_quit ( ) ) <EOL> window . set_size_request ( <NUM_LIT> , - <NUM_LIT:1> ) <EOL> vbox = gtk . VBox ( ) <EOL> window . add ( vbox ) <EOL> self . merge_id = <NUM_LIT:0> <EOL> uimanager = gtk . UIManager ( ) <EOL> self . uimanager = uimanager <EOL> accelgroup = uimanager . get_accel_group ( ) <EOL> window . add_accel_group ( accelgroup ) <EOL> actiongroup0 = gtk . ActionGroup ( '<STR_LIT>' ) <EOL> actiongroup0 . add_actions ( [ ( '<STR_LIT>' , None , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , None , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , None , '<STR_LIT>' ) ] ) <EOL> uimanager . insert_action_group ( actiongroup0 , <NUM_LIT:0> ) <EOL> actiongroup = gtk . ActionGroup ( '<STR_LIT>' ) <EOL> self . actiongroup = actiongroup <EOL> actiongroup . add_toggle_actions ( [ ( '<STR_LIT>' , None , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , self . mute_cb ) ] ) <EOL> actiongroup . add_actions ( [ ( '<STR_LIT>' , gtk . STOCK_QUIT , '<STR_LIT>' , None , <EOL> '<STR_LIT>' , self . quit_cb ) ] ) <EOL> actiongroup . get_action ( '<STR_LIT>' ) . set_property ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> actiongroup . add_radio_actions ( [ ( '<STR_LIT>' , None , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , <NUM_LIT:0> ) , <EOL> ( '<STR_LIT>' , None , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , <NUM_LIT:1> ) , <EOL> ( '<STR_LIT>' , None , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , <NUM_LIT:2> ) , <EOL> ] , <NUM_LIT:0> , self . radioband_cb ) <EOL> uimanager . insert_action_group ( actiongroup , <NUM_LIT:1> ) <EOL> merge_id = uimanager . add_ui_from_string ( self . ui0 ) <EOL> actiongroup1 = gtk . ActionGroup ( '<STR_LIT>' ) <EOL> actiongroup1 . add_toggle_actions ( [ ( '<STR_LIT>' , None , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> self . loudness_cb ) ] ) <EOL> actiongroup1 . add_actions ( [ ( '<STR_LIT>' , gtk . STOCK_NEW , None , None , <EOL> '<STR_LIT>' , self . new_cb ) , <EOL> ( '<STR_LIT>' , gtk . STOCK_SAVE , None , None , <EOL> '<STR_LIT>' , self . save_cb ) ] ) <EOL> actiongroup1 . add_radio_actions ( [ ( '<STR_LIT>' , None , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , <NUM_LIT:3> ) , <EOL> ( '<STR_LIT>' , None , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT:4> ) , <EOL> ] , <NUM_LIT:3> , self . radioband_cb ) <EOL> group = actiongroup . get_action ( '<STR_LIT>' ) . get_group ( ) [ <NUM_LIT:0> ] <EOL> action = actiongroup1 . get_action ( '<STR_LIT>' ) <EOL> action . set_group ( group ) <EOL> action . set_active ( False ) <EOL> action = actiongroup1 . get_action ( '<STR_LIT>' ) <EOL> action . set_group ( group ) <EOL> action . set_active ( False ) <EOL> uimanager . insert_action_group ( actiongroup1 , <NUM_LIT:2> ) <EOL> menubar = uimanager . get_widget ( '<STR_LIT>' ) <EOL> vbox . pack_start ( menubar , False ) <EOL> toolbar = uimanager . get_widget ( '<STR_LIT>' ) <EOL>"}
{"rec_id": "9746", "recitation_code": "def cli ( ctx ) :", "input_code_id": 3487, "input": "<s> import click <EOL> from complex . cli import pass_context <EOL> @ click . command ( '<STR_LIT:status>' , short_help = '<STR_LIT>' ) <EOL> @ pass_context <EOL>"}
{"rec_id": "9746", "recitation_code": "def cli ( ctx ) :", "input_code_id": 9746, "input": "<s> import click <EOL> import inspector <EOL> import googleanalytics as ga <EOL> @ click . group ( invoke_without_command = True ) <EOL> @ click . option ( '<STR_LIT>' ) <EOL> @ click . option ( '<STR_LIT>' ) <EOL> @ click . option ( '<STR_LIT>' ) <EOL> @ click . option ( '<STR_LIT>' ) <EOL> @ click . option ( '<STR_LIT>' , is_flag = True ) <EOL> @ click . pass_context <EOL>"}
{"rec_id": "9867", "recitation_code": "@ pass logger", "input_code_id": 6938, "input": "<s> import click <EOL> from shpkpr . cli import arguments <EOL> from shpkpr . cli import options <EOL> from shpkpr . cli . entrypoint import CONTEXT_SETTINGS <EOL> from shpkpr . cli . logger import pass_logger <EOL> @ click . group ( '<STR_LIT>' , short_help = '<STR_LIT>' , context_settings = CONTEXT_SETTINGS ) <EOL> @ pass_logger <EOL> def cli ( logger ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ cli . command ( '<STR_LIT:list>' , short_help = '<STR_LIT>' , context_settings = CONTEXT_SETTINGS ) <EOL> @ options . application_id <EOL> @ options . marathon_client <EOL> @ pass_logger <EOL> def list ( logger , marathon_client , application_id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> application = marathon_client . get_application ( application_id ) <EOL> for k , v in sorted ( application [ '<STR_LIT>' ] . items ( ) ) : <EOL> logger . log ( \"<STR_LIT>\" , k , v ) <EOL> @ cli . command ( '<STR_LIT>' , short_help = '<STR_LIT>' , context_settings = CONTEXT_SETTINGS ) <EOL> @ arguments . env_pairs <EOL> @ options . application_id <EOL> @ options . force <EOL> @ options . marathon_client <EOL>"}
{"rec_id": "9867", "recitation_code": "@ pass logger", "input_code_id": 9867, "input": "<s> import click <EOL> from shpkpr . cli import options <EOL> from shpkpr . cli . entrypoint import CONTEXT_SETTINGS <EOL> from shpkpr . cli . logger import pass_logger <EOL> @ click . command ( '<STR_LIT:list>' , short_help = \"<STR_LIT>\" , context_settings = CONTEXT_SETTINGS ) <EOL>"}
{"rec_id": "9901", "recitation_code": "if self . supports set ciphers :", "input_code_id": 9901, "input": "<s> from binascii import hexlify , unhexlify <EOL> from hashlib import md5 , sha1 , sha256 <EOL> from . . exceptions import SSLError , InsecurePlatformWarning <EOL> SSLContext = None <EOL> HAS_SNI = False <EOL> create_default_context = None <EOL> HASHFUNC_MAP = { <EOL> <NUM_LIT:32> : md5 , <EOL> <NUM_LIT> : sha1 , <EOL> <NUM_LIT:64> : sha256 , <EOL> } <EOL> import errno <EOL> import warnings <EOL> try : <EOL> import ssl <EOL> from ssl import wrap_socket , CERT_NONE , PROTOCOL_SSLv23 <EOL> from ssl import HAS_SNI <EOL> except ImportError : <EOL> pass <EOL> try : <EOL> from ssl import OP_NO_SSLv2 , OP_NO_SSLv3 , OP_NO_COMPRESSION <EOL> except ImportError : <EOL> OP_NO_SSLv2 , OP_NO_SSLv3 = <NUM_LIT> , <NUM_LIT> <EOL> OP_NO_COMPRESSION = <NUM_LIT> <EOL> DEFAULT_CIPHERS = ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> ) <EOL> try : <EOL> from ssl import SSLContext <EOL> except ImportError : <EOL> import sys <EOL> class SSLContext ( object ) : <EOL> supports_set_ciphers = ( ( <NUM_LIT:2> , <NUM_LIT:7> ) <= sys . version_info < ( <NUM_LIT:3> , ) or <EOL> ( <NUM_LIT:3> , <NUM_LIT:2> ) <= sys . version_info ) <EOL> def __init__ ( self , protocol_version ) : <EOL> self . protocol = protocol_version <EOL> self . check_hostname = False <EOL> self . verify_mode = ssl . CERT_NONE <EOL> self . ca_certs = None <EOL> self . options = <NUM_LIT:0> <EOL> self . certfile = None <EOL> self . keyfile = None <EOL> self . ciphers = None <EOL> def load_cert_chain ( self , certfile , keyfile ) : <EOL> self . certfile = certfile <EOL> self . keyfile = keyfile <EOL> def load_verify_locations ( self , cafile = None , capath = None ) : <EOL> self . ca_certs = cafile <EOL> if capath is not None : <EOL> raise SSLError ( \"<STR_LIT>\" ) <EOL> def set_ciphers ( self , cipher_suite ) : <EOL> if not self . supports_set_ciphers : <EOL> raise TypeError ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> ) <EOL> self . ciphers = cipher_suite <EOL> def wrap_socket ( self , socket , server_hostname = None ) : <EOL> warnings . warn ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' , <EOL> InsecurePlatformWarning <EOL> ) <EOL> kwargs = { <EOL> '<STR_LIT>' : self . keyfile , <EOL> '<STR_LIT>' : self . certfile , <EOL> '<STR_LIT>' : self . ca_certs , <EOL> '<STR_LIT>' : self . verify_mode , <EOL> '<STR_LIT>' : self . protocol , <EOL> } <EOL>"}
{"rec_id": "9901", "recitation_code": "if self . supports set ciphers :", "input_code_id": 57567, "input": "<s> from __future__ import absolute_import <EOL> import errno <EOL> import warnings <EOL> import hmac <EOL> from binascii import hexlify , unhexlify <EOL> from hashlib import md5 , sha1 , sha256 <EOL> from . . exceptions import SSLError , InsecurePlatformWarning , SNIMissingWarning <EOL> SSLContext = None <EOL> HAS_SNI = False <EOL> create_default_context = None <EOL> HASHFUNC_MAP = { <EOL> <NUM_LIT:32> : md5 , <EOL> <NUM_LIT> : sha1 , <EOL> <NUM_LIT:64> : sha256 , <EOL> } <EOL> def _const_compare_digest_backport ( a , b ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> result = abs ( len ( a ) - len ( b ) ) <EOL> for l , r in zip ( bytearray ( a ) , bytearray ( b ) ) : <EOL> result |= l ^ r <EOL> return result == <NUM_LIT:0> <EOL> _const_compare_digest = getattr ( hmac , '<STR_LIT>' , <EOL> _const_compare_digest_backport ) <EOL> try : <EOL> import ssl <EOL> from ssl import wrap_socket , CERT_NONE , PROTOCOL_SSLv23 <EOL> from ssl import HAS_SNI <EOL> except ImportError : <EOL> pass <EOL> try : <EOL> from ssl import OP_NO_SSLv2 , OP_NO_SSLv3 , OP_NO_COMPRESSION <EOL> except ImportError : <EOL> OP_NO_SSLv2 , OP_NO_SSLv3 = <NUM_LIT> , <NUM_LIT> <EOL> OP_NO_COMPRESSION = <NUM_LIT> <EOL> DEFAULT_CIPHERS = ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> ) <EOL> try : <EOL> from ssl import SSLContext <EOL> except ImportError : <EOL> import sys <EOL> class SSLContext ( object ) : <EOL> supports_set_ciphers = ( ( <NUM_LIT:2> , <NUM_LIT:7> ) <= sys . version_info < ( <NUM_LIT:3> , ) or <EOL> ( <NUM_LIT:3> , <NUM_LIT:2> ) <= sys . version_info ) <EOL> def __init__ ( self , protocol_version ) : <EOL> self . protocol = protocol_version <EOL> self . check_hostname = False <EOL> self . verify_mode = ssl . CERT_NONE <EOL> self . ca_certs = None <EOL> self . options = <NUM_LIT:0> <EOL> self . certfile = None <EOL> self . keyfile = None <EOL> self . ciphers = None <EOL> def load_cert_chain ( self , certfile , keyfile ) : <EOL> self . certfile = certfile <EOL> self . keyfile = keyfile <EOL> def load_verify_locations ( self , cafile = None , capath = None ) : <EOL> self . ca_certs = cafile <EOL> if capath is not None : <EOL> raise SSLError ( \"<STR_LIT>\" ) <EOL> def set_ciphers ( self , cipher_suite ) : <EOL> if not self . supports_set_ciphers : <EOL> raise TypeError ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> ) <EOL> self . ciphers = cipher_suite <EOL> def wrap_socket ( self , socket , server_hostname = None ) : <EOL> warnings . warn ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' , <EOL> InsecurePlatformWarning <EOL> ) <EOL> kwargs = { <EOL> '<STR_LIT>' : self . keyfile , <EOL> '<STR_LIT>' : self . certfile , <EOL> '<STR_LIT>' : self . ca_certs , <EOL> '<STR_LIT>' : self . verify_mode , <EOL> '<STR_LIT>' : self . protocol , <EOL> } <EOL>"}
