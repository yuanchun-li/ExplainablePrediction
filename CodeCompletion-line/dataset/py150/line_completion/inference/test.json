{"id": "41906", "input": "<s> import itertools <EOL> import random <EOL> import pickle <EOL> import time <EOL> SUITS = ( '<STR_LIT:c>' , '<STR_LIT:d>' , '<STR_LIT:h>' , '<STR_LIT:s>' ) <EOL> RANKS = ( '<STR_LIT:2>' , '<STR_LIT:3>' , '<STR_LIT:4>' , '<STR_LIT:5>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:T>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:A>' ) <EOL> DECK = tuple ( '<STR_LIT>' . join ( card ) for card in itertools . product ( RANKS , SUITS ) ) <EOL> ORDER_LOOKUP = dict ( zip ( DECK , range ( <NUM_LIT> ) ) ) <EOL> RANK_LOOKUP = dict ( zip ( RANKS , range ( <NUM_LIT> ) ) ) <EOL> SUIT_LOOKUP = dict ( zip ( SUITS , range ( <NUM_LIT:4> ) ) ) <EOL> def cmp_cards ( a , b ) : <EOL> return cmp ( ORDER_LOOKUP [ a ] , ORDER_LOOKUP [ b ] ) <EOL> def cmp_tuples ( a , b ) : <EOL> n1 = len ( a ) <EOL> n2 = len ( b ) <EOL> if n1 != n2 : <EOL> return cmp ( n1 , n2 ) <EOL> return cmp ( a , b ) <EOL> def suit ( card ) : <EOL> return card [ <NUM_LIT:1> ] <EOL> def suit_int ( card ) : <EOL> return SUIT_LOOKUP [ card [ <NUM_LIT:1> ] ] <EOL> def rank ( card ) : <EOL> return card [ <NUM_LIT:0> ] <EOL> def rank_int ( card ) : <EOL> return RANK_LOOKUP [ card [ <NUM_LIT:0> ] ] <EOL> def card_int ( card ) : <EOL> s = <NUM_LIT:1> << suit_int ( card ) <EOL> r = rank_int ( card ) <EOL> c = ( s << <NUM_LIT:4> ) | r <EOL> return c <EOL> def is_straight ( cards ) : <EOL> previous = rank_int ( cards [ <NUM_LIT:0> ] ) - <NUM_LIT:1> <EOL> for card in cards : <EOL> r = rank_int ( card ) <EOL> if r != previous + <NUM_LIT:1> : <EOL> if not ( r == <NUM_LIT:12> and previous == <NUM_LIT:3> ) : <EOL> return False <EOL> previous = r <EOL> return True <EOL> def is_flush ( cards ) : <EOL> s = suit ( cards [ <NUM_LIT:0> ] ) <EOL> return all ( suit ( card ) == s for card in cards ) <EOL> def same_rank ( cards ) : <EOL> r = rank ( cards [ <NUM_LIT:0> ] ) <EOL> return all ( rank ( card ) == r for card in cards ) <EOL> def split_ranks ( cards , indexes ) : <EOL> for index in indexes : <EOL> a , b = cards [ : index ] , cards [ index : ] <EOL> if same_rank ( a ) and same_rank ( b ) : <EOL> return True <EOL> return False <EOL> def is_full_house ( cards ) : <EOL> return split_ranks ( cards , ( <NUM_LIT:2> , <NUM_LIT:3> ) ) <EOL> def is_four ( cards ) : <EOL> return split_ranks ( cards , ( <NUM_LIT:1> , <NUM_LIT:4> ) ) <EOL> def is_pat ( cards ) : <EOL> return is_straight ( cards ) or is_flush ( cards ) or is_full_house ( cards ) or is_four ( cards ) <EOL> def is_straight_flush ( cards ) : <EOL> return is_straight ( cards ) and is_flush ( cards ) <EOL> def rank_count ( cards ) : <EOL>", "gt": ""}
{"id": "7297", "input": "<s> import six <EOL> from sahara import exceptions as ex <EOL> from sahara . i18n import _ <EOL> def check_tenant_for_delete ( context , object ) : <EOL> if object . tenant_id != context . tenant_id : <EOL> raise ex . DeletionFailed ( <EOL> _ ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) . format ( <EOL> object = type ( object ) . __name__ , id = object . id ) ) <EOL> def check_tenant_for_update ( context , object ) : <EOL> if object . tenant_id != context . tenant_id : <EOL> raise ex . UpdateFailedException ( <EOL> object . id , <EOL> _ ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) . format ( <EOL> object = type ( object ) . __name__ ) ) <EOL> def check_protected_from_delete ( object ) : <EOL>", "gt": ""}
{"id": "1640", "input": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL>", "gt": ""}
{"id": "18025", "input": "<s> import ctypes <EOL> import logging <EOL> import os <EOL> class ColorizingStreamHandler ( logging . StreamHandler ) : <EOL> color_map = { <EOL> '<STR_LIT>' : <NUM_LIT:0> , <EOL> '<STR_LIT>' : <NUM_LIT:1> , <EOL> '<STR_LIT>' : <NUM_LIT:2> , <EOL> '<STR_LIT>' : <NUM_LIT:3> , <EOL> '<STR_LIT>' : <NUM_LIT:4> , <EOL> '<STR_LIT>' : <NUM_LIT:5> , <EOL> '<STR_LIT>' : <NUM_LIT:6> , <EOL> '<STR_LIT>' : <NUM_LIT:7> , <EOL> } <EOL> if os . name == '<STR_LIT>' : <EOL> level_map = { <EOL> logging . DEBUG : ( None , '<STR_LIT>' , True ) , <EOL> logging . INFO : ( None , '<STR_LIT>' , False ) , <EOL> logging . WARNING : ( None , '<STR_LIT>' , True ) , <EOL> logging . ERROR : ( None , '<STR_LIT>' , True ) , <EOL> logging . CRITICAL : ( '<STR_LIT>' , '<STR_LIT>' , True ) , <EOL> } <EOL> else : <EOL> level_map = { <EOL> logging . DEBUG : ( None , '<STR_LIT>' , False ) , <EOL> logging . INFO : ( None , '<STR_LIT>' , False ) , <EOL> logging . WARNING : ( None , '<STR_LIT>' , False ) , <EOL> logging . ERROR : ( None , '<STR_LIT>' , False ) , <EOL> logging . CRITICAL : ( '<STR_LIT>' , '<STR_LIT>' , True ) , <EOL> } <EOL> csi = '<STR_LIT>' <EOL> reset = '<STR_LIT>' <EOL> @ property <EOL> def is_tty ( self ) : <EOL> if os . environ . get ( '<STR_LIT>' ) : <EOL> return True <EOL> isatty = getattr ( self . stream , '<STR_LIT>' , None ) <EOL> return isatty and isatty ( ) <EOL> def emit ( self , record ) : <EOL> try : <EOL> message = self . format ( record ) <EOL> stream = self . stream <EOL> if not self . is_tty : <EOL> stream . write ( message ) <EOL> else : <EOL> self . output_colorized ( message ) <EOL> stream . write ( getattr ( self , '<STR_LIT>' , '<STR_LIT:\\n>' ) ) <EOL> self . flush ( ) <EOL> except ( KeyboardInterrupt , SystemExit ) : <EOL> raise <EOL> except : <EOL> self . handleError ( record ) <EOL> if os . name != '<STR_LIT>' : <EOL> def output_colorized ( self , message ) : <EOL> self . stream . write ( message ) <EOL> else : <EOL> import re <EOL> ansi_esc = re . compile ( r'<STR_LIT>' ) <EOL> nt_color_map = { <EOL> <NUM_LIT:0> : <NUM_LIT> , <EOL> <NUM_LIT:1> : <NUM_LIT> , <EOL> <NUM_LIT:2> : <NUM_LIT> , <EOL> <NUM_LIT:3> : <NUM_LIT> , <EOL> <NUM_LIT:4> : <NUM_LIT> , <EOL> <NUM_LIT:5> : <NUM_LIT> , <EOL>", "gt": ""}
{"id": "16050", "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import , unicode_literals <EOL> import time <EOL> from oauthlib . common import Request , generate_token <EOL> from . . import signature , utils , errors <EOL> from . . import CONTENT_TYPE_FORM_URLENCODED <EOL> from . . import SIGNATURE_HMAC , SIGNATURE_RSA <EOL> from . . import SIGNATURE_TYPE_AUTH_HEADER <EOL> from . . import SIGNATURE_TYPE_QUERY <EOL> from . . import SIGNATURE_TYPE_BODY <EOL> class BaseEndpoint ( object ) : <EOL> def __init__ ( self , request_validator , token_generator = None ) : <EOL> self . request_validator = request_validator <EOL> self . token_generator = token_generator or generate_token <EOL> def _get_signature_type_and_params ( self , request ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> header_params = signature . collect_parameters ( headers = request . headers , <EOL> exclude_oauth_signature = False , with_realm = True ) <EOL> body_params = signature . collect_parameters ( body = request . body , <EOL> exclude_oauth_signature = False ) <EOL> query_params = signature . collect_parameters ( uri_query = request . uri_query , <EOL> exclude_oauth_signature = False ) <EOL> params = [ ] <EOL> params . extend ( header_params ) <EOL> params . extend ( body_params ) <EOL> params . extend ( query_params ) <EOL> signature_types_with_oauth_params = list ( filter ( lambda s : s [ <NUM_LIT:2> ] , ( <EOL> ( SIGNATURE_TYPE_AUTH_HEADER , params , <EOL> utils . filter_oauth_params ( header_params ) ) , <EOL> ( SIGNATURE_TYPE_BODY , params , <EOL> utils . filter_oauth_params ( body_params ) ) , <EOL> ( SIGNATURE_TYPE_QUERY , params , <EOL> utils . filter_oauth_params ( query_params ) ) <EOL> ) ) ) <EOL> if len ( signature_types_with_oauth_params ) > <NUM_LIT:1> : <EOL> found_types = [ s [ <NUM_LIT:0> ] for s in signature_types_with_oauth_params ] <EOL> raise errors . InvalidRequestError ( <EOL> description = ( '<STR_LIT>' <EOL> '<STR_LIT>' , <EOL> '<STR_LIT:U+002CU+0020>' . join ( found_types ) ) ) <EOL> try : <EOL> signature_type , params , oauth_params = signature_types_with_oauth_params [ <EOL> <NUM_LIT:0> ] <EOL> except IndexError : <EOL> raise errors . InvalidRequestError ( <EOL> description = '<STR_LIT>' ) <EOL> return signature_type , params , oauth_params <EOL> def _create_request ( self , uri , http_method , body , headers ) : <EOL> headers = headers or { } <EOL> if ( \"<STR_LIT:Content-Type>\" in headers and <EOL> CONTENT_TYPE_FORM_URLENCODED in headers [ \"<STR_LIT:Content-Type>\" ] ) : <EOL> request = Request ( uri , http_method , body , headers ) <EOL> else : <EOL> request = Request ( uri , http_method , '<STR_LIT>' , headers ) <EOL> signature_type , params , oauth_params = ( <EOL> self . _get_signature_type_and_params ( request ) ) <EOL> if len ( dict ( oauth_params ) ) != len ( oauth_params ) : <EOL> raise errors . InvalidRequestError ( <EOL> description = '<STR_LIT>' ) <EOL> oauth_params = dict ( oauth_params ) <EOL> request . signature = oauth_params . get ( '<STR_LIT>' ) <EOL> request . client_key = oauth_params . get ( '<STR_LIT>' ) <EOL> request . resource_owner_key = oauth_params . get ( '<STR_LIT>' ) <EOL> request . nonce = oauth_params . get ( '<STR_LIT>' ) <EOL> request . timestamp = oauth_params . get ( '<STR_LIT>' ) <EOL> request . redirect_uri = oauth_params . get ( '<STR_LIT>' ) <EOL> request . verifier = oauth_params . get ( '<STR_LIT>' ) <EOL> request . signature_method = oauth_params . get ( '<STR_LIT>' ) <EOL> request . realm = dict ( params ) . get ( '<STR_LIT>' ) <EOL>", "gt": ""}
{"id": "14629", "input": "<s> from admin_honeypot import views <EOL> from django . conf . urls import url <EOL> urlpatterns = [ <EOL>", "gt": ""}
{"id": "9145", "input": "<s> from __future__ import print_function , division <EOL> from sympy import Symbol , O , Add <EOL> x = Symbol ( '<STR_LIT:x>' ) <EOL>", "gt": ""}
{"id": "6718", "input": "<s> import django <EOL> from django . apps import AppConfig <EOL> from django_jinja import base <EOL> class DjangoJinjaAppConfig ( AppConfig ) : <EOL>", "gt": ""}
{"id": "44349", "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> revision = '<STR_LIT>' <EOL> down_revision = '<STR_LIT>' <EOL> from alembic import op <EOL> import sqlalchemy as sa <EOL> def upgrade ( ) : <EOL> op . alter_column ( '<STR_LIT>' , '<STR_LIT>' , <EOL> existing_type = sa . INTEGER ( ) , <EOL>", "gt": ""}
{"id": "35742", "input": "<s> import numpy as np <EOL> import pybrain . rl . environments <EOL> from pybrain . utilities import one_to_n <EOL> from environment import Environment <EOL> class BalanceTask ( pybrain . rl . environments . EpisodicTask ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> max_tilt = np . pi / <NUM_LIT> <EOL> nactions = <NUM_LIT:9> <EOL> goto = False <EOL> def __init__ ( self , butt_disturbance_amplitude = <NUM_LIT> , only_steer = False , <EOL> max_time = <NUM_LIT> , randomInitState = False , x_goal = <NUM_LIT:10> , y_goal = <NUM_LIT:20> , ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> super ( BalanceTask , self ) . __init__ ( Environment ( randomInitState , x_goal , y_goal ) ) <EOL> self . _butt_disturbance_amplitude = butt_disturbance_amplitude <EOL> self . only_steer = only_steer <EOL> self . max_time = max_time <EOL> self . t = <NUM_LIT:0> <EOL> self . action_history = np . zeros ( self . nactions ) <EOL> @ property <EOL> def indim ( self ) : <EOL> return <NUM_LIT:1> <EOL> @ property <EOL> def outdim ( self ) : <EOL> return <NUM_LIT:5> <EOL> def reset ( self ) : <EOL> super ( BalanceTask , self ) . reset ( ) <EOL> self . t = <NUM_LIT:0> <EOL> def performAction ( self , action ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . t += <NUM_LIT:1> <EOL> self . action_history += one_to_n ( action [ <NUM_LIT:0> ] , self . nactions ) <EOL> assert round ( action [ <NUM_LIT:0> ] ) == action [ <NUM_LIT:0> ] <EOL> if self . only_steer : <EOL> T = <NUM_LIT:2> * ( action [ <NUM_LIT:0> ] / <NUM_LIT> - <NUM_LIT:1.0> ) <EOL> d = <NUM_LIT:0.> <EOL> else : <EOL> torque_selector = np . floor ( action [ <NUM_LIT:0> ] / <NUM_LIT> ) - <NUM_LIT:1.0> <EOL> T = <NUM_LIT:2> * torque_selector <EOL> p = <NUM_LIT> * np . random . rand ( ) - <NUM_LIT:1.0> <EOL> disp_selector = action [ <NUM_LIT:0> ] % <NUM_LIT:3> - <NUM_LIT:1.0> <EOL> d = <NUM_LIT> * disp_selector + self . _butt_disturbance_amplitude * p <EOL> super ( BalanceTask , self ) . performAction ( [ T , d ] ) <EOL> def getObservation ( self ) : <EOL> ( theta , thetad , omega , omegad , omegadd , <EOL> xf , yf , xb , yb , psi , psig ) = self . env . getSensors ( ) <EOL> return self . env . getSensors ( ) [ <NUM_LIT:0> : <NUM_LIT:5> ] <EOL> def isFinished ( self ) : <EOL> if np . abs ( self . env . getTilt ( ) ) > self . max_tilt : <EOL> return True <EOL> elapsed_time = self . env . time_step * self . t <EOL> if elapsed_time > self . max_time : <EOL> print '<STR_LIT>' , self . t , elapsed_time <EOL> return True <EOL> return False <EOL> def getReward ( self ) : <EOL> if np . abs ( self . env . getTilt ( ) ) > self . max_tilt : <EOL> return - <NUM_LIT:1.0> <EOL> return <NUM_LIT:0.0> <EOL> class GotoTask ( BalanceTask ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> goto = True <EOL> @ property <EOL> def outdim ( self ) : <EOL> return <NUM_LIT:9> <EOL> def getObservation ( self ) : <EOL> ( theta , thetad , omega , omegad , omegadd , <EOL> xf , yf , xb , yb , psi , psig ) = self . env . getSensors ( ) <EOL> return [ self . env . getSensors ( ) [ i ] for i in [ <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:5> , <NUM_LIT:6> , <NUM_LIT:9> , <NUM_LIT:10> ] ] <EOL> def isFinished ( self ) : <EOL> dist_to_goal = self . calc_dist_to_goal ( ) <EOL> if np . abs ( self . env . getTilt ( ) ) > self . max_tilt : <EOL> print '<STR_LIT>' , dist_to_goal <EOL> return True <EOL> if dist_to_goal < <NUM_LIT> : <EOL> print '<STR_LIT>' <EOL> return True <EOL> return False <EOL> def getReward ( self ) : <EOL> r_factor = <NUM_LIT> <EOL> if np . abs ( self . env . getTilt ( ) ) > self . max_tilt : <EOL> return - <NUM_LIT:1.0> <EOL> else : <EOL> temp = self . calc_dist_to_goal ( ) <EOL> heading = self . calc_angle_to_goal ( ) <EOL> if ( temp < <NUM_LIT> ) : <EOL> return <NUM_LIT> <EOL> else : <EOL> return ( <NUM_LIT> - heading ** <NUM_LIT:2> ) * r_factor <EOL> def calc_dist_to_goal ( self ) : <EOL> x_goal = self . env . x_goal <EOL> y_goal = self . env . y_goal <EOL> r_goal = self . env . r_goal <EOL> xf = self . env . getXF ( ) <EOL> yf = self . env . getYF ( ) <EOL> sqrd_dist_to_goal = ( x_goal - xf ) ** <NUM_LIT:2> + ( y_goal - yf ) ** <NUM_LIT:2> <EOL> temp = np . max ( [ <NUM_LIT:0> , sqrd_dist_to_goal - r_goal ** <NUM_LIT:2> ] ) <EOL> temp = np . sqrt ( temp ) <EOL> return temp <EOL> def calc_angle_to_goal ( self ) : <EOL> x_goal = self . env . x_goal <EOL> y_goal = self . env . y_goal <EOL> xf = self . env . getXF ( ) <EOL> xb = self . env . getXB ( ) <EOL> yf = self . env . getYF ( ) <EOL> yb = self . env . getYB ( ) <EOL> temp = ( xf - xb ) * ( x_goal - xf ) + ( yf - yb ) * ( y_goal - yf ) <EOL> scalar = temp / ( <NUM_LIT:1> * np . sqrt ( ( x_goal - xf ) ** <NUM_LIT:2> + ( y_goal - yf ) ** <NUM_LIT:2> ) ) <EOL> tvaer = ( - yf + yb ) * ( x_goal - xf ) + ( xf - xb ) * ( y_goal - yf ) <EOL> if tvaer <= <NUM_LIT:0> : <EOL> temp = scalar - <NUM_LIT:1> <EOL> else : <EOL> temp = np . abs ( scalar - <NUM_LIT:1> ) <EOL> return temp <EOL> class LinearFATileCoding3456BalanceTask ( BalanceTask ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> theta_bounds = np . array ( <EOL> [ - <NUM_LIT:0.5> * np . pi , - <NUM_LIT:1.0> , - <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT> , <NUM_LIT:1.0> , <NUM_LIT:0.5> * np . pi ] ) <EOL> thetad_bounds = np . array ( <EOL> [ - np . inf , - <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT> , np . inf ] ) <EOL> omega_bounds = np . array ( <EOL> [ - BalanceTask . max_tilt , - <NUM_LIT> , - <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT> , <NUM_LIT> , <EOL> BalanceTask . max_tilt ] ) <EOL> omegad_bounds = np . array ( <EOL> [ - np . inf , - <NUM_LIT:0.5> , - <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT> , <NUM_LIT:0.5> , np . inf ] ) <EOL> omegadd_bounds = np . array ( <EOL> [ - np . inf , - <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT> , np . inf ] ) <EOL> nbins_across_dims = [ <EOL> len ( theta_bounds ) - <NUM_LIT:1> , <EOL> len ( thetad_bounds ) - <NUM_LIT:1> , <EOL> len ( omega_bounds ) - <NUM_LIT:1> , <EOL> len ( omegad_bounds ) - <NUM_LIT:1> , <EOL> len ( omegadd_bounds ) - <NUM_LIT:1> ] <EOL> magic_array = np . cumprod ( [ <NUM_LIT:1> ] + nbins_across_dims ) [ : - <NUM_LIT:1> ] <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( LinearFATileCoding3456BalanceTask , self ) . __init__ ( * args , ** kwargs ) <EOL> self . bin_count = np . zeros ( self . outdim ) <EOL> @ property <EOL> def outdim ( self ) : <EOL> return <NUM_LIT> <EOL> def getBin ( self , theta , thetad , omega , omegad , omegadd ) : <EOL> bin_indices = [ <EOL> np . digitize ( [ theta ] , self . theta_bounds ) [ <NUM_LIT:0> ] - <NUM_LIT:1> , <EOL> np . digitize ( [ thetad ] , self . thetad_bounds ) [ <NUM_LIT:0> ] - <NUM_LIT:1> , <EOL> np . digitize ( [ omega ] , self . omega_bounds ) [ <NUM_LIT:0> ] - <NUM_LIT:1> , <EOL> np . digitize ( [ omegad ] , self . omegad_bounds ) [ <NUM_LIT:0> ] - <NUM_LIT:1> , <EOL> np . digitize ( [ omegadd ] , self . omegadd_bounds ) [ <NUM_LIT:0> ] - <NUM_LIT:1> , <EOL> ] <EOL> linear_index = np . dot ( self . magic_array , bin_indices ) <EOL> if linear_index > self . outdim : <EOL> print self . isFinished ( ) <EOL> print self . env . getTilt ( ) <EOL> print np . abs ( self . env . getTilt ( ) ) <EOL> print self . max_tilt <EOL> print np . abs ( self . env . getTilt ( ) ) > self . max_tilt <EOL> print self . env . getSensors ( ) [ <NUM_LIT:0> : <NUM_LIT:5> ] <EOL> print self . magic_array <EOL> print bin_index_for_each_dim <EOL> print linear_index <EOL> return linear_index <EOL> def getBinIndices ( self , linear_index ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return linear_index / self . magic_array % self . nbins_across_dims <EOL> def getObservation ( self ) : <EOL> ( theta , thetad , omega , omegad , omegadd , <EOL> xf , yf , xb , yb , psi , psig ) = self . env . getSensors ( ) <EOL> state = one_to_n ( self . getBin ( theta , thetad , omega , omegad , omegadd ) , <EOL> self . outdim ) <EOL> self . bin_count += state <EOL> return state <EOL> class LSPIBalanceTask ( BalanceTask ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ property <EOL> def outdim ( self ) : <EOL> return <NUM_LIT> <EOL> def getPhi ( self , theta , thetad , omega , omegad , omegadd ) : <EOL> return np . array ( [ <EOL> <NUM_LIT:1> , omega , omegad , omega ** <NUM_LIT:2> , omegad ** <NUM_LIT:2> , omega * omegad , <EOL> theta , thetad , theta ** <NUM_LIT:2> , thetad ** <NUM_LIT:2> , theta * thetad , <EOL> omega * theta , omega * theta ** <NUM_LIT:2> , omega ** <NUM_LIT:2> * theta , <EOL> ] ) <EOL> def getObservation ( self ) : <EOL> ( theta , thetad , omega , omegad , omegadd , <EOL> xf , yf , xb , yb , psi , psig ) = self . env . getSensors ( ) <EOL> return self . getPhi ( theta , thetad , omega , omegad , omegadd ) <EOL> class LSPIGotoTask ( BalanceTask ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , five_actions = False , rewardType = <NUM_LIT:1> , * args , ** kwargs ) : <EOL> BalanceTask . __init__ ( self , * args , ** kwargs ) <EOL> self . five_actions = five_actions <EOL> goto = True <EOL> if self . five_actions : <EOL> self . nactions = <NUM_LIT:5> <EOL> self . action_history = np . zeros ( self . nactions ) <EOL> self . rewardType = rewardType <EOL> @ property <EOL> def outdim ( self ) : <EOL> return <NUM_LIT:20> <EOL> def performAction ( self , action ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . five_actions : <EOL> p = <NUM_LIT> * np . random . rand ( ) - <NUM_LIT:1.0> <EOL> T = <NUM_LIT:0> <EOL> d = self . _butt_disturbance_amplitude * p <EOL> self . t += <NUM_LIT:1> <EOL> self . action_history += one_to_n ( action [ <NUM_LIT:0> ] , self . nactions ) <EOL> assert round ( action [ <NUM_LIT:0> ] ) == action [ <NUM_LIT:0> ] <EOL> if action [ <NUM_LIT:0> ] == <NUM_LIT:0> : <EOL> T = - <NUM_LIT:2> <EOL> elif action [ <NUM_LIT:0> ] == <NUM_LIT:1> : <EOL> T = <NUM_LIT:2> <EOL> elif action [ <NUM_LIT:0> ] == <NUM_LIT:2> : <EOL> d -= <NUM_LIT> <EOL> elif action [ <NUM_LIT:0> ] == <NUM_LIT:3> : <EOL> d += <NUM_LIT> <EOL> super ( BalanceTask , self ) . performAction ( [ T , d ] ) <EOL> else : <EOL> BalanceTask . performAction ( self , action ) <EOL> def getPhi ( self , theta , thetad , omega , omegad , omegadd , psig ) : <EOL>", "gt": ""}
{"id": "5698", "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from zope . interface import Attribute , Interface <EOL> class IInitializer ( Interface ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class IInitiatingInitializer ( IInitializer ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> xmlstream = Attribute ( \"\"\"<STR_LIT>\"\"\" ) <EOL> def initialize ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class IIQResponseTracker ( Interface ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> iqDeferreds = Attribute ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> class IXMPPHandler ( Interface ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> parent = Attribute ( \"\"\"<STR_LIT>\"\"\" ) <EOL> xmlstream = Attribute ( \"\"\"<STR_LIT>\"\"\" ) <EOL> def setHandlerParent ( parent ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def disownHandlerParent ( parent ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def makeConnection ( xs ) : <EOL>", "gt": ""}
{"id": "38699", "input": "<s> import datetime <EOL> from south . db import db <EOL> from south . v2 import SchemaMigration <EOL> from django . db import models <EOL> class Migration ( SchemaMigration ) : <EOL> def forwards ( self , orm ) : <EOL> db . create_table ( '<STR_LIT>' , ( <EOL> ( '<STR_LIT:id>' , self . gf ( '<STR_LIT>' ) ( primary_key = True ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( to = orm [ '<STR_LIT>' ] , null = True , blank = True ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( unique = True , max_length = <NUM_LIT:100> ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( max_length = <NUM_LIT> ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( max_length = <NUM_LIT> ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( db_index = True ) ) , <EOL> ) ) <EOL> db . send_create_signal ( '<STR_LIT>' , [ '<STR_LIT>' ] ) <EOL> def backwards ( self , orm ) : <EOL> db . delete_table ( '<STR_LIT>' ) <EOL> models = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:email>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:password>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:username>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' , '<STR_LIT>' : \"<STR_LIT>\" } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT:code>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:description>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:5>' , '<STR_LIT>' : '<STR_LIT:2>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT:email>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL>", "gt": ""}
{"id": "27652", "input": "<s> def comparer ( ) : <EOL> a = <NUM_LIT:3> <EOL> b = <NUM_LIT:4> <EOL>", "gt": ""}
{"id": "1953", "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from . library import * <EOL> from . array import * <EOL> from . features import * <EOL> def fast ( image , threshold = <NUM_LIT> , arc_length = <NUM_LIT:9> , non_max = True , feature_ratio = <NUM_LIT> , edge = <NUM_LIT:3> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> out = Features ( ) <EOL> safe_call ( backend . get ( ) . af_fast ( ct . pointer ( out . feat ) , <EOL> image . arr , ct . c_float ( threshold ) , ct . c_uint ( arc_length ) , non_max , <EOL> ct . c_float ( feature_ratio ) , ct . c_uint ( edge ) ) ) <EOL> return out <EOL> def harris ( image , max_corners = <NUM_LIT> , min_response = <NUM_LIT> , sigma = <NUM_LIT:1.0> , block_size = <NUM_LIT:0> , k_thr = <NUM_LIT> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> out = Features ( ) <EOL> safe_call ( backend . get ( ) . af_harris ( ct . pointer ( out . feat ) , <EOL> image . arr , ct . c_uint ( max_corners ) , ct . c_float ( min_response ) , <EOL> ct . c_float ( sigma ) , ct . c_uint ( block_size ) , ct . c_float ( k_thr ) ) ) <EOL> return out <EOL> def orb ( image , threshold = <NUM_LIT> , max_features = <NUM_LIT> , scale = <NUM_LIT> , num_levels = <NUM_LIT:4> , blur_image = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> feat = Features ( ) <EOL> desc = Array ( ) <EOL> safe_call ( backend . get ( ) . af_orb ( ct . pointer ( feat . feat ) , ct . pointer ( desc . arr ) , <EOL> ct . c_float ( threshold ) , ct . c_uint ( max_features ) , <EOL> ct . c_float ( scale ) , ct . c_uint ( num_levels ) , blur_image ) ) <EOL> return feat , desc <EOL> def hamming_matcher ( query , database , dim = <NUM_LIT:0> , num_nearest = <NUM_LIT:1> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> index = Array ( ) <EOL> dist = Array ( ) <EOL> safe_call ( backend . get ( ) . af_hamming_matcher ( ct . pointer ( idx . arr ) , ct . pointer ( dist . arr ) , <EOL> query . arr , database . arr , <EOL> c_dim_t ( dim ) , c_dim_t ( num_nearest ) ) ) <EOL> return index , dist <EOL> def nearest_neighbour ( query , database , dim = <NUM_LIT:0> , num_nearest = <NUM_LIT:1> , match_type = MATCH . SSD ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> index = Array ( ) <EOL> dist = Array ( ) <EOL> safe_call ( backend . get ( ) . af_nearest_neighbour ( ct . pointer ( idx . arr ) , ct . pointer ( dist . arr ) , <EOL> query . arr , database . arr , <EOL> c_dim_t ( dim ) , c_dim_t ( num_nearest ) , <EOL> match_type . value ) ) <EOL> return index , dist <EOL> def match_template ( image , template , match_type = MATCH . SAD ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "gt": ""}
{"id": "6141", "input": "<s> import os <EOL> import sys <EOL> import argparse <EOL> import itertools <EOL> import math <EOL> import time <EOL> import shlex <EOL> from fastqp import FastqReader , padbases , percentile , mean , bam_read_count , gc , window <EOL> from fastqp . plots import qualplot , qualdist , qualmap , nucplot , depthplot , gcplot , gcdist , kmerplot , mismatchplot , adaptermerplot <EOL> from fastqp . adapters import all_adapter_sequences <EOL> from collections import defaultdict <EOL> from simplesam import Reader , Sam <EOL> from subprocess import Popen , PIPE <EOL> from scipy import stats <EOL> from operator import mul <EOL> from six . moves import reduce <EOL> def run ( args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> time_start = time . time ( ) <EOL> if args . input . name != '<STR_LIT>' : <EOL> bsize = os . path . getsize ( args . input . name ) <EOL> est_counter = int ( ) <EOL> sample_lengths = list ( ) <EOL> sample_binsizes = list ( ) <EOL> act_nlines = int ( ) <EOL> name , ext = os . path . splitext ( args . input . name ) <EOL> if ( args . leftlimit > <NUM_LIT:0> ) and ( args . rightlimit > <NUM_LIT:0> ) : <EOL> if args . rightlimit < args . leftlimit : <EOL> sys . exit ( \"<STR_LIT>\" ) <EOL> if args . type : <EOL> ext = '<STR_LIT:.>' + args . type <EOL> if ext not in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] and args . input . name != '<STR_LIT>' : <EOL> sys . exit ( \"<STR_LIT>\" ) <EOL> if args . name : <EOL> sample_name = args . name <EOL> else : <EOL> sample_name = args . input . name <EOL> if ext in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> with FastqReader ( open ( args . input . name ) ) as fh : <EOL> for read in fh : <EOL> sample_lengths . append ( len ( read ) ) <EOL> sample_binsizes . append ( len ( str ( read ) ) ) <EOL> est_counter += <NUM_LIT:1> <EOL> if est_counter == <NUM_LIT> : <EOL> break <EOL> mean_bentry = mean ( sample_binsizes ) <EOL> mean_len = mean ( sample_lengths ) <EOL> est_nlines = int ( bsize / mean_bentry ) <EOL> if not args . quiet : <EOL> sys . stderr . write ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" . format ( bytes = mean_bentry , <EOL> len = mean_len , <EOL> est = est_nlines ) ) <EOL> elif ext == '<STR_LIT>' : <EOL> with Reader ( open ( args . input . name ) ) as fh : <EOL> for read in fh : <EOL> sample_lengths . append ( len ( read ) ) <EOL> sample_binsizes . append ( len ( str ( read ) ) ) <EOL> est_counter += <NUM_LIT:1> <EOL> if est_counter == <NUM_LIT> : <EOL> break <EOL> mean_bentry = mean ( sample_binsizes ) <EOL> mean_len = mean ( sample_lengths ) <EOL> est_nlines = int ( bsize / mean_bentry ) <EOL> if not args . quiet : <EOL> sys . stderr . write ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" . format ( bytes = mean_bentry , <EOL> len = mean_len , <EOL> est = est_nlines ) ) <EOL> elif ext == '<STR_LIT>' : <EOL> est_nlines = sum ( bam_read_count ( args . input . name ) ) <EOL> if not args . quiet : <EOL> sys . stderr . write ( \"<STR_LIT>\" . format ( est = est_nlines ) ) <EOL> elif ext == '<STR_LIT>' : <EOL> if args . binsize : <EOL> n = args . binsize <EOL> est_nlines = None <EOL> if not args . quiet : <EOL> sys . stderr . write ( \"<STR_LIT>\" . format ( binsize = n ) ) <EOL> else : <EOL> sys . stderr . write ( \"<STR_LIT>\" ) <EOL> p1 = Popen ( shlex . split ( '<STR_LIT>' % args . input . name ) , stdout = PIPE ) <EOL> p2 = Popen ( shlex . split ( '<STR_LIT>' ) , stdin = p1 . stdout , stdout = PIPE ) <EOL> est_nlines , _ = p2 . communicate ( ) <EOL> est_nlines = int ( est_nlines ) // <NUM_LIT:4> <EOL> if not args . quiet : <EOL> sys . stderr . write ( \"<STR_LIT>\" . format ( est = est_nlines ) ) <EOL> elif name == '<STR_LIT>' : <EOL> if args . binsize : <EOL> n = args . binsize <EOL> else : <EOL> n = <NUM_LIT:1> <EOL> if not args . quiet : <EOL> sys . stderr . write ( \"<STR_LIT>\" . format ( binsize = n ) ) <EOL> est_nlines = None <EOL> if est_nlines is not None : <EOL> if args . binsize : <EOL> n = args . binsize <EOL> else : <EOL> nf = math . floor ( est_nlines / args . nreads ) <EOL> if nf >= <NUM_LIT:1> : <EOL> n = int ( nf ) <EOL> else : <EOL> n = <NUM_LIT:1> <EOL> if not args . quiet : <EOL> sys . stderr . write ( \"<STR_LIT>\" . format ( binsize = n ) ) <EOL> if ext in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> infile = Reader ( args . input ) <EOL> else : <EOL> infile = FastqReader ( args . input , ext = ext ) <EOL> read_len = defaultdict ( int ) <EOL> cycle_nuc = defaultdict ( lambda : defaultdict ( int ) ) <EOL> cycle_qual = defaultdict ( lambda : defaultdict ( int ) ) <EOL> cycle_gc = defaultdict ( int ) <EOL> cycle_kmers = defaultdict ( lambda : defaultdict ( int ) ) <EOL> cycle_mismatch = { '<STR_LIT:C>' : defaultdict ( lambda : defaultdict ( int ) ) , <EOL> '<STR_LIT>' : defaultdict ( lambda : defaultdict ( int ) ) , <EOL> '<STR_LIT:A>' : defaultdict ( lambda : defaultdict ( int ) ) , <EOL> '<STR_LIT:T>' : defaultdict ( lambda : defaultdict ( int ) ) } <EOL> if args . count_duplicates : <EOL> try : <EOL> from pybloom import ScalableBloomFilter <EOL> bloom_filter = ScalableBloomFilter ( mode = ScalableBloomFilter . SMALL_SET_GROWTH ) <EOL> except ImportError : <EOL> sys . exit ( \"<STR_LIT>\" ) <EOL> duplicates = <NUM_LIT:0> <EOL> percent_complete = <NUM_LIT:10> <EOL> reads = infile . subsample ( n ) <EOL> for read in reads : <EOL> if isinstance ( read , Sam ) : <EOL> if args . aligned_only and not read . mapped : <EOL> continue <EOL> elif args . unaligned_only and read . mapped : <EOL> continue <EOL> if read . reverse : <EOL> seq = read . seq [ : : - <NUM_LIT:1> ] <EOL> qual = read . qual [ : : - <NUM_LIT:1> ] <EOL> else : <EOL> seq = read . seq <EOL> qual = read . qual <EOL> else : <EOL> seq = read . seq <EOL> qual = read . qual <EOL> if ( args . leftlimit == <NUM_LIT:1> ) and ( args . rightlimit < <NUM_LIT:0> ) : <EOL> pass <EOL> elif ( args . leftlimit >= <NUM_LIT:1> ) and ( args . rightlimit > <NUM_LIT:0> ) : <EOL> try : <EOL> seq = seq [ args . leftlimit - <NUM_LIT:1> : args . rightlimit ] <EOL> qual = qual [ args . leftlimit - <NUM_LIT:1> : args . rightlimit ] <EOL> except IndexError : <EOL> act_nlines += n <EOL> continue <EOL> elif ( args . leftlimit > <NUM_LIT:1> ) and ( args . rightlimit < <NUM_LIT:0> ) : <EOL> try : <EOL> seq = seq [ args . leftlimit - <NUM_LIT:1> : ] <EOL> qual = qual [ args . leftlimit - <NUM_LIT:1> : ] <EOL> except IndexError : <EOL> act_nlines += n <EOL>", "gt": ""}
{"id": "14329", "input": "<s> from django . contrib . contenttypes . models import ContentType <EOL> from lfs . core . utils import import_symbol <EOL> class Criteria ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def is_valid ( self , request , product = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for criterion in self . get_criteria ( ) : <EOL> criterion . request = request <EOL> criterion . product = product <EOL> if not criterion . is_valid ( ) : <EOL> return False <EOL> return True <EOL> def get_criteria ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> content_type = ContentType . objects . get_for_model ( self ) <EOL> criteria = [ ] <EOL> from lfs . criteria . models import Criterion <EOL> for criterion in Criterion . objects . filter ( content_id = self . id , content_type = content_type ) : <EOL> criteria . append ( criterion . get_content_object ( ) ) <EOL>", "gt": ""}
{"id": "15248", "input": "<s> from math import sin , cos , pi <EOL> import pg <EOL> import random <EOL> class LegoMan ( object ) : <EOL> def __init__ ( self ) : <EOL> self . x = ( random . random ( ) - <NUM_LIT:0.5> ) * <NUM_LIT:50> <EOL> self . z = ( random . random ( ) - <NUM_LIT:0.5> ) * <NUM_LIT:50> <EOL> self . a = random . random ( ) * pi * <NUM_LIT:2> <EOL> def update ( self , t , dt ) : <EOL> if random . random ( ) < <NUM_LIT> : <EOL> self . a += random . randint ( - <NUM_LIT:1> , <NUM_LIT:1> ) * pi / <NUM_LIT:8> <EOL> dx = cos ( self . a ) <EOL> dz = sin ( self . a ) <EOL> self . x += dx * dt <EOL> self . z += dz * dt <EOL> class Window ( pg . Window ) : <EOL> def setup ( self ) : <EOL> self . wasd = pg . WASD ( self , speed = <NUM_LIT:10> ) <EOL> self . wasd . look_at ( ( <NUM_LIT:0> , <NUM_LIT:8> , <NUM_LIT:30> ) , ( <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ) ) <EOL>", "gt": ""}
{"id": "33119", "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import <EOL> class CredTypes ( object ) : <EOL> HMAC = \"<STR_LIT>\" <EOL>", "gt": ""}
{"id": "39454", "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> import numpy as np <EOL> from . . pakbase import Package <EOL> from numpy import atleast_2d <EOL> from flopy . modflow . mfparbc import ModflowParBc as mfparbc <EOL> from numpy . lib . recfunctions import stack_arrays <EOL> class ModflowHfb ( Package ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , model , nphfb = <NUM_LIT:0> , mxfb = <NUM_LIT:0> , nhfbnp = <NUM_LIT:0> , <EOL> hfb_data = None , nacthfb = <NUM_LIT:0> , no_print = False , <EOL> options = None , extension = '<STR_LIT>' , unitnumber = <NUM_LIT> ) : <EOL> Package . __init__ ( self , model , extension , '<STR_LIT>' , <EOL> unitnumber ) <EOL> self . heading = '<STR_LIT>' <EOL> self . url = '<STR_LIT>' <EOL> self . nphfb = nphfb <EOL> self . mxfb = mxfb <EOL> self . nacthfb = nacthfb <EOL> self . no_print = no_print <EOL> self . np = <NUM_LIT:0> <EOL> if options is None : <EOL> options = [ ] <EOL> if self . no_print : <EOL> options . append ( '<STR_LIT>' ) <EOL> self . options = options <EOL> aux_names = [ ] <EOL> it = <NUM_LIT:0> <EOL> while it < len ( options ) : <EOL> print ( it , options [ it ] ) <EOL> if '<STR_LIT>' in options [ it ] . lower ( ) : <EOL> aux_names . append ( options [ it + <NUM_LIT:1> ] . lower ( ) ) <EOL> it += <NUM_LIT:1> <EOL> it += <NUM_LIT:1> <EOL> if hfb_data is None : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> self . nhfbnp = len ( hfb_data ) <EOL> self . hfb_data = ModflowHfb . get_empty ( self . nhfbnp ) <EOL> for ibnd , t in enumerate ( hfb_data ) : <EOL> self . hfb_data [ ibnd ] = tuple ( t ) <EOL> self . parent . add_package ( self ) <EOL> def ncells ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . nhfbnp <EOL> def write_file ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> f_hfb = open ( self . fn_path , '<STR_LIT:w>' ) <EOL> f_hfb . write ( '<STR_LIT>' . format ( self . heading ) ) <EOL> f_hfb . write ( '<STR_LIT>' . format ( self . nphfb , self . mxfb , self . nhfbnp ) ) <EOL> for option in self . options : <EOL> f_hfb . write ( '<STR_LIT>' . format ( option ) ) <EOL> f_hfb . write ( '<STR_LIT:\\n>' ) <EOL> for a in self . hfb_data : <EOL> f_hfb . write ( <EOL> '<STR_LIT>' . format ( a [ <NUM_LIT:0> ] + <NUM_LIT:1> , a [ <NUM_LIT:1> ] + <NUM_LIT:1> , a [ <NUM_LIT:2> ] + <NUM_LIT:1> , a [ <NUM_LIT:3> ] + <NUM_LIT:1> , a [ <NUM_LIT:4> ] + <NUM_LIT:1> , <EOL> a [ <NUM_LIT:5> ] ) ) <EOL> f_hfb . write ( '<STR_LIT>' . format ( self . nacthfb ) ) <EOL> f_hfb . close ( ) <EOL> @ staticmethod <EOL> def get_empty ( ncells = <NUM_LIT:0> , aux_names = None , structured = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> dtype = ModflowHfb . get_default_dtype ( structured = structured ) <EOL> if aux_names is not None : <EOL> dtype = Package . add_to_dtype ( dtype , aux_names , np . float32 ) <EOL> d = np . zeros ( ( ncells , len ( dtype ) ) , dtype = dtype ) <EOL> d [ : , : ] = - <NUM_LIT> <EOL> return np . core . records . fromarrays ( d . transpose ( ) , dtype = dtype ) <EOL> @ staticmethod <EOL> def get_default_dtype ( structured = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if structured : <EOL> dtype = np . dtype ( [ ( \"<STR_LIT:k>\" , np . int ) , <EOL> ( \"<STR_LIT>\" , np . int ) , ( \"<STR_LIT>\" , np . int ) , <EOL> ( \"<STR_LIT>\" , np . int ) , ( \"<STR_LIT>\" , np . int ) , <EOL> ( \"<STR_LIT>\" , np . float32 ) ] ) <EOL> else : <EOL> assert not structured , '<STR_LIT>' <EOL> return dtype <EOL> @ staticmethod <EOL> def load ( f , model , ext_unit_dict = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "gt": ""}
{"id": "1740", "input": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL>", "gt": ""}
{"id": "36782", "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import print_function <EOL> import monotonic <EOL> import time <EOL> import socket <EOL> import sys <EOL> import os <EOL> import platform <EOL> import re <EOL> from dronekit . util import errprinter <EOL> from pymavlink import mavutil , mavwp <EOL> from Queue import Queue , Empty <EOL> from threading import Thread <EOL> import types <EOL> import threading <EOL> import math <EOL> import copy <EOL> import collections <EOL> from pymavlink . dialects . v10 import ardupilotmega <EOL> class APIException ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , message ) : <EOL> super ( APIException , self ) . __init__ ( message ) <EOL> class Attitude ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , pitch , yaw , roll ) : <EOL> self . pitch = pitch <EOL> self . yaw = yaw <EOL> self . roll = roll <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" % ( self . pitch , self . yaw , self . roll ) <EOL> class LocationGlobal ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , lat , lon , alt = None ) : <EOL> self . lat = lat <EOL> self . lon = lon <EOL> self . alt = alt <EOL> self . local_frame = None <EOL> self . global_frame = None <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" % ( self . lat , self . lon , self . alt ) <EOL> class LocationGlobalRelative ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , lat , lon , alt = None ) : <EOL> self . lat = lat <EOL> self . lon = lon <EOL> self . alt = alt <EOL> self . local_frame = None <EOL> self . global_frame = None <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" % ( self . lat , self . lon , self . alt ) <EOL> class LocationLocal ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , north , east , down ) : <EOL> self . north = north <EOL> self . east = east <EOL> self . down = down <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" % ( self . north , self . east , self . down ) <EOL> class GPSInfo ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , eph , epv , fix_type , satellites_visible ) : <EOL> self . eph = eph <EOL> self . epv = epv <EOL> self . fix_type = fix_type <EOL> self . satellites_visible = satellites_visible <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" % ( self . fix_type , self . satellites_visible ) <EOL> class Battery ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , voltage , current , level ) : <EOL> self . voltage = voltage / <NUM_LIT> <EOL> if current == - <NUM_LIT:1> : <EOL> self . current = None <EOL> else : <EOL> self . current = current / <NUM_LIT> <EOL> if level == - <NUM_LIT:1> : <EOL> self . level = None <EOL> else : <EOL> self . level = level <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" . format ( self . voltage , self . current , <EOL> self . level ) <EOL> class Rangefinder ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , distance , voltage ) : <EOL> self . distance = distance <EOL> self . voltage = voltage <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" . format ( self . distance , self . voltage ) <EOL> class Version ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , raw_version , autopilot_type , vehicle_type ) : <EOL> self . autopilot_type = autopilot_type <EOL> self . vehicle_type = vehicle_type <EOL> self . raw_version = raw_version <EOL> if ( raw_version == None ) : <EOL> self . major = None <EOL> self . minor = None <EOL> self . patch = None <EOL> self . release = None <EOL> else : <EOL> self . major = raw_version >> <NUM_LIT> & <NUM_LIT> <EOL> self . minor = raw_version >> <NUM_LIT:16> & <NUM_LIT> <EOL> self . patch = raw_version >> <NUM_LIT:8> & <NUM_LIT> <EOL> self . release = raw_version & <NUM_LIT> <EOL> def is_stable ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . release == <NUM_LIT:255> <EOL> def release_version ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . release is None : <EOL> return None <EOL> if ( self . release == <NUM_LIT:255> ) : <EOL> return <NUM_LIT:0> <EOL> return self . release % <NUM_LIT:64> <EOL> def release_type ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . release is None : <EOL> return None <EOL> types = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> return types [ self . release / <NUM_LIT:64> ] <EOL> def __str__ ( self ) : <EOL> prefix = \"<STR_LIT>\" <EOL> if ( self . autopilot_type == mavutil . mavlink . MAV_AUTOPILOT_ARDUPILOTMEGA ) : <EOL> prefix += \"<STR_LIT>\" <EOL> elif ( self . autopilot_type == mavutil . mavlink . MAV_AUTOPILOT_PX4 ) : <EOL> prefix += \"<STR_LIT>\" <EOL> else : <EOL> prefix += \"<STR_LIT>\" <EOL> if ( self . vehicle_type == mavutil . mavlink . MAV_TYPE_QUADROTOR ) : <EOL> prefix += \"<STR_LIT>\" <EOL> elif ( self . vehicle_type == mavutil . mavlink . MAV_TYPE_FIXED_WING ) : <EOL> prefix += \"<STR_LIT>\" <EOL> elif ( self . vehicle_type == mavutil . mavlink . MAV_TYPE_GROUND_ROVER ) : <EOL> prefix += \"<STR_LIT>\" <EOL> else : <EOL> prefix += \"<STR_LIT>\" % ( self . vehicle_type ) <EOL> if self . release_type ( ) is None : <EOL> release_type = \"<STR_LIT>\" <EOL> elif self . is_stable ( ) : <EOL> release_type = \"<STR_LIT>\" <EOL> else : <EOL> release_type = \"<STR_LIT:->\" + str ( self . release_type ( ) ) + str ( self . release_version ( ) ) <EOL> return prefix + \"<STR_LIT>\" % ( self . major , self . minor , self . patch ) + release_type <EOL> class Capabilities : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , capabilities ) : <EOL> self . mission_float = ( ( ( capabilities >> <NUM_LIT:0> ) & <NUM_LIT:1> ) == <NUM_LIT:1> ) <EOL> self . param_float = ( ( ( capabilities >> <NUM_LIT:1> ) & <NUM_LIT:1> ) == <NUM_LIT:1> ) <EOL> self . mission_int = ( ( ( capabilities >> <NUM_LIT:2> ) & <NUM_LIT:1> ) == <NUM_LIT:1> ) <EOL> self . command_int = ( ( ( capabilities >> <NUM_LIT:3> ) & <NUM_LIT:1> ) == <NUM_LIT:1> ) <EOL> self . param_union = ( ( ( capabilities >> <NUM_LIT:4> ) & <NUM_LIT:1> ) == <NUM_LIT:1> ) <EOL> self . ftp = ( ( ( capabilities >> <NUM_LIT:5> ) & <NUM_LIT:1> ) == <NUM_LIT:1> ) <EOL> self . set_attitude_target = ( ( ( capabilities >> <NUM_LIT:6> ) & <NUM_LIT:1> ) == <NUM_LIT:1> ) <EOL> self . set_attitude_target_local_ned = ( ( ( capabilities >> <NUM_LIT:7> ) & <NUM_LIT:1> ) == <NUM_LIT:1> ) <EOL> self . set_altitude_target_global_int = ( ( ( capabilities >> <NUM_LIT:8> ) & <NUM_LIT:1> ) == <NUM_LIT:1> ) <EOL> self . terrain = ( ( ( capabilities >> <NUM_LIT:9> ) & <NUM_LIT:1> ) == <NUM_LIT:1> ) <EOL> self . set_actuator_target = ( ( ( capabilities >> <NUM_LIT:10> ) & <NUM_LIT:1> ) == <NUM_LIT:1> ) <EOL> self . flight_termination = ( ( ( capabilities >> <NUM_LIT:11> ) & <NUM_LIT:1> ) == <NUM_LIT:1> ) <EOL> self . compass_calibration = ( ( ( capabilities >> <NUM_LIT:12> ) & <NUM_LIT:1> ) == <NUM_LIT:1> ) <EOL> class VehicleMode ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , name ) : <EOL> self . name = name <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" % self . name <EOL> def __eq__ ( self , other ) : <EOL> return self . name == other <EOL> def __ne__ ( self , other ) : <EOL> return self . name != other <EOL> class SystemStatus ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , state ) : <EOL> self . state = state <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" % self . state <EOL> def __eq__ ( self , other ) : <EOL> return self . state == other <EOL> def __ne__ ( self , other ) : <EOL> return self . state != other <EOL> class HasObservers ( object ) : <EOL> def __init__ ( self ) : <EOL> self . _attribute_listeners = { } <EOL> self . _attribute_cache = { } <EOL> def add_attribute_listener ( self , attr_name , observer ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> l = self . _attribute_listeners . get ( attr_name ) <EOL> if l is None : <EOL> l = [ ] <EOL> self . _attribute_listeners [ attr_name ] = l <EOL> if not observer in l : <EOL> l . append ( observer ) <EOL> def remove_attribute_listener ( self , attr_name , observer ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> l = self . _attribute_listeners . get ( attr_name ) <EOL> if l is not None : <EOL> l . remove ( observer ) <EOL> if len ( l ) == <NUM_LIT:0> : <EOL> del self . _attribute_listeners [ attr_name ] <EOL> def notify_attribute_listeners ( self , attr_name , value , cache = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if cache : <EOL> if attr_name in self . _attribute_cache and self . _attribute_cache [ attr_name ] == value : <EOL> return <EOL> self . _attribute_cache [ attr_name ] = value <EOL> for fn in self . _attribute_listeners . get ( attr_name , [ ] ) : <EOL> try : <EOL> fn ( self , attr_name , value ) <EOL> except Exception as e : <EOL> errprinter ( '<STR_LIT>' % <EOL> attr_name ) <EOL> errprinter ( '<STR_LIT>' + str ( e ) ) <EOL> for fn in self . _attribute_listeners . get ( '<STR_LIT:*>' , [ ] ) : <EOL> try : <EOL> fn ( self , attr_name , value ) <EOL> except Exception as e : <EOL> errprinter ( '<STR_LIT>' % <EOL> attr_name ) <EOL> errprinter ( '<STR_LIT>' + str ( e ) ) <EOL> def on_attribute ( self , name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def decorator ( fn ) : <EOL> if isinstance ( name , list ) : <EOL> for n in name : <EOL> self . add_attribute_listener ( n , fn ) <EOL> else : <EOL> self . add_attribute_listener ( name , fn ) <EOL> return decorator <EOL> class ChannelsOverride ( dict ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , vehicle ) : <EOL> self . _vehicle = vehicle <EOL> self . _count = <NUM_LIT:8> <EOL> self . _active = True <EOL> def __getitem__ ( self , key ) : <EOL> return dict . __getitem__ ( self , str ( key ) ) <EOL> def __setitem__ ( self , key , value ) : <EOL> if not ( int ( key ) > <NUM_LIT:0> and int ( key ) <= self . _count ) : <EOL> raise Exception ( '<STR_LIT>' % key ) <EOL> if not value : <EOL> try : <EOL> dict . __delitem__ ( self , str ( key ) ) <EOL> except : <EOL> pass <EOL> else : <EOL> dict . __setitem__ ( self , str ( key ) , value ) <EOL> self . _send ( ) <EOL> def __delitem__ ( self , key ) : <EOL> dict . __delitem__ ( self , str ( key ) ) <EOL> self . _send ( ) <EOL> def __len__ ( self ) : <EOL> return self . _count <EOL> def _send ( self ) : <EOL> if self . _active : <EOL> overrides = [ <NUM_LIT:0> ] * <NUM_LIT:8> <EOL> for k , v in self . iteritems ( ) : <EOL> overrides [ int ( k ) - <NUM_LIT:1> ] = v <EOL> self . _vehicle . _master . mav . rc_channels_override_send ( <NUM_LIT:0> , <NUM_LIT:0> , * overrides ) <EOL> class Channels ( dict ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , vehicle , count ) : <EOL> self . _vehicle = vehicle <EOL> self . _count = count <EOL> self . _overrides = ChannelsOverride ( vehicle ) <EOL> self . _readonly = False <EOL> for k in range ( <NUM_LIT:0> , count ) : <EOL> self [ k + <NUM_LIT:1> ] = None <EOL> self . _readonly = True <EOL> @ property <EOL> def count ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _count <EOL> def __getitem__ ( self , key ) : <EOL> return dict . __getitem__ ( self , str ( key ) ) <EOL> def __setitem__ ( self , key , value ) : <EOL> if self . _readonly : <EOL> raise TypeError ( '<STR_LIT>' ) <EOL> return dict . __setitem__ ( self , str ( key ) , value ) <EOL> def __len__ ( self ) : <EOL> return self . _count <EOL> def _update_channel ( self , channel , value ) : <EOL> channel = int ( channel ) <EOL> self . _readonly = False <EOL> self [ channel ] = value <EOL> self . _readonly = True <EOL> self . _count = max ( self . _count , channel ) <EOL> @ property <EOL> def overrides ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _overrides <EOL> @ overrides . setter <EOL> def overrides ( self , newch ) : <EOL> self . _overrides . _active = False <EOL> self . _overrides . clear ( ) <EOL> for k , v in newch . iteritems ( ) : <EOL> if v : <EOL> self . _overrides [ str ( k ) ] = v <EOL> else : <EOL> try : <EOL> del self . _overrides [ str ( k ) ] <EOL> except : <EOL> pass <EOL> self . _overrides . _active = True <EOL> self . _overrides . _send ( ) <EOL> class Locations ( HasObservers ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , vehicle ) : <EOL> super ( Locations , self ) . __init__ ( ) <EOL> self . _lat = None <EOL> self . _lon = None <EOL> self . _alt = None <EOL> self . _relative_alt = None <EOL> @ vehicle . on_message ( '<STR_LIT>' ) <EOL> def listener ( vehicle , name , m ) : <EOL> ( self . _lat , self . _lon ) = ( m . lat / <NUM_LIT> , m . lon / <NUM_LIT> ) <EOL> self . _relative_alt = m . relative_alt / <NUM_LIT> <EOL> self . notify_attribute_listeners ( '<STR_LIT>' , self . global_relative_frame ) <EOL> vehicle . notify_attribute_listeners ( '<STR_LIT>' , <EOL> vehicle . location . global_relative_frame ) <EOL> if self . _alt != None or m . alt != <NUM_LIT:0> : <EOL> self . _alt = m . alt / <NUM_LIT> <EOL> self . notify_attribute_listeners ( '<STR_LIT>' , self . global_frame ) <EOL> vehicle . notify_attribute_listeners ( '<STR_LIT>' , <EOL> vehicle . location . global_frame ) <EOL> vehicle . notify_attribute_listeners ( '<STR_LIT:location>' , vehicle . location ) <EOL> self . _north = None <EOL> self . _east = None <EOL> self . _down = None <EOL> @ vehicle . on_message ( '<STR_LIT>' ) <EOL> def listener ( vehicle , name , m ) : <EOL> self . _north = m . x <EOL> self . _east = m . y <EOL> self . _down = m . z <EOL> self . notify_attribute_listeners ( '<STR_LIT>' , self . local_frame ) <EOL> vehicle . notify_attribute_listeners ( '<STR_LIT>' , vehicle . location . local_frame ) <EOL> vehicle . notify_attribute_listeners ( '<STR_LIT:location>' , vehicle . location ) <EOL> @ property <EOL> def local_frame ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return LocationLocal ( self . _north , self . _east , self . _down ) <EOL> @ property <EOL> def global_frame ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return LocationGlobal ( self . _lat , self . _lon , self . _alt ) <EOL> @ property <EOL> def global_relative_frame ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return LocationGlobalRelative ( self . _lat , self . _lon , self . _relative_alt ) <EOL> class Vehicle ( HasObservers ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , handler ) : <EOL> super ( Vehicle , self ) . __init__ ( ) <EOL> self . _handler = handler <EOL> self . _master = handler . master <EOL> self . _ready_attrs = set ( [ '<STR_LIT>' ] ) <EOL> self . _default_ready_attrs = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> @ self . on_attribute ( '<STR_LIT:*>' ) <EOL> def listener ( _ , name , value ) : <EOL> self . _ready_attrs . add ( name ) <EOL> self . _message_listeners = dict ( ) <EOL> @ handler . forward_message <EOL> def listener ( _ , msg ) : <EOL> self . notify_message_listeners ( msg . get_type ( ) , msg ) <EOL> self . _location = Locations ( self ) <EOL> self . _vx = None <EOL> self . _vy = None <EOL> self . _vz = None <EOL> @ self . on_message ( '<STR_LIT>' ) <EOL> def listener ( self , name , m ) : <EOL> ( self . _vx , self . _vy , self . _vz ) = ( m . vx / <NUM_LIT> , m . vy / <NUM_LIT> , m . vz / <NUM_LIT> ) <EOL> self . notify_attribute_listeners ( '<STR_LIT>' , self . velocity ) <EOL> self . _pitch = None <EOL> self . _yaw = None <EOL> self . _roll = None <EOL> self . _pitchspeed = None <EOL> self . _yawspeed = None <EOL> self . _rollspeed = None <EOL> @ self . on_message ( '<STR_LIT>' ) <EOL> def listener ( self , name , m ) : <EOL> self . _pitch = m . pitch <EOL> self . _yaw = m . yaw <EOL> self . _roll = m . roll <EOL> self . _pitchspeed = m . pitchspeed <EOL> self . _yawspeed = m . yawspeed <EOL> self . _rollspeed = m . rollspeed <EOL> self . notify_attribute_listeners ( '<STR_LIT>' , self . attitude ) <EOL> self . _heading = None <EOL> self . _airspeed = None <EOL> self . _groundspeed = None <EOL> @ self . on_message ( '<STR_LIT>' ) <EOL> def listener ( self , name , m ) : <EOL> self . _heading = m . heading <EOL> self . notify_attribute_listeners ( '<STR_LIT>' , self . heading ) <EOL> self . _airspeed = m . airspeed <EOL> self . notify_attribute_listeners ( '<STR_LIT>' , self . airspeed ) <EOL> self . _groundspeed = m . groundspeed <EOL> self . notify_attribute_listeners ( '<STR_LIT>' , self . groundspeed ) <EOL> self . _rngfnd_distance = None <EOL> self . _rngfnd_voltage = None <EOL> @ self . on_message ( '<STR_LIT>' ) <EOL> def listener ( self , name , m ) : <EOL> self . _rngfnd_distance = m . distance <EOL> self . _rngfnd_voltage = m . voltage <EOL> self . notify_attribute_listeners ( '<STR_LIT>' , self . rangefinder ) <EOL> self . _mount_pitch = None <EOL> self . _mount_yaw = None <EOL> self . _mount_roll = None <EOL> @ self . on_message ( '<STR_LIT>' ) <EOL> def listener ( self , name , m ) : <EOL> self . _mount_pitch = m . pointing_a / <NUM_LIT> <EOL> self . _mount_roll = m . pointing_b / <NUM_LIT> <EOL> self . _mount_yaw = m . pointing_c / <NUM_LIT> <EOL> self . notify_attribute_listeners ( '<STR_LIT>' , self . mount_status ) <EOL> self . _capabilities = None <EOL> self . _raw_version = None <EOL> self . _autopilot_version_msg_count = <NUM_LIT:0> <EOL> @ self . on_message ( '<STR_LIT>' ) <EOL> def listener ( vehicle , name , m ) : <EOL> self . _capabilities = m . capabilities <EOL> self . _raw_version = m . flight_sw_version <EOL> self . _autopilot_version_msg_count += <NUM_LIT:1> <EOL> if self . _capabilities != <NUM_LIT:0> or self . _autopilot_version_msg_count > <NUM_LIT:5> : <EOL> vehicle . remove_message_listener ( '<STR_LIT>' , self . send_capabilties_request ) <EOL> self . notify_attribute_listeners ( '<STR_LIT>' , self . _raw_version ) <EOL> self . _gimbal = Gimbal ( self ) <EOL> self . _channels = Channels ( self , <NUM_LIT:8> ) <EOL> @ self . on_message ( '<STR_LIT>' ) <EOL> def listener ( self , name , m ) : <EOL> def set_rc ( chnum , v ) : <EOL> '''<STR_LIT>''' <EOL> self . _channels . _update_channel ( str ( m . port * <NUM_LIT:8> + chnum ) , v ) <EOL> set_rc ( <NUM_LIT:1> , m . chan1_raw ) <EOL> set_rc ( <NUM_LIT:2> , m . chan2_raw ) <EOL> set_rc ( <NUM_LIT:3> , m . chan3_raw ) <EOL> set_rc ( <NUM_LIT:4> , m . chan4_raw ) <EOL> set_rc ( <NUM_LIT:5> , m . chan5_raw ) <EOL> set_rc ( <NUM_LIT:6> , m . chan6_raw ) <EOL> set_rc ( <NUM_LIT:7> , m . chan7_raw ) <EOL> set_rc ( <NUM_LIT:8> , m . chan8_raw ) <EOL> self . notify_attribute_listeners ( '<STR_LIT>' , self . channels ) <EOL> self . _voltage = None <EOL> self . _current = None <EOL> self . _level = None <EOL> @ self . on_message ( '<STR_LIT>' ) <EOL> def listener ( self , name , m ) : <EOL> self . _voltage = m . voltage_battery <EOL> self . _current = m . current_battery <EOL> self . _level = m . battery_remaining <EOL> self . notify_attribute_listeners ( '<STR_LIT>' , self . battery ) <EOL> self . _eph = None <EOL> self . _epv = None <EOL> self . _satellites_visible = None <EOL> self . _fix_type = None <EOL> @ self . on_message ( '<STR_LIT>' ) <EOL> def listener ( self , name , m ) : <EOL> self . _eph = m . eph <EOL> self . _epv = m . epv <EOL> self . _satellites_visible = m . satellites_visible <EOL> self . _fix_type = m . fix_type <EOL> self . notify_attribute_listeners ( '<STR_LIT>' , self . gps_0 ) <EOL> self . _current_waypoint = <NUM_LIT:0> <EOL> @ self . on_message ( [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def listener ( self , name , m ) : <EOL> self . _current_waypoint = m . seq <EOL> self . _ekf_poshorizabs = False <EOL> self . _ekf_constposmode = False <EOL> self . _ekf_predposhorizabs = False <EOL> @ self . on_message ( '<STR_LIT>' ) <EOL> def listener ( self , name , m ) : <EOL> self . _ekf_poshorizabs = ( m . flags & ardupilotmega . EKF_POS_HORIZ_ABS ) > <NUM_LIT:0> <EOL> self . _ekf_constposmode = ( m . flags & ardupilotmega . EKF_CONST_POS_MODE ) > <NUM_LIT:0> <EOL> self . _ekf_predposhorizabs = ( m . flags & ardupilotmega . EKF_PRED_POS_HORIZ_ABS ) > <NUM_LIT:0> <EOL> self . notify_attribute_listeners ( '<STR_LIT>' , self . ekf_ok , cache = True ) <EOL> self . _flightmode = '<STR_LIT>' <EOL> self . _armed = False <EOL> self . _system_status = None <EOL> self . _autopilot_type = None <EOL> self . _vehicle_type = None <EOL> @ self . on_message ( '<STR_LIT>' ) <EOL> def listener ( self , name , m ) : <EOL> self . _armed = ( m . base_mode & mavutil . mavlink . MAV_MODE_FLAG_SAFETY_ARMED ) != <NUM_LIT:0> <EOL> self . notify_attribute_listeners ( '<STR_LIT>' , self . armed , cache = True ) <EOL> self . _autopilot_type = m . autopilot <EOL> self . _vehicle_type = m . type <EOL> if self . _is_mode_available ( m . custom_mode ) == False : <EOL> raise APIException ( \"<STR_LIT>\" % m . custom_mode ) <EOL> self . _flightmode = self . _mode_mapping_bynumber [ m . custom_mode ] <EOL> self . notify_attribute_listeners ( '<STR_LIT>' , self . mode , cache = True ) <EOL> self . _system_status = m . system_status <EOL> self . notify_attribute_listeners ( '<STR_LIT>' , self . system_status , cache = True ) <EOL> self . _home_location = None <EOL> self . _wploader = mavwp . MAVWPLoader ( ) <EOL> self . _wp_loaded = True <EOL> self . _wp_uploaded = None <EOL> self . _wpts_dirty = False <EOL> self . _commands = CommandSequence ( self ) <EOL> @ self . on_message ( [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def listener ( self , name , msg ) : <EOL> if not self . _wp_loaded : <EOL> self . _wploader . clear ( ) <EOL> self . _wploader . expected_count = msg . count <EOL> self . _master . waypoint_request_send ( <NUM_LIT:0> ) <EOL> @ self . on_message ( [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def listener ( self , name , msg ) : <EOL> if not self . _wp_loaded : <EOL> if msg . seq == <NUM_LIT:0> : <EOL> if not ( msg . x == <NUM_LIT:0> and msg . y == <NUM_LIT:0> and msg . z == <NUM_LIT:0> ) : <EOL> self . _home_location = LocationGlobal ( msg . x , msg . y , msg . z ) <EOL> if msg . seq > self . _wploader . count ( ) : <EOL> pass <EOL> elif msg . seq < self . _wploader . count ( ) : <EOL> pass <EOL> else : <EOL> self . _wploader . add ( msg ) <EOL> if msg . seq + <NUM_LIT:1> < self . _wploader . expected_count : <EOL> self . _master . waypoint_request_send ( msg . seq + <NUM_LIT:1> ) <EOL> else : <EOL> self . _wp_loaded = True <EOL> self . notify_attribute_listeners ( '<STR_LIT>' , self . commands ) <EOL> @ self . on_message ( [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def listener ( self , name , msg ) : <EOL> if self . _wp_uploaded != None : <EOL> wp = self . _wploader . wp ( msg . seq ) <EOL> handler . fix_targets ( wp ) <EOL> self . _master . mav . send ( wp ) <EOL> self . _wp_uploaded [ msg . seq ] = True <EOL> start_duration = <NUM_LIT> <EOL> repeat_duration = <NUM_LIT:1> <EOL> self . _params_count = - <NUM_LIT:1> <EOL> self . _params_set = [ ] <EOL> self . _params_loaded = False <EOL> self . _params_start = False <EOL> self . _params_map = { } <EOL> self . _params_last = monotonic . monotonic ( ) <EOL> self . _params_duration = start_duration <EOL> self . _parameters = Parameters ( self ) <EOL> @ handler . forward_loop <EOL> def listener ( _ ) : <EOL> if not self . _params_start : <EOL> return <EOL> if None not in self . _params_set and not self . _params_loaded : <EOL> self . _params_loaded = True <EOL> self . notify_attribute_listeners ( '<STR_LIT>' , self . parameters ) <EOL> if not self . _params_loaded and monotonic . monotonic ( ) - self . _params_last > self . _params_duration : <EOL> c = <NUM_LIT:0> <EOL> for i , v in enumerate ( self . _params_set ) : <EOL> if v == None : <EOL> self . _master . mav . param_request_read_send ( <NUM_LIT:0> , <NUM_LIT:0> , '<STR_LIT>' , i ) <EOL> c += <NUM_LIT:1> <EOL> if c > <NUM_LIT:50> : <EOL> break <EOL> self . _params_duration = repeat_duration <EOL> self . _params_last = monotonic . monotonic ( ) <EOL> @ self . on_message ( [ '<STR_LIT>' ] ) <EOL> def listener ( self , name , msg ) : <EOL> if self . _params_count != msg . param_count : <EOL> self . _params_loaded = False <EOL> self . _params_start = True <EOL> self . _params_count = msg . param_count <EOL> self . _params_set = [ None ] * msg . param_count <EOL> try : <EOL> if msg . param_index < msg . param_count and msg : <EOL> if self . _params_set [ msg . param_index ] == None : <EOL> self . _params_last = monotonic . monotonic ( ) <EOL> self . _params_duration = start_duration <EOL> self . _params_set [ msg . param_index ] = msg <EOL> self . _params_map [ msg . param_id ] = msg . param_value <EOL> self . _parameters . notify_attribute_listeners ( msg . param_id , msg . param_value , <EOL> cache = True ) <EOL> except : <EOL> import traceback <EOL> traceback . print_exc ( ) <EOL> self . _heartbeat_started = False <EOL> self . _heartbeat_lastsent = <NUM_LIT:0> <EOL>", "gt": ""}
{"id": "13032", "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import cooper <EOL> from itertools import repeat <EOL> import unittest <EOL> def make_test_hierarchy ( trace , decorator = lambda x : x , metacls = type ) : <EOL> @ decorator <EOL> class _A ( object ) : <EOL> __metaclass__ = metacls <EOL> @ cooper . cooperate <EOL> def __init__ ( self ) : <EOL> trace . append ( _A . __init__ ) <EOL> @ cooper . cooperative <EOL> def method ( self , mparam ) : <EOL> self . _a_mparam = mparam <EOL> trace . append ( _A . method ) <EOL> @ cooper . cooperative <EOL> def post_method ( self , pmparam ) : <EOL> self . _a_pmparam = pmparam <EOL> trace . append ( _A . post_method ) <EOL> @ decorator <EOL> class _B ( _A ) : <EOL> __metaclass__ = metacls <EOL> @ cooper . cooperate <EOL> def __init__ ( self , b_param = '<STR_LIT>' ) : <EOL> self . _b_param = b_param <EOL> trace . append ( _B . __init__ ) <EOL> @ cooper . cooperate <EOL> def method ( self , mparam , b_mparam = '<STR_LIT>' ) : <EOL> self . _b_mparam = b_mparam <EOL> trace . append ( _B . method ) <EOL> @ cooper . post_cooperate <EOL> def post_method ( self , pmparam , b_pmparam = '<STR_LIT>' ) : <EOL> self . _b_pmparam = b_pmparam <EOL> trace . append ( _B . post_method ) <EOL> @ decorator <EOL> class _C ( _A ) : <EOL> __metaclass__ = metacls <EOL> @ cooper . cooperate <EOL> def __init__ ( self ) : <EOL> trace . append ( _C . __init__ ) <EOL> @ cooper . cooperate <EOL> def method ( self , mparam ) : <EOL> self . _c_mparam = mparam <EOL> trace . append ( _C . method ) <EOL> @ cooper . post_cooperate <EOL> def post_method ( self , pmparam ) : <EOL> self . _c_pmparam = pmparam <EOL> trace . append ( _C . post_method ) <EOL> @ decorator <EOL> class _D ( _B , _C ) : <EOL> __metaclass__ = metacls <EOL> @ cooper . cooperate <EOL> def __init__ ( self , d_param = '<STR_LIT>' ) : <EOL> self . _d_param = d_param <EOL> trace . append ( _D . __init__ ) <EOL> @ cooper . cooperate <EOL> def method ( self , mparam , d_mparam = '<STR_LIT>' ) : <EOL> self . _d_mparam = d_mparam <EOL> trace . append ( _D . method ) <EOL> @ cooper . post_cooperate <EOL> def post_method ( self , pmparam , d_pmparam = '<STR_LIT>' ) : <EOL> self . _d_pmparam = d_pmparam <EOL> trace . append ( _D . post_method ) <EOL> @ decorator <EOL> class _F ( _D , _A ) : <EOL> __metaclass__ = metacls <EOL> return _A , _B , _C , _D , _F <EOL> class TestCoop ( unittest . TestCase ) : <EOL> cls_decorator = cooper . cooperative_class <EOL> cls_meta = type <EOL> def setUp ( self ) : <EOL> self . _trace = [ ] <EOL> self . _A , self . _B , self . _C , self . _D , self . _F = make_test_hierarchy ( <EOL> self . _trace , <EOL> decorator = self . cls_decorator . im_func , <EOL> metacls = self . cls_meta ) <EOL> def test_init_parameter_passing ( self ) : <EOL> obj = self . _D ( ) <EOL> self . assertEqual ( obj . _b_param , '<STR_LIT>' ) <EOL> self . assertEqual ( obj . _d_param , '<STR_LIT>' ) <EOL> obj = self . _D ( b_param = '<STR_LIT>' ) <EOL> self . assertEqual ( obj . _b_param , '<STR_LIT>' ) <EOL> self . assertEqual ( obj . _d_param , '<STR_LIT>' ) <EOL> obj = self . _D ( d_param = '<STR_LIT>' ) <EOL> self . assertEqual ( obj . _b_param , '<STR_LIT>' ) <EOL> self . assertEqual ( obj . _d_param , '<STR_LIT>' ) <EOL> obj = self . _D ( d_param = '<STR_LIT>' , <EOL> b_param = '<STR_LIT>' ) <EOL> self . assertEqual ( obj . _b_param , '<STR_LIT>' ) <EOL> self . assertEqual ( obj . _d_param , '<STR_LIT>' ) <EOL> def test_init_check_no_positional ( self ) : <EOL> def make_cls ( ) : <EOL> @ self . cls_decorator . im_func <EOL> class _Bad ( object ) : <EOL> __metaclass__ = self . cls_meta <EOL> @ cooper . cooperate <EOL> def __init__ ( self , positional ) : <EOL> pass <EOL> self . assertRaises ( cooper . CooperativeError , make_cls ) <EOL> def test_init_check_no_variadic ( self ) : <EOL> def make_cls ( ) : <EOL> @ self . cls_decorator . im_func <EOL> class _Bad ( object ) : <EOL> __metaclass__ = self . cls_meta <EOL> @ cooper . cooperate <EOL> def __init__ ( self , * a ) : <EOL> pass <EOL> self . assertRaises ( cooper . CooperativeError , make_cls ) <EOL> def test_init_check_no_variadic_keywords ( self ) : <EOL> def make_cls ( ) : <EOL> @ self . cls_decorator . im_func <EOL> class _Bad ( object ) : <EOL> __metaclass__ = self . cls_meta <EOL> @ cooper . cooperate <EOL> def __init__ ( self , ** k ) : <EOL> pass <EOL> self . assertRaises ( cooper . CooperativeError , make_cls ) <EOL> def test_init_must_cooperate ( self ) : <EOL> def make_cls ( ) : <EOL> @ self . cls_decorator . im_func <EOL> class _Bad ( object ) : <EOL> __metaclass__ = self . cls_meta <EOL> def __init__ ( self ) : <EOL> pass <EOL> self . assertRaises ( cooper . CooperativeError , make_cls ) <EOL> def test_init_must_override ( self ) : <EOL> def make_cls ( ) : <EOL> @ self . cls_decorator . im_func <EOL> class _Bad ( object ) : <EOL> __metaclass__ = self . cls_meta <EOL> @ cooper . cooperative <EOL> def __init__ ( self ) : <EOL> pass <EOL> self . assertRaises ( cooper . CooperativeError , make_cls ) <EOL> def test_super_params_sends_params ( self ) : <EOL> @ self . cls_decorator . im_func <EOL> class _Fixed ( self . _F ) : <EOL> __metaclass__ = self . cls_meta <EOL> @ cooper . cooperate_with_params ( b_param = '<STR_LIT>' ) <EOL> def __init__ ( self ) : <EOL> pass <EOL> obj = _Fixed ( ) <EOL> self . assertEqual ( obj . _b_param , '<STR_LIT>' ) <EOL> def test_manual_init ( self ) : <EOL> outer_self = self <EOL> @ self . cls_decorator . im_func <EOL> class _Manual ( self . _D ) : <EOL> __metaclass__ = self . cls_meta <EOL> @ cooper . manual_cooperate <EOL> def __init__ ( self , * a , ** k ) : <EOL> super ( _Manual , self ) . __init__ ( * a , ** k ) <EOL> outer_self . _trace . append ( _Manual . __init__ ) <EOL> self . _clear_trace ( ) <EOL> _Manual ( ) <EOL> self . _check_trace_calls_with_mro ( _Manual . __init__ ) <EOL> def test_can_mix_non_cooperative_superclass_single_inherit ( self ) : <EOL> class NonCooperativeSuperClass ( object ) : <EOL> pass <EOL> @ self . cls_decorator . im_func <EOL> class _Good ( NonCooperativeSuperClass ) : <EOL> __metaclass__ = self . cls_meta <EOL> self . assertTrue ( isinstance ( _Good ( ) , _Good ) ) <EOL> def test_can_not_mix_non_cooperative_superclass_multi_inherit ( self ) : <EOL> class NonCooperativeSuperClass1 ( object ) : <EOL> pass <EOL> class NonCooperativeSuperClass2 ( object ) : <EOL> pass <EOL> def make_class ( ) : <EOL> @ self . cls_decorator . im_func <EOL> class _Bad ( NonCooperativeSuperClass1 , <EOL> NonCooperativeSuperClass2 ) : <EOL> __metaclass__ = self . cls_meta <EOL> self . assertRaises ( cooper . CooperativeError , make_class ) <EOL> def test_can_mix_non_cooperative_subclass ( self ) : <EOL> class _Good ( self . _D ) : <EOL> pass <EOL> self . _clear_trace ( ) <EOL> _Good ( ) <EOL> self . _check_trace_calls_with_mro ( self . _D . __init__ ) <EOL> def test_abstract_method_forbids_instantiation ( self ) : <EOL> @ self . cls_decorator . im_func <EOL> class _ABC ( self . _D ) : <EOL> __metaclass__ = self . cls_meta <EOL> @ cooper . abstract <EOL> def abstract_method ( self ) : <EOL> return <NUM_LIT:0> <EOL> self . assertRaises ( TypeError , _ABC ) <EOL> def test_override_abstract_method_enables_instantiation ( self ) : <EOL> @ self . cls_decorator . im_func <EOL>", "gt": ""}
{"id": "42591", "input": "<s> from __future__ import absolute_import , unicode_literals <EOL> from django . core . urlresolvers import reverse <EOL> from django . test import TestCase <EOL> from wagtail . tests . testapp . models import EventIndex , EventPage , SimplePage <EOL> from wagtail . tests . utils import WagtailTestUtils <EOL> from wagtail . wagtailcore . models import Page <EOL> class TestChooserBrowse ( TestCase , WagtailTestUtils ) : <EOL> def setUp ( self ) : <EOL> self . root_page = Page . objects . get ( id = <NUM_LIT:2> ) <EOL> self . child_page = SimplePage ( title = \"<STR_LIT>\" , content = \"<STR_LIT:hello>\" ) <EOL> self . root_page . add_child ( instance = self . child_page ) <EOL> self . login ( ) <EOL> def get ( self , params = { } ) : <EOL> return self . client . get ( reverse ( '<STR_LIT>' ) , params ) <EOL> def test_simple ( self ) : <EOL> response = self . get ( ) <EOL> self . assertEqual ( response . status_code , <NUM_LIT:200> ) <EOL> self . assertTemplateUsed ( response , '<STR_LIT>' ) <EOL> class TestCanChooseRootFlag ( TestCase , WagtailTestUtils ) : <EOL> def setUp ( self ) : <EOL> self . login ( ) <EOL> def get ( self , params = { } ) : <EOL> return self . client . get ( reverse ( '<STR_LIT>' ) , params ) <EOL> def test_cannot_choose_root_by_default ( self ) : <EOL> response = self . get ( ) <EOL> self . assertNotContains ( response , '<STR_LIT>' ) <EOL> def test_can_choose_root ( self ) : <EOL> response = self . get ( { '<STR_LIT>' : '<STR_LIT:true>' } ) <EOL> self . assertContains ( response , '<STR_LIT>' ) <EOL> class TestChooserBrowseChild ( TestCase , WagtailTestUtils ) : <EOL> def setUp ( self ) : <EOL> self . root_page = Page . objects . get ( id = <NUM_LIT:2> ) <EOL> self . child_page = SimplePage ( title = \"<STR_LIT>\" , content = \"<STR_LIT:hello>\" ) <EOL> self . root_page . add_child ( instance = self . child_page ) <EOL> self . login ( ) <EOL> def get ( self , params = { } ) : <EOL> return self . client . get ( reverse ( '<STR_LIT>' , <EOL> args = ( self . root_page . id , ) ) , params ) <EOL> def get_invalid ( self , params = { } ) : <EOL> return self . client . get ( reverse ( '<STR_LIT>' , <EOL> args = ( <NUM_LIT> , ) ) , params ) <EOL> def test_simple ( self ) : <EOL> response = self . get ( ) <EOL> self . assertEqual ( response . status_code , <NUM_LIT:200> ) <EOL> self . assertTemplateUsed ( response , '<STR_LIT>' ) <EOL> def test_get_invalid ( self ) : <EOL> self . assertEqual ( self . get_invalid ( ) . status_code , <NUM_LIT> ) <EOL> def test_with_page_type ( self ) : <EOL> event_page = EventPage ( <EOL> title = \"<STR_LIT>\" , <EOL> location = '<STR_LIT>' , audience = '<STR_LIT>' , <EOL> cost = '<STR_LIT>' , date_from = '<STR_LIT>' , <EOL> ) <EOL> self . root_page . add_child ( instance = event_page ) <EOL> event_index_page = EventIndex ( <EOL> title = \"<STR_LIT>\" , <EOL> ) <EOL> self . root_page . add_child ( instance = event_index_page ) <EOL> event_index_page . add_child ( instance = EventPage ( <EOL> title = \"<STR_LIT>\" , <EOL> location = '<STR_LIT>' , audience = '<STR_LIT>' , <EOL> cost = '<STR_LIT>' , date_from = '<STR_LIT>' , <EOL> ) ) <EOL> response = self . get ( { '<STR_LIT>' : '<STR_LIT>' } ) <EOL> self . assertEqual ( response . status_code , <NUM_LIT:200> ) <EOL> self . assertTemplateUsed ( response , '<STR_LIT>' ) <EOL> self . assertEqual ( response . context [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> pages = { <EOL> page . id : page <EOL> for page in response . context [ '<STR_LIT>' ] . object_list <EOL> } <EOL> self . assertIn ( self . child_page . id , pages ) <EOL> self . assertTrue ( pages [ self . child_page . id ] . can_choose ) <EOL> self . assertFalse ( pages [ self . child_page . id ] . can_descend ) <EOL> self . assertNotIn ( event_page . id , pages ) <EOL> self . assertIn ( event_index_page . id , pages ) <EOL> self . assertFalse ( pages [ event_index_page . id ] . can_choose ) <EOL> self . assertTrue ( pages [ event_index_page . id ] . can_descend ) <EOL> def test_with_blank_page_type ( self ) : <EOL> response = self . get ( { '<STR_LIT>' : '<STR_LIT>' } ) <EOL> self . assertEqual ( response . status_code , <NUM_LIT:200> ) <EOL> self . assertTemplateUsed ( response , '<STR_LIT>' ) <EOL> def test_with_multiple_page_types ( self ) : <EOL> event_page = EventPage ( <EOL> title = \"<STR_LIT>\" , <EOL> location = '<STR_LIT>' , audience = '<STR_LIT>' , <EOL> cost = '<STR_LIT>' , date_from = '<STR_LIT>' , <EOL> ) <EOL> self . root_page . add_child ( instance = event_page ) <EOL> response = self . get ( { '<STR_LIT>' : '<STR_LIT>' } ) <EOL> self . assertEqual ( response . status_code , <NUM_LIT:200> ) <EOL> self . assertTemplateUsed ( response , '<STR_LIT>' ) <EOL> self . assertEqual ( response . context [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> pages = { <EOL> page . id : page <EOL> for page in response . context [ '<STR_LIT>' ] . object_list <EOL> } <EOL> self . assertIn ( self . child_page . id , pages ) <EOL> self . assertTrue ( pages [ self . child_page . id ] . can_choose ) <EOL> self . assertIn ( event_page . id , pages ) <EOL> self . assertTrue ( pages [ self . child_page . id ] . can_choose ) <EOL> def test_with_unknown_page_type ( self ) : <EOL> response = self . get ( { '<STR_LIT>' : '<STR_LIT>' } ) <EOL> self . assertEqual ( response . status_code , <NUM_LIT> ) <EOL> def test_with_bad_page_type ( self ) : <EOL> response = self . get ( { '<STR_LIT>' : '<STR_LIT>' } ) <EOL> self . assertEqual ( response . status_code , <NUM_LIT> ) <EOL> def test_with_invalid_page_type ( self ) : <EOL> response = self . get ( { '<STR_LIT>' : '<STR_LIT:foo>' } ) <EOL> self . assertEqual ( response . status_code , <NUM_LIT> ) <EOL> def setup_pagination_test_data ( self ) : <EOL> for i in range ( <NUM_LIT:100> ) : <EOL> new_page = SimplePage ( <EOL> title = \"<STR_LIT>\" , <EOL> slug = \"<STR_LIT>\" % i , <EOL> content = \"<STR_LIT:hello>\" , <EOL> ) <EOL> self . root_page . add_child ( instance = new_page ) <EOL> def test_pagination_basic ( self ) : <EOL> self . setup_pagination_test_data ( ) <EOL> response = self . get ( ) <EOL> self . assertEqual ( response . context [ '<STR_LIT>' ] . paginator . num_pages , <NUM_LIT:5> ) <EOL> self . assertEqual ( response . context [ '<STR_LIT>' ] . number , <NUM_LIT:1> ) <EOL> def test_pagination_another_page ( self ) : <EOL>", "gt": ""}
{"id": "45963", "input": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL>", "gt": ""}
{"id": "35714", "input": "<s> from email import message_from_string <EOL> from email . header import decode_header <EOL> from imaplib import IMAP4 , IMAP4_SSL <EOL> from os import makedirs <EOL> from os . path import exists , join <EOL> import re <EOL> from sys import exit <EOL> import sh <EOL> from tornado . options import define , options , parse_config_file <EOL> from magpie . config import config_path <EOL> class EmailNotesError ( Exception ) : <EOL> pass <EOL> define ( '<STR_LIT>' , default = None , type = str ) <EOL> define ( '<STR_LIT:username>' , default = None , type = str ) <EOL> define ( '<STR_LIT:password>' , default = None , type = str ) <EOL> define ( '<STR_LIT>' , default = None , type = str ) <EOL> define ( '<STR_LIT>' , default = None , type = str ) <EOL> define ( '<STR_LIT>' , default = True , type = bool ) <EOL> define ( '<STR_LIT>' , default = '<STR_LIT>' , type = str ) <EOL> parse_config_file ( config_path . email_notes ) <EOL> if options . use_ssl : <EOL> imap = IMAP4_SSL ( options . imap_server ) <EOL> else : <EOL> imap = IMAP4 ( options . imap_server ) <EOL> imap . login ( options . username , options . password ) <EOL> result , data = imap . select ( options . folder ) <EOL> if result != '<STR_LIT:OK>' : <EOL> raise EmailNotesError ( result ) <EOL> result , messages = imap . search ( None , '<STR_LIT>' ) <EOL> if result != '<STR_LIT:OK>' : <EOL> raise EmailNotesError ( result ) <EOL> if messages [ <NUM_LIT:0> ] == '<STR_LIT>' : <EOL> exit ( ) <EOL> git = sh . git . bake ( _cwd = options . repo ) <EOL> for message_index in messages [ <NUM_LIT:0> ] . split ( '<STR_LIT:U+0020>' ) : <EOL> junk , data = imap . fetch ( message_index , '<STR_LIT>' ) <EOL> message = message_from_string ( data [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] ) <EOL> subject = decode_header ( message . get ( '<STR_LIT>' ) ) [ <NUM_LIT:0> ] <EOL> if subject [ <NUM_LIT:1> ] is None : <EOL> subject = subject [ <NUM_LIT:0> ] <EOL> else : <EOL> subject = subject [ <NUM_LIT:0> ] . decode ( subject [ <NUM_LIT:1> ] ) <EOL>", "gt": ""}
{"id": "27494", "input": "<s> from __future__ import unicode_literals <EOL> from codecs import getincrementaldecoder <EOL> import os <EOL> __all__ = ( <EOL> '<STR_LIT>' , <EOL> ) <EOL> class PosixStdinReader ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , stdin_fd , errors = '<STR_LIT:ignore>' ) : <EOL> assert isinstance ( stdin_fd , int ) <EOL> self . stdin_fd = stdin_fd <EOL> self . errors = errors <EOL> self . _stdin_decoder_cls = getincrementaldecoder ( '<STR_LIT:utf-8>' ) <EOL>", "gt": ""}
{"id": "14447", "input": "<s> import json <EOL> import sys <EOL> import warnings <EOL> from django . conf import settings <EOL> from django . contrib . auth import get_user_model <EOL> from django . contrib . auth . models import AnonymousUser , Permission <EOL> from django . contrib . sites . models import Site <EOL> from django . core . cache import cache <EOL> from django . core . exceptions import ObjectDoesNotExist <EOL> from django . core . urlresolvers import reverse <EOL> from django . template import engines <EOL> from django . template . context import Context <EOL> from django . test import testcases <EOL> from django . test . client import RequestFactory <EOL> from django . utils . timezone import now <EOL> from django . utils . translation import activate <EOL> from django . utils . six . moves . urllib . parse import unquote , urljoin <EOL> from menus . menu_pool import menu_pool <EOL> from cms . models import Page <EOL> from cms . test_utils . util . context_managers import UserLoginContext <EOL> from cms . utils . compat import DJANGO_1_8 <EOL> from cms . utils . permissions import set_current_user <EOL> URL_CMS_PAGE = \"<STR_LIT>\" <EOL> URL_CMS_PAGE_ADD = urljoin ( URL_CMS_PAGE , \"<STR_LIT>\" ) <EOL> URL_CMS_PAGE_CHANGE_BASE = urljoin ( URL_CMS_PAGE , \"<STR_LIT>\" ) <EOL> if DJANGO_1_8 : <EOL> URL_CMS_PAGE_CHANGE = URL_CMS_PAGE_CHANGE_BASE <EOL> else : <EOL> URL_CMS_PAGE_CHANGE = urljoin ( URL_CMS_PAGE_CHANGE_BASE , \"<STR_LIT>\" ) <EOL> URL_CMS_PAGE_ADVANCED_CHANGE = urljoin ( URL_CMS_PAGE , \"<STR_LIT>\" ) <EOL> URL_CMS_PAGE_PERMISSION_CHANGE = urljoin ( URL_CMS_PAGE , \"<STR_LIT>\" ) <EOL> URL_CMS_PAGE_PERMISSIONS = urljoin ( URL_CMS_PAGE , \"<STR_LIT>\" ) <EOL> URL_CMS_PAGE_PUBLISHED = urljoin ( URL_CMS_PAGE , \"<STR_LIT>\" ) <EOL> URL_CMS_PAGE_MOVE = urljoin ( URL_CMS_PAGE , \"<STR_LIT>\" ) <EOL> URL_CMS_PAGE_CHANGE_LANGUAGE = URL_CMS_PAGE_CHANGE + \"<STR_LIT>\" <EOL> URL_CMS_PAGE_CHANGE_TEMPLATE = urljoin ( URL_CMS_PAGE_CHANGE , \"<STR_LIT>\" ) <EOL> URL_CMS_PAGE_PUBLISH = urljoin ( URL_CMS_PAGE_CHANGE_BASE , \"<STR_LIT>\" ) <EOL> URL_CMS_PAGE_DELETE = urljoin ( URL_CMS_PAGE_CHANGE_BASE , \"<STR_LIT>\" ) <EOL> URL_CMS_PLUGIN_ADD = urljoin ( URL_CMS_PAGE , \"<STR_LIT>\" ) <EOL> URL_CMS_PLUGIN_EDIT = urljoin ( URL_CMS_PAGE , \"<STR_LIT>\" ) <EOL> URL_CMS_PLUGIN_MOVE = urljoin ( URL_CMS_PAGE , \"<STR_LIT>\" ) <EOL> URL_CMS_PLUGIN_PAGE_MOVE = urljoin ( URL_CMS_PAGE_CHANGE_BASE , \"<STR_LIT>\" ) <EOL> URL_CMS_PLUGIN_PAGE_ADD = urljoin ( URL_CMS_PAGE_CHANGE_BASE , \"<STR_LIT>\" ) <EOL> URL_CMS_PLUGIN_REMOVE = urljoin ( URL_CMS_PAGE , \"<STR_LIT>\" ) <EOL> URL_CMS_PLUGIN_DELETE = urljoin ( URL_CMS_PAGE , \"<STR_LIT>\" ) <EOL> URL_CMS_PLUGINS_COPY = urljoin ( URL_CMS_PAGE , \"<STR_LIT>\" ) <EOL> URL_CMS_TRANSLATION_DELETE = urljoin ( URL_CMS_PAGE_CHANGE_BASE , \"<STR_LIT>\" ) <EOL> URL_CMS_USERSETTINGS = \"<STR_LIT>\" <EOL> URL_CMS_PAGE_HISTORY = urljoin ( URL_CMS_PAGE_CHANGE_BASE , \"<STR_LIT>\" ) <EOL> URL_CMS_PLUGIN_HISTORY_EDIT = urljoin ( URL_CMS_PAGE_HISTORY , \"<STR_LIT>\" ) <EOL> class _Warning ( object ) : <EOL> def __init__ ( self , message , category , filename , lineno ) : <EOL> self . message = message <EOL> self . category = category <EOL> self . filename = filename <EOL> self . lineno = lineno <EOL> def _collectWarnings ( observeWarning , f , * args , ** kwargs ) : <EOL> def showWarning ( message , category , filename , lineno , file = None , line = None ) : <EOL> assert isinstance ( message , Warning ) <EOL> observeWarning ( _Warning ( <EOL> message . args [ <NUM_LIT:0> ] , category , filename , lineno ) ) <EOL> for v in sys . modules . values ( ) : <EOL> if v is not None : <EOL> try : <EOL> v . __warningregistry__ = None <EOL> except : <EOL> pass <EOL> origFilters = warnings . filters [ : ] <EOL> origShow = warnings . showwarning <EOL> warnings . simplefilter ( '<STR_LIT>' ) <EOL> try : <EOL> warnings . showwarning = showWarning <EOL> result = f ( * args , ** kwargs ) <EOL> finally : <EOL> warnings . filters [ : ] = origFilters <EOL> warnings . showwarning = origShow <EOL> return result <EOL> class BaseCMSTestCase ( object ) : <EOL> counter = <NUM_LIT:1> <EOL> def _fixture_setup ( self ) : <EOL> super ( BaseCMSTestCase , self ) . _fixture_setup ( ) <EOL> self . create_fixtures ( ) <EOL> activate ( \"<STR_LIT>\" ) <EOL> def create_fixtures ( self ) : <EOL> pass <EOL> def _post_teardown ( self ) : <EOL> menu_pool . clear ( ) <EOL> cache . clear ( ) <EOL> super ( BaseCMSTestCase , self ) . _post_teardown ( ) <EOL> set_current_user ( None ) <EOL> def login_user_context ( self , user ) : <EOL> return UserLoginContext ( self , user ) <EOL> def _create_user ( self , username , is_staff = False , is_superuser = False , <EOL> is_active = True , add_default_permissions = False , permissions = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> User = get_user_model ( ) <EOL> fields = dict ( email = username + '<STR_LIT>' , last_login = now ( ) , <EOL> is_staff = is_staff , is_active = is_active , is_superuser = is_superuser <EOL> ) <EOL> if ( get_user_model ( ) . USERNAME_FIELD != '<STR_LIT:email>' ) : <EOL> fields [ get_user_model ( ) . USERNAME_FIELD ] = username <EOL> user = User ( ** fields ) <EOL> user . set_password ( getattr ( user , get_user_model ( ) . USERNAME_FIELD ) ) <EOL> user . save ( ) <EOL> if is_staff and not is_superuser and add_default_permissions : <EOL> user . user_permissions . add ( Permission . objects . get ( codename = '<STR_LIT>' ) ) <EOL> user . user_permissions . add ( Permission . objects . get ( codename = '<STR_LIT>' ) ) <EOL> user . user_permissions . add ( Permission . objects . get ( codename = '<STR_LIT>' ) ) <EOL> user . user_permissions . add ( Permission . objects . get ( codename = '<STR_LIT>' ) ) <EOL> user . user_permissions . add ( Permission . objects . get ( codename = '<STR_LIT>' ) ) <EOL> user . user_permissions . add ( Permission . objects . get ( codename = '<STR_LIT>' ) ) <EOL> user . user_permissions . add ( Permission . objects . get ( codename = '<STR_LIT>' ) ) <EOL> if is_staff and not is_superuser and permissions : <EOL> for permission in permissions : <EOL> user . user_permissions . add ( Permission . objects . get ( codename = permission ) ) <EOL> return user <EOL> def get_superuser ( self ) : <EOL> try : <EOL> query = dict ( ) <EOL> if get_user_model ( ) . USERNAME_FIELD != \"<STR_LIT:email>\" : <EOL> query [ get_user_model ( ) . USERNAME_FIELD ] = \"<STR_LIT>\" <EOL> else : <EOL> query [ get_user_model ( ) . USERNAME_FIELD ] = \"<STR_LIT>\" <EOL> admin = get_user_model ( ) . objects . get ( ** query ) <EOL> except get_user_model ( ) . DoesNotExist : <EOL> admin = self . _create_user ( \"<STR_LIT>\" , is_staff = True , is_superuser = True ) <EOL> return admin <EOL> def get_staff_user_with_no_permissions ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> staff = self . _create_user ( \"<STR_LIT>\" , is_staff = True , is_superuser = False ) <EOL> return staff <EOL> def get_staff_user_with_std_permissions ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> staff = self . _create_user ( \"<STR_LIT>\" , is_staff = True , is_superuser = False , <EOL> add_default_permissions = True ) <EOL> return staff <EOL> def get_standard_user ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> standard = self . _create_user ( \"<STR_LIT>\" , is_staff = False , is_superuser = False ) <EOL> return standard <EOL> def get_new_page_data ( self , parent_id = '<STR_LIT>' ) : <EOL> page_data = { <EOL> '<STR_LIT:title>' : '<STR_LIT>' % self . counter , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . counter , <EOL> '<STR_LIT>' : settings . LANGUAGES [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : parent_id , <EOL> '<STR_LIT>' : <NUM_LIT:1> , <EOL> '<STR_LIT>' : <NUM_LIT:0> , <EOL> '<STR_LIT>' : <NUM_LIT:0> , <EOL> '<STR_LIT>' : <NUM_LIT:0> , <EOL> '<STR_LIT>' : <NUM_LIT:0> , <EOL> '<STR_LIT>' : <NUM_LIT:0> , <EOL> '<STR_LIT>' : <NUM_LIT:0> <EOL> } <EOL> self . counter += <NUM_LIT:1> <EOL> return page_data <EOL> def get_new_page_data_dbfields ( self , parent = None , site = None , <EOL>", "gt": ""}
{"id": "29440", "input": "<s> from swift . common . swob import Request , Response <EOL> from swift . common . utils import register_swift_info <EOL> class CrossDomainMiddleware ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , app , conf , * args , ** kwargs ) : <EOL> self . app = app <EOL> self . conf = conf <EOL> default_domain_policy = '<STR_LIT>' '<STR_LIT>' <EOL> self . cross_domain_policy = self . conf . get ( '<STR_LIT>' , <EOL> default_domain_policy ) <EOL> def GET ( self , req ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> body = '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' % self . cross_domain_policy <EOL> return Response ( request = req , body = body , <EOL>", "gt": ""}
{"id": "38619", "input": "<s> '''<STR_LIT>''' <EOL> from matplotlib . pyplot import figure , plot , show , legend , xlabel , ylabel , savefig , fill , fill_between , errorbar , xlim <EOL> from numpy . ma . core import mean , std , shape , sqrt <EOL> from pickle import load <EOL> from kameleon_mcmc . paper_figures import latex_plot_init <EOL> import matplotlib as mpl <EOL> from numpy . ma . extras import median <EOL> import sys <EOL> import os <EOL> if len ( sys . argv ) <= <NUM_LIT:1> : <EOL> print \"<STR_LIT>\" , str ( sys . argv [ <NUM_LIT:0> ] ) . split ( os . sep ) [ - <NUM_LIT:1> ] , \"<STR_LIT>\" <EOL> exit ( ) <EOL> which_plot = str ( sys . argv [ <NUM_LIT:1> ] ) <EOL> if len ( sys . argv ) >= <NUM_LIT:3> : <EOL> highlight = str ( sys . argv [ <NUM_LIT:2> ] ) <EOL> else : <EOL> highlight = None <EOL> if len ( sys . argv ) >= <NUM_LIT:4> : <EOL> directory = str ( sys . argv [ <NUM_LIT:3> ] ) <EOL> else : <EOL> directory = '<STR_LIT>' <EOL> mpl . rcParams [ '<STR_LIT>' ] = True <EOL> mpl . rcParams [ '<STR_LIT>' ] = True <EOL> sampler_names_short = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> sampler_names = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> colours = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> ii = <NUM_LIT:0> <EOL> for sampler_name in sampler_names : <EOL> filename = directory + sampler_name + \"<STR_LIT>\" <EOL> f = open ( filename , \"<STR_LIT:r>\" ) <EOL> upto , mmds , mean_dist = load ( f ) <EOL>", "gt": ""}
{"id": "18232", "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> import netaddr <EOL> from neutron_lib import exceptions <EOL> import oslo_i18n <EOL> from oslo_log import log as logging <EOL> from oslo_policy import policy as oslo_policy <EOL> import six <EOL> import webob . dec <EOL> import webob . exc <EOL> from neutron . _i18n import _ , _LE , _LI <EOL> from neutron import wsgi <EOL> LOG = logging . getLogger ( __name__ ) <EOL> class Request ( wsgi . Request ) : <EOL> pass <EOL> def Resource ( controller , faults = None , deserializers = None , serializers = None , <EOL> action_status = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> default_deserializers = { '<STR_LIT:application/json>' : wsgi . JSONDeserializer ( ) } <EOL> default_serializers = { '<STR_LIT:application/json>' : wsgi . JSONDictSerializer ( ) } <EOL> format_types = { '<STR_LIT>' : '<STR_LIT:application/json>' } <EOL> action_status = action_status or dict ( create = <NUM_LIT> , delete = <NUM_LIT> ) <EOL> default_deserializers . update ( deserializers or { } ) <EOL> default_serializers . update ( serializers or { } ) <EOL> deserializers = default_deserializers <EOL> serializers = default_serializers <EOL> faults = faults or { } <EOL> @ webob . dec . wsgify ( RequestClass = Request ) <EOL> def resource ( request ) : <EOL> route_args = request . environ . get ( '<STR_LIT>' ) <EOL> if route_args : <EOL> args = route_args [ <NUM_LIT:1> ] . copy ( ) <EOL> else : <EOL> args = { } <EOL> args . pop ( '<STR_LIT>' , None ) <EOL> fmt = args . pop ( '<STR_LIT>' , None ) <EOL> action = args . pop ( '<STR_LIT:action>' , None ) <EOL> content_type = format_types . get ( fmt , <EOL> request . best_match_content_type ( ) ) <EOL> language = request . best_match_language ( ) <EOL> deserializer = deserializers . get ( content_type ) <EOL> serializer = serializers . get ( content_type ) <EOL> try : <EOL> if request . body : <EOL> args [ '<STR_LIT:body>' ] = deserializer . deserialize ( request . body ) [ '<STR_LIT:body>' ] <EOL> method = getattr ( controller , action ) <EOL> result = method ( request = request , ** args ) <EOL> except ( exceptions . NeutronException , <EOL> netaddr . AddrFormatError , <EOL> oslo_policy . PolicyNotAuthorized ) as e : <EOL> for fault in faults : <EOL> if isinstance ( e , fault ) : <EOL> mapped_exc = faults [ fault ] <EOL> break <EOL> else : <EOL> mapped_exc = webob . exc . HTTPInternalServerError <EOL> if <NUM_LIT> <= mapped_exc . code < <NUM_LIT> : <EOL> LOG . info ( _LI ( '<STR_LIT>' ) , <EOL> { '<STR_LIT:action>' : action , '<STR_LIT>' : e } ) <EOL> else : <EOL>", "gt": ""}
{"id": "426", "input": "<s> from __future__ import absolute_import <EOL> from __future__ import print_function <EOL> import dataflow_example <EOL> expected_verilog = \"\"\"<STR_LIT>\"\"\" <EOL> def test ( ) : <EOL> test_module = dataflow_example . mkTest ( ) <EOL> code = test_module . to_verilog ( ) <EOL>", "gt": ""}
{"id": "10464", "input": "<s> from oslo_log import log as logging <EOL> from nova . network import linux_net <EOL> from nova import utils <EOL> LOG = logging . getLogger ( __name__ ) <EOL> class L3Driver ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , l3_lib = None ) : <EOL> raise NotImplementedError ( ) <EOL> def initialize ( self , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError ( ) <EOL> def initialize_network ( self , cidr , is_external ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError ( ) <EOL> def initialize_gateway ( self , network_ref ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError ( ) <EOL> def remove_gateway ( self , network_ref ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError ( ) <EOL> def is_initialized ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError ( ) <EOL> def add_floating_ip ( self , floating_ip , fixed_ip , l3_interface_id , <EOL> network = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError ( ) <EOL> def remove_floating_ip ( self , floating_ip , fixed_ip , l3_interface_id , <EOL> network = None ) : <EOL> raise NotImplementedError ( ) <EOL> def add_vpn ( self , public_ip , port , private_ip ) : <EOL> raise NotImplementedError ( ) <EOL> def remove_vpn ( self , public_ip , port , private_ip ) : <EOL> raise NotImplementedError ( ) <EOL> def clean_conntrack ( self , fixed_ip ) : <EOL> raise NotImplementedError ( ) <EOL> def teardown ( self ) : <EOL> raise NotImplementedError ( ) <EOL> class LinuxNetL3 ( L3Driver ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self ) : <EOL> self . initialized = False <EOL> def initialize ( self , ** kwargs ) : <EOL> if self . initialized : <EOL> return <EOL> LOG . debug ( \"<STR_LIT>\" ) <EOL> fixed_range = kwargs . get ( '<STR_LIT>' , False ) <EOL> networks = kwargs . get ( '<STR_LIT>' , None ) <EOL> if not fixed_range and networks is not None : <EOL> for network in networks : <EOL> if network [ '<STR_LIT>' ] : <EOL> is_ext = ( network [ '<STR_LIT>' ] is not None and <EOL> network [ '<STR_LIT>' ] != network [ '<STR_LIT>' ] ) <EOL> self . initialize_network ( network [ '<STR_LIT>' ] , is_ext ) <EOL> linux_net . ensure_metadata_ip ( ) <EOL> linux_net . metadata_forward ( ) <EOL>", "gt": ""}
{"id": "45754", "input": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Ship ( ) <EOL>", "gt": ""}
{"id": "22299", "input": "<s> import os <EOL> import sys <EOL> import atexit <EOL> import json <EOL> from . connection import Connection , Pager <EOL> from . exceptions import ResponseError <EOL> from functools import wraps <EOL> if \"<STR_LIT>\" not in sys . argv : <EOL> cache_file = \"<STR_LIT>\" <EOL> cache = { } <EOL> if os . path . isfile ( cache_file ) : <EOL> with open ( cache_file , \"<STR_LIT:r>\" ) as f : <EOL> try : <EOL> cache = json . load ( f ) <EOL> except ValueError : <EOL> pass <EOL> def save_cache ( ) : <EOL> with open ( cache_file , '<STR_LIT:w>' ) as f : <EOL> json . dump ( cache , f ) <EOL> atexit . register ( save_cache ) <EOL> def memoise ( wrapped ) : <EOL> @ wraps ( wrapped ) <EOL> def wrapper ( * args , ** kwargs ) : <EOL> key = args [ <NUM_LIT:0> ] <EOL> if key not in cache : <EOL> cache [ key ] = wrapped ( * args , ** kwargs ) <EOL> return cache [ key ] <EOL> return wrapper <EOL> else : <EOL> def memoise ( wrapped ) : <EOL> @ wraps ( wrapped ) <EOL> def wrapper ( * args , ** kwargs ) : <EOL> return wrapped ( * args , ** kwargs ) <EOL> return wrapper <EOL> token = os . environ . get ( \"<STR_LIT>\" ) <EOL> debug = os . environ . get ( \"<STR_LIT>\" ) <EOL> if token is None : <EOL> print ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> else : <EOL> if debug : <EOL> print ( \"<STR_LIT>\" % len ( token ) ) <EOL> conn = Connection ( token ) <EOL> def unique ( array ) : <EOL> array = [ x for x in array if x is not None ] <EOL> return list ( { v [ '<STR_LIT>' ] : v for v in array } . values ( ) ) <EOL> def flatten ( array ) : <EOL> return [ item for sublist in array for item in sublist ] <EOL> @ memoise <EOL> def get_paged_json ( uri ) : <EOL> json = [ ] <EOL> try : <EOL> pager = Pager ( conn , uri , params = { } , max_pages = <NUM_LIT:0> ) <EOL> for response in pager : <EOL> progress_advance ( ) <EOL> json += response . json ( ) <EOL> except ResponseError : <EOL> pass <EOL> return json <EOL> def get_page_int_json ( uri ) : <EOL> json = [ ] <EOL> page = <NUM_LIT:1> <EOL> while True : <EOL> progress_advance ( ) <EOL> response = get_data ( \"<STR_LIT>\" % ( uri , page ) ) <EOL> if len ( response ) == <NUM_LIT:0> : <EOL> break <EOL> else : <EOL> page = page + <NUM_LIT:1> <EOL> json += response <EOL> return json <EOL> def get_code_contributors ( repo_name ) : <EOL> progress ( \"<STR_LIT>\" ) <EOL> users = [ ] <EOL> response = get_page_int_json ( \"<STR_LIT>\" % repo_name ) <EOL> for entry in response : <EOL> users . append ( get_user_data ( entry ) ) <EOL> progress_complete ( ) <EOL> return unique ( users ) <EOL> def get_code_commentors ( repo_name , limit ) : <EOL> progress ( \"<STR_LIT>\" ) <EOL> pri_count = get_pri_count ( repo_name ) <EOL> if limit == <NUM_LIT:0> : <EOL> minimum = <NUM_LIT:1> <EOL>", "gt": ""}
{"id": "18211", "input": "<s> import json <EOL> from ironic . common import exception <EOL> from ironic . common import raid <EOL> from ironic . drivers import base as drivers_base <EOL> from ironic . tests import base <EOL> from ironic . tests . unit . db import base as db_base <EOL> from ironic . tests . unit . objects import utils as obj_utils <EOL> from ironic . tests . unit import raid_constants <EOL> class ValidateRaidConfigurationTestCase ( base . TestCase ) : <EOL> def setUp ( self ) : <EOL> with open ( drivers_base . RAID_CONFIG_SCHEMA , '<STR_LIT:r>' ) as raid_schema_fobj : <EOL> self . schema = json . load ( raid_schema_fobj ) <EOL> super ( ValidateRaidConfigurationTestCase , self ) . setUp ( ) <EOL> def test_validate_configuration_okay ( self ) : <EOL> raid_config = json . loads ( raid_constants . RAID_CONFIG_OKAY ) <EOL> raid . validate_configuration ( <EOL> raid_config , raid_config_schema = self . schema ) <EOL> def test_validate_configuration_no_logical_disk ( self ) : <EOL> self . assertRaises ( exception . InvalidParameterValue , <EOL> raid . validate_configuration , <EOL> { } , <EOL> raid_config_schema = self . schema ) <EOL> def test_validate_configuration_zero_logical_disks ( self ) : <EOL> raid_config = json . loads ( raid_constants . RAID_CONFIG_NO_LOGICAL_DISKS ) <EOL> self . assertRaises ( exception . InvalidParameterValue , <EOL> raid . validate_configuration , <EOL> raid_config , <EOL> raid_config_schema = self . schema ) <EOL> def test_validate_configuration_no_raid_level ( self ) : <EOL> raid_config = json . loads ( raid_constants . RAID_CONFIG_NO_RAID_LEVEL ) <EOL> self . assertRaises ( exception . InvalidParameterValue , <EOL> raid . validate_configuration , <EOL> raid_config , <EOL> raid_config_schema = self . schema ) <EOL> def test_validate_configuration_invalid_raid_level ( self ) : <EOL> raid_config = json . loads ( raid_constants . RAID_CONFIG_INVALID_RAID_LEVEL ) <EOL> self . assertRaises ( exception . InvalidParameterValue , <EOL> raid . validate_configuration , <EOL> raid_config , <EOL> raid_config_schema = self . schema ) <EOL> def test_validate_configuration_no_size_gb ( self ) : <EOL> raid_config = json . loads ( raid_constants . RAID_CONFIG_NO_SIZE_GB ) <EOL> self . assertRaises ( exception . InvalidParameterValue , <EOL> raid . validate_configuration , <EOL> raid_config , <EOL> raid_config_schema = self . schema ) <EOL> def test_validate_configuration_max_size_gb ( self ) : <EOL> raid_config = json . loads ( raid_constants . RAID_CONFIG_MAX_SIZE_GB ) <EOL> raid . validate_configuration ( raid_config , <EOL> raid_config_schema = self . schema ) <EOL> def test_validate_configuration_invalid_size_gb ( self ) : <EOL> raid_config = json . loads ( raid_constants . RAID_CONFIG_INVALID_SIZE_GB ) <EOL> self . assertRaises ( exception . InvalidParameterValue , <EOL> raid . validate_configuration , <EOL> raid_config , <EOL> raid_config_schema = self . schema ) <EOL> def test_validate_configuration_invalid_is_root_volume ( self ) : <EOL> raid_config_str = raid_constants . RAID_CONFIG_INVALID_IS_ROOT_VOL <EOL> raid_config = json . loads ( raid_config_str ) <EOL> self . assertRaises ( exception . InvalidParameterValue , <EOL> raid . validate_configuration , <EOL> raid_config , <EOL> raid_config_schema = self . schema ) <EOL> def test_validate_configuration_invalid_multiple_is_root_volume ( self ) : <EOL> raid_config_str = raid_constants . RAID_CONFIG_MULTIPLE_IS_ROOT_VOL <EOL> raid_config = json . loads ( raid_config_str ) <EOL> self . assertRaises ( exception . InvalidParameterValue , <EOL> raid . validate_configuration , <EOL> raid_config , <EOL> raid_config_schema = self . schema ) <EOL> def test_validate_configuration_invalid_share_physical_disks ( self ) : <EOL> raid_config_str = raid_constants . RAID_CONFIG_INVALID_SHARE_PHY_DISKS <EOL> raid_config = json . loads ( raid_config_str ) <EOL> self . assertRaises ( exception . InvalidParameterValue , <EOL> raid . validate_configuration , <EOL> raid_config , <EOL> raid_config_schema = self . schema ) <EOL> def test_validate_configuration_invalid_disk_type ( self ) : <EOL> raid_config = json . loads ( raid_constants . RAID_CONFIG_INVALID_DISK_TYPE ) <EOL> self . assertRaises ( exception . InvalidParameterValue , <EOL> raid . validate_configuration , <EOL> raid_config , <EOL> raid_config_schema = self . schema ) <EOL> def test_validate_configuration_invalid_int_type ( self ) : <EOL> raid_config = json . loads ( raid_constants . RAID_CONFIG_INVALID_INT_TYPE ) <EOL> self . assertRaises ( exception . InvalidParameterValue , <EOL> raid . validate_configuration , <EOL> raid_config , <EOL> raid_config_schema = self . schema ) <EOL> def test_validate_configuration_invalid_number_of_phy_disks ( self ) : <EOL> raid_config_str = raid_constants . RAID_CONFIG_INVALID_NUM_PHY_DISKS <EOL> raid_config = json . loads ( raid_config_str ) <EOL>", "gt": ""}
{"id": "10190", "input": "<s> def fab ( max ) : <EOL> n , a , b = <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> <EOL> while n < max : <EOL> print b <EOL> a , b = b , a + b <EOL> n = n + <NUM_LIT:1> <EOL> def fab1 ( max ) : <EOL> n , a , b = <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> <EOL> L = [ ] <EOL> while n < max : <EOL> L . append ( b ) <EOL> a , b = b , a + b <EOL> n = n + <NUM_LIT:1> <EOL> return L <EOL> class Fab ( object ) : <EOL> def __init__ ( self , max ) : <EOL> self . max = max <EOL> self . n , self . a , self . b = <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> <EOL> def __iter__ ( self ) : <EOL> return self <EOL> def next ( self ) : <EOL> if self . n < self . max : <EOL> r = self . b <EOL> self . a , self . b = self . b , self . a + self . b <EOL> self . n = self . n + <NUM_LIT:1> <EOL> return r <EOL> raise StopIteration ( ) <EOL>", "gt": ""}
{"id": "14111", "input": "<s> import os , sys <EOL> libcef_dll = os . path . join ( os . path . dirname ( os . path . abspath ( __file__ ) ) , <EOL> '<STR_LIT>' ) <EOL> if os . path . exists ( libcef_dll ) : <EOL> if ( <NUM_LIT:2> , <NUM_LIT:7> ) <= sys . version_info < ( <NUM_LIT:2> , <NUM_LIT:8> ) : <EOL> import cefpython_py27 as cefpython <EOL> elif ( <NUM_LIT:3> , <NUM_LIT:4> ) <= sys . version_info < ( <NUM_LIT:3> , <NUM_LIT:4> ) : <EOL> import cefpython_py34 as cefpython <EOL> else : <EOL> raise Exception ( \"<STR_LIT>\" % sys . version ) <EOL> else : <EOL> from cefpython3 import cefpython <EOL> import pygtk <EOL> pygtk . require ( '<STR_LIT>' ) <EOL> import gtk <EOL> import gobject <EOL> def GetApplicationPath ( file = None ) : <EOL> import re , os , platform <EOL> if not hasattr ( GetApplicationPath , \"<STR_LIT>\" ) : <EOL> if hasattr ( sys , \"<STR_LIT>\" ) : <EOL> dir = os . path . dirname ( sys . executable ) <EOL> elif \"<STR_LIT>\" in globals ( ) : <EOL> dir = os . path . dirname ( os . path . realpath ( __file__ ) ) <EOL> else : <EOL> dir = os . getcwd ( ) <EOL> GetApplicationPath . dir = dir <EOL> if file is None : <EOL> file = \"<STR_LIT>\" <EOL> if not file . startswith ( \"<STR_LIT:/>\" ) and not file . startswith ( \"<STR_LIT:\\\\>\" ) and ( <EOL> not re . search ( r\"<STR_LIT>\" , file ) ) : <EOL> path = GetApplicationPath . dir + os . sep + file <EOL> if platform . system ( ) == \"<STR_LIT>\" : <EOL> path = re . sub ( r\"<STR_LIT>\" , re . escape ( os . sep ) , path ) <EOL> path = re . sub ( r\"<STR_LIT>\" , \"<STR_LIT>\" , path ) <EOL> return path <EOL> return str ( file ) <EOL> def ExceptHook ( excType , excValue , traceObject ) : <EOL> import traceback , os , time , codecs <EOL> errorMsg = \"<STR_LIT:\\n>\" . join ( traceback . format_exception ( excType , excValue , <EOL> traceObject ) ) <EOL> errorFile = GetApplicationPath ( \"<STR_LIT>\" ) <EOL> try : <EOL> appEncoding = cefpython . g_applicationSettings [ \"<STR_LIT>\" ] <EOL> except : <EOL> appEncoding = \"<STR_LIT:utf-8>\" <EOL> if type ( errorMsg ) == bytes : <EOL> errorMsg = errorMsg . decode ( encoding = appEncoding , errors = \"<STR_LIT:replace>\" ) <EOL> try : <EOL> with codecs . open ( errorFile , mode = \"<STR_LIT:a>\" , encoding = appEncoding ) as fp : <EOL> fp . write ( \"<STR_LIT>\" % ( <EOL> time . strftime ( \"<STR_LIT>\" ) , errorMsg ) ) <EOL> except : <EOL> print ( \"<STR_LIT>\" % ( <EOL> errorFile ) ) <EOL> errorMsg = errorMsg . encode ( \"<STR_LIT:ascii>\" , errors = \"<STR_LIT:replace>\" ) <EOL> errorMsg = errorMsg . decode ( \"<STR_LIT:ascii>\" , errors = \"<STR_LIT:replace>\" ) <EOL> print ( \"<STR_LIT:\\n>\" + errorMsg + \"<STR_LIT:\\n>\" ) <EOL> cefpython . QuitMessageLoop ( ) <EOL> cefpython . Shutdown ( ) <EOL> os . _exit ( <NUM_LIT:1> ) <EOL> class PyGTKExample : <EOL> mainWindow = None <EOL> container = None <EOL> browser = None <EOL> exiting = None <EOL> searchEntry = None <EOL> def __init__ ( self ) : <EOL> gobject . timeout_add ( <NUM_LIT:10> , self . OnTimer ) <EOL> self . mainWindow = gtk . Window ( gtk . WINDOW_TOPLEVEL ) <EOL> self . mainWindow . connect ( '<STR_LIT>' , self . OnExit ) <EOL> self . mainWindow . set_size_request ( width = <NUM_LIT> , height = <NUM_LIT> ) <EOL> self . mainWindow . set_title ( '<STR_LIT>' ) <EOL> self . mainWindow . realize ( ) <EOL>", "gt": ""}
{"id": "22060", "input": "<s> import unittest2 <EOL> class Test__BlobIterator ( unittest2 . TestCase ) : <EOL> def _getTargetClass ( self ) : <EOL> from gcloud . storage . bucket import _BlobIterator <EOL> return _BlobIterator <EOL> def _makeOne ( self , * args , ** kw ) : <EOL> return self . _getTargetClass ( ) ( * args , ** kw ) <EOL> def test_ctor ( self ) : <EOL> connection = _Connection ( ) <EOL> client = _Client ( connection ) <EOL> bucket = _Bucket ( ) <EOL> iterator = self . _makeOne ( bucket , client = client ) <EOL> self . assertTrue ( iterator . bucket is bucket ) <EOL> self . assertTrue ( iterator . client is client ) <EOL> self . assertEqual ( iterator . path , '<STR_LIT>' % bucket . path ) <EOL> self . assertEqual ( iterator . page_number , <NUM_LIT:0> ) <EOL> self . assertEqual ( iterator . next_page_token , None ) <EOL> self . assertEqual ( iterator . prefixes , set ( ) ) <EOL> def test_get_items_from_response_empty ( self ) : <EOL> connection = _Connection ( ) <EOL> client = _Client ( connection ) <EOL> bucket = _Bucket ( ) <EOL> iterator = self . _makeOne ( bucket , client = client ) <EOL> blobs = list ( iterator . get_items_from_response ( { } ) ) <EOL> self . assertEqual ( blobs , [ ] ) <EOL> self . assertEqual ( iterator . prefixes , set ( ) ) <EOL> def test_get_items_from_response_non_empty ( self ) : <EOL> from gcloud . storage . blob import Blob <EOL> BLOB_NAME = '<STR_LIT>' <EOL> response = { '<STR_LIT>' : [ { '<STR_LIT:name>' : BLOB_NAME } ] , '<STR_LIT>' : [ '<STR_LIT:foo>' ] } <EOL> connection = _Connection ( ) <EOL> client = _Client ( connection ) <EOL> bucket = _Bucket ( ) <EOL> iterator = self . _makeOne ( bucket , client = client ) <EOL> blobs = list ( iterator . get_items_from_response ( response ) ) <EOL> self . assertEqual ( len ( blobs ) , <NUM_LIT:1> ) <EOL> blob = blobs [ <NUM_LIT:0> ] <EOL> self . assertTrue ( isinstance ( blob , Blob ) ) <EOL> self . assertEqual ( blob . name , BLOB_NAME ) <EOL> self . assertEqual ( iterator . prefixes , set ( [ '<STR_LIT:foo>' ] ) ) <EOL> def test_get_items_from_response_cumulative_prefixes ( self ) : <EOL> from gcloud . storage . blob import Blob <EOL> BLOB_NAME = '<STR_LIT>' <EOL> response1 = { '<STR_LIT>' : [ { '<STR_LIT:name>' : BLOB_NAME } ] , '<STR_LIT>' : [ '<STR_LIT:foo>' ] } <EOL> response2 = { <EOL> '<STR_LIT>' : [ ] , <EOL> '<STR_LIT>' : [ '<STR_LIT:foo>' , '<STR_LIT:bar>' ] , <EOL> } <EOL> connection = _Connection ( ) <EOL> client = _Client ( connection ) <EOL> bucket = _Bucket ( ) <EOL> iterator = self . _makeOne ( bucket , client = client ) <EOL> blobs = list ( iterator . get_items_from_response ( response1 ) ) <EOL> self . assertEqual ( len ( blobs ) , <NUM_LIT:1> ) <EOL> blob = blobs [ <NUM_LIT:0> ] <EOL> self . assertTrue ( isinstance ( blob , Blob ) ) <EOL> self . assertEqual ( blob . name , BLOB_NAME ) <EOL> self . assertEqual ( iterator . prefixes , set ( [ '<STR_LIT:foo>' ] ) ) <EOL> blobs = list ( iterator . get_items_from_response ( response2 ) ) <EOL> self . assertEqual ( len ( blobs ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( iterator . prefixes , set ( [ '<STR_LIT:foo>' , '<STR_LIT:bar>' ] ) ) <EOL> class Test_Bucket ( unittest2 . TestCase ) : <EOL> def _makeOne ( self , client = None , name = None , properties = None ) : <EOL> from gcloud . storage . bucket import Bucket <EOL> if client is None : <EOL> connection = _Connection ( ) <EOL> client = _Client ( connection ) <EOL> bucket = Bucket ( client , name = name ) <EOL> bucket . _properties = properties or { } <EOL> return bucket <EOL> def test_ctor ( self ) : <EOL> NAME = '<STR_LIT:name>' <EOL> properties = { '<STR_LIT:key>' : '<STR_LIT:value>' } <EOL> bucket = self . _makeOne ( name = NAME , properties = properties ) <EOL> self . assertEqual ( bucket . name , NAME ) <EOL> self . assertEqual ( bucket . _properties , properties ) <EOL> self . assertFalse ( bucket . _acl . loaded ) <EOL> self . assertTrue ( bucket . _acl . bucket is bucket ) <EOL> self . assertFalse ( bucket . _default_object_acl . loaded ) <EOL> self . assertTrue ( bucket . _default_object_acl . bucket is bucket ) <EOL> def test_blob ( self ) : <EOL> from gcloud . storage . blob import Blob <EOL> BUCKET_NAME = '<STR_LIT>' <EOL> BLOB_NAME = '<STR_LIT>' <EOL> CHUNK_SIZE = <NUM_LIT> * <NUM_LIT> <EOL> bucket = self . _makeOne ( name = BUCKET_NAME ) <EOL> blob = bucket . blob ( BLOB_NAME , chunk_size = CHUNK_SIZE ) <EOL> self . assertTrue ( isinstance ( blob , Blob ) ) <EOL> self . assertTrue ( blob . bucket is bucket ) <EOL> self . assertTrue ( blob . client is bucket . client ) <EOL> self . assertEqual ( blob . name , BLOB_NAME ) <EOL> self . assertEqual ( blob . chunk_size , CHUNK_SIZE ) <EOL> def test_exists_miss ( self ) : <EOL> from gcloud . exceptions import NotFound <EOL> class _FakeConnection ( object ) : <EOL> _called_with = [ ] <EOL> @ classmethod <EOL> def api_request ( cls , * args , ** kwargs ) : <EOL> cls . _called_with . append ( ( args , kwargs ) ) <EOL> raise NotFound ( args ) <EOL> BUCKET_NAME = '<STR_LIT>' <EOL> bucket = self . _makeOne ( name = BUCKET_NAME ) <EOL> client = _Client ( _FakeConnection ) <EOL> self . assertFalse ( bucket . exists ( client = client ) ) <EOL> expected_called_kwargs = { <EOL> '<STR_LIT>' : '<STR_LIT:GET>' , <EOL> '<STR_LIT:path>' : bucket . path , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT:name>' , <EOL> } , <EOL> '<STR_LIT>' : None , <EOL> } <EOL> expected_cw = [ ( ( ) , expected_called_kwargs ) ] <EOL> self . assertEqual ( _FakeConnection . _called_with , expected_cw ) <EOL> def test_exists_hit ( self ) : <EOL> class _FakeConnection ( object ) : <EOL> _called_with = [ ] <EOL> @ classmethod <EOL> def api_request ( cls , * args , ** kwargs ) : <EOL> cls . _called_with . append ( ( args , kwargs ) ) <EOL> return object ( ) <EOL> BUCKET_NAME = '<STR_LIT>' <EOL> bucket = self . _makeOne ( name = BUCKET_NAME ) <EOL> client = _Client ( _FakeConnection ) <EOL> self . assertTrue ( bucket . exists ( client = client ) ) <EOL> expected_called_kwargs = { <EOL> '<STR_LIT>' : '<STR_LIT:GET>' , <EOL> '<STR_LIT:path>' : bucket . path , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT:name>' , <EOL> } , <EOL> '<STR_LIT>' : None , <EOL> } <EOL> expected_cw = [ ( ( ) , expected_called_kwargs ) ] <EOL> self . assertEqual ( _FakeConnection . _called_with , expected_cw ) <EOL> def test_create_hit ( self ) : <EOL> BUCKET_NAME = '<STR_LIT>' <EOL> DATA = { '<STR_LIT:name>' : BUCKET_NAME } <EOL> connection = _Connection ( DATA ) <EOL> PROJECT = '<STR_LIT>' <EOL> client = _Client ( connection , project = PROJECT ) <EOL> bucket = self . _makeOne ( client = client , name = BUCKET_NAME ) <EOL> bucket . create ( ) <EOL> kw , = connection . _requested <EOL> self . assertEqual ( kw [ '<STR_LIT>' ] , '<STR_LIT:POST>' ) <EOL> self . assertEqual ( kw [ '<STR_LIT:path>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( kw [ '<STR_LIT>' ] , { '<STR_LIT>' : PROJECT } ) <EOL> self . assertEqual ( kw [ '<STR_LIT:data>' ] , DATA ) <EOL> def test_create_w_extra_properties ( self ) : <EOL> BUCKET_NAME = '<STR_LIT>' <EOL> PROJECT = '<STR_LIT>' <EOL> CORS = [ { <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : [ '<STR_LIT:*>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> } ] <EOL> LIFECYCLE_RULES = [ { <EOL> \"<STR_LIT:action>\" : { \"<STR_LIT:type>\" : \"<STR_LIT>\" } , <EOL> \"<STR_LIT>\" : { \"<STR_LIT>\" : <NUM_LIT> } <EOL> } ] <EOL> LOCATION = '<STR_LIT>' <EOL> STORAGE_CLASS = '<STR_LIT>' <EOL> DATA = { <EOL> '<STR_LIT:name>' : BUCKET_NAME , <EOL> '<STR_LIT>' : CORS , <EOL> '<STR_LIT>' : { '<STR_LIT>' : LIFECYCLE_RULES } , <EOL> '<STR_LIT:location>' : LOCATION , <EOL> '<STR_LIT>' : STORAGE_CLASS , <EOL> '<STR_LIT>' : { '<STR_LIT>' : True } , <EOL> } <EOL> connection = _Connection ( DATA ) <EOL> client = _Client ( connection , project = PROJECT ) <EOL> bucket = self . _makeOne ( client = client , name = BUCKET_NAME ) <EOL> bucket . cors = CORS <EOL> bucket . lifecycle_rules = LIFECYCLE_RULES <EOL> bucket . location = LOCATION <EOL> bucket . storage_class = STORAGE_CLASS <EOL> bucket . versioning_enabled = True <EOL> bucket . create ( ) <EOL> kw , = connection . _requested <EOL> self . assertEqual ( kw [ '<STR_LIT>' ] , '<STR_LIT:POST>' ) <EOL> self . assertEqual ( kw [ '<STR_LIT:path>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( kw [ '<STR_LIT>' ] , { '<STR_LIT>' : PROJECT } ) <EOL> self . assertEqual ( kw [ '<STR_LIT:data>' ] , DATA ) <EOL> def test_acl_property ( self ) : <EOL> from gcloud . storage . acl import BucketACL <EOL> bucket = self . _makeOne ( ) <EOL> acl = bucket . acl <EOL> self . assertTrue ( isinstance ( acl , BucketACL ) ) <EOL> self . assertTrue ( acl is bucket . _acl ) <EOL> def test_default_object_acl_property ( self ) : <EOL> from gcloud . storage . acl import DefaultObjectACL <EOL> bucket = self . _makeOne ( ) <EOL> acl = bucket . default_object_acl <EOL> self . assertTrue ( isinstance ( acl , DefaultObjectACL ) ) <EOL> self . assertTrue ( acl is bucket . _default_object_acl ) <EOL> def test_path_no_name ( self ) : <EOL> bucket = self . _makeOne ( ) <EOL> self . assertRaises ( ValueError , getattr , bucket , '<STR_LIT:path>' ) <EOL> def test_path_w_name ( self ) : <EOL> NAME = '<STR_LIT:name>' <EOL> bucket = self . _makeOne ( name = NAME ) <EOL> self . assertEqual ( bucket . path , '<STR_LIT>' % NAME ) <EOL> def test_get_blob_miss ( self ) : <EOL> NAME = '<STR_LIT:name>' <EOL> NONESUCH = '<STR_LIT>' <EOL> connection = _Connection ( ) <EOL> client = _Client ( connection ) <EOL> bucket = self . _makeOne ( name = NAME ) <EOL> result = bucket . get_blob ( NONESUCH , client = client ) <EOL> self . assertTrue ( result is None ) <EOL> kw , = connection . _requested <EOL> self . assertEqual ( kw [ '<STR_LIT>' ] , '<STR_LIT:GET>' ) <EOL> self . assertEqual ( kw [ '<STR_LIT:path>' ] , '<STR_LIT>' % ( NAME , NONESUCH ) ) <EOL> def test_get_blob_hit ( self ) : <EOL> NAME = '<STR_LIT:name>' <EOL> BLOB_NAME = '<STR_LIT>' <EOL> connection = _Connection ( { '<STR_LIT:name>' : BLOB_NAME } ) <EOL> client = _Client ( connection ) <EOL> bucket = self . _makeOne ( name = NAME ) <EOL> blob = bucket . get_blob ( BLOB_NAME , client = client ) <EOL> self . assertTrue ( blob . bucket is bucket ) <EOL> self . assertEqual ( blob . name , BLOB_NAME ) <EOL> kw , = connection . _requested <EOL> self . assertEqual ( kw [ '<STR_LIT>' ] , '<STR_LIT:GET>' ) <EOL> self . assertEqual ( kw [ '<STR_LIT:path>' ] , '<STR_LIT>' % ( NAME , BLOB_NAME ) ) <EOL> def test_list_blobs_defaults ( self ) : <EOL> NAME = '<STR_LIT:name>' <EOL> connection = _Connection ( { '<STR_LIT>' : [ ] } ) <EOL> client = _Client ( connection ) <EOL> bucket = self . _makeOne ( client = client , name = NAME ) <EOL> iterator = bucket . list_blobs ( ) <EOL> blobs = list ( iterator ) <EOL> self . assertEqual ( blobs , [ ] ) <EOL> kw , = connection . _requested <EOL> self . assertEqual ( kw [ '<STR_LIT>' ] , '<STR_LIT:GET>' ) <EOL> self . assertEqual ( kw [ '<STR_LIT:path>' ] , '<STR_LIT>' % NAME ) <EOL> self . assertEqual ( kw [ '<STR_LIT>' ] , { '<STR_LIT>' : '<STR_LIT>' } ) <EOL> def test_list_blobs_w_all_arguments ( self ) : <EOL> NAME = '<STR_LIT:name>' <EOL> MAX_RESULTS = <NUM_LIT:10> <EOL> PAGE_TOKEN = '<STR_LIT>' <EOL> PREFIX = '<STR_LIT>' <EOL> DELIMITER = '<STR_LIT:/>' <EOL> VERSIONS = True <EOL> PROJECTION = '<STR_LIT>' <EOL> FIELDS = '<STR_LIT>' <EOL> EXPECTED = { <EOL> '<STR_LIT>' : <NUM_LIT:10> , <EOL> '<STR_LIT>' : PAGE_TOKEN , <EOL> '<STR_LIT>' : PREFIX , <EOL> '<STR_LIT>' : DELIMITER , <EOL> '<STR_LIT>' : VERSIONS , <EOL> '<STR_LIT>' : PROJECTION , <EOL> '<STR_LIT>' : FIELDS , <EOL> } <EOL> connection = _Connection ( { '<STR_LIT>' : [ ] } ) <EOL> client = _Client ( connection ) <EOL> bucket = self . _makeOne ( name = NAME ) <EOL> iterator = bucket . list_blobs ( <EOL> max_results = MAX_RESULTS , <EOL> page_token = PAGE_TOKEN , <EOL> prefix = PREFIX , <EOL> delimiter = DELIMITER , <EOL> versions = VERSIONS , <EOL> projection = PROJECTION , <EOL> fields = FIELDS , <EOL> client = client , <EOL> ) <EOL> blobs = list ( iterator ) <EOL> self . assertEqual ( blobs , [ ] ) <EOL> kw , = connection . _requested <EOL> self . assertEqual ( kw [ '<STR_LIT>' ] , '<STR_LIT:GET>' ) <EOL> self . assertEqual ( kw [ '<STR_LIT:path>' ] , '<STR_LIT>' % NAME ) <EOL> self . assertEqual ( kw [ '<STR_LIT>' ] , EXPECTED ) <EOL> def test_list_blobs ( self ) : <EOL> NAME = '<STR_LIT:name>' <EOL> connection = _Connection ( { '<STR_LIT>' : [ ] } ) <EOL> client = _Client ( connection ) <EOL> bucket = self . _makeOne ( client = client , name = NAME ) <EOL> iterator = bucket . list_blobs ( ) <EOL> blobs = list ( iterator ) <EOL> self . assertEqual ( blobs , [ ] ) <EOL> kw , = connection . _requested <EOL> self . assertEqual ( kw [ '<STR_LIT>' ] , '<STR_LIT:GET>' ) <EOL> self . assertEqual ( kw [ '<STR_LIT:path>' ] , '<STR_LIT>' % NAME ) <EOL> self . assertEqual ( kw [ '<STR_LIT>' ] , { '<STR_LIT>' : '<STR_LIT>' } ) <EOL> def test_delete_miss ( self ) : <EOL> from gcloud . exceptions import NotFound <EOL> NAME = '<STR_LIT:name>' <EOL> connection = _Connection ( ) <EOL> client = _Client ( connection ) <EOL> bucket = self . _makeOne ( client = client , name = NAME ) <EOL> self . assertRaises ( NotFound , bucket . delete ) <EOL> expected_cw = [ { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:path>' : bucket . path , <EOL> '<STR_LIT>' : None , <EOL> } ] <EOL> self . assertEqual ( connection . _deleted_buckets , expected_cw ) <EOL> def test_delete_hit ( self ) : <EOL> NAME = '<STR_LIT:name>' <EOL> GET_BLOBS_RESP = { '<STR_LIT>' : [ ] } <EOL> connection = _Connection ( GET_BLOBS_RESP ) <EOL> connection . _delete_bucket = True <EOL> client = _Client ( connection ) <EOL> bucket = self . _makeOne ( client = client , name = NAME ) <EOL> result = bucket . delete ( force = True ) <EOL> self . assertTrue ( result is None ) <EOL> expected_cw = [ { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:path>' : bucket . path , <EOL> '<STR_LIT>' : None , <EOL> } ] <EOL> self . assertEqual ( connection . _deleted_buckets , expected_cw ) <EOL> def test_delete_force_delete_blobs ( self ) : <EOL> NAME = '<STR_LIT:name>' <EOL> BLOB_NAME1 = '<STR_LIT>' <EOL> BLOB_NAME2 = '<STR_LIT>' <EOL> GET_BLOBS_RESP = { <EOL> '<STR_LIT>' : [ <EOL> { '<STR_LIT:name>' : BLOB_NAME1 } , <EOL> { '<STR_LIT:name>' : BLOB_NAME2 } , <EOL> ] , <EOL> } <EOL> DELETE_BLOB1_RESP = DELETE_BLOB2_RESP = { } <EOL> connection = _Connection ( GET_BLOBS_RESP , DELETE_BLOB1_RESP , <EOL> DELETE_BLOB2_RESP ) <EOL> connection . _delete_bucket = True <EOL> client = _Client ( connection ) <EOL> bucket = self . _makeOne ( client = client , name = NAME ) <EOL> result = bucket . delete ( force = True ) <EOL> self . assertTrue ( result is None ) <EOL> expected_cw = [ { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:path>' : bucket . path , <EOL> '<STR_LIT>' : None , <EOL> } ] <EOL> self . assertEqual ( connection . _deleted_buckets , expected_cw ) <EOL> def test_delete_force_miss_blobs ( self ) : <EOL> NAME = '<STR_LIT:name>' <EOL> BLOB_NAME = '<STR_LIT>' <EOL> GET_BLOBS_RESP = { '<STR_LIT>' : [ { '<STR_LIT:name>' : BLOB_NAME } ] } <EOL> connection = _Connection ( GET_BLOBS_RESP ) <EOL> connection . _delete_bucket = True <EOL> client = _Client ( connection ) <EOL> bucket = self . _makeOne ( client = client , name = NAME ) <EOL> result = bucket . delete ( force = True ) <EOL> self . assertTrue ( result is None ) <EOL> expected_cw = [ { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:path>' : bucket . path , <EOL> '<STR_LIT>' : None , <EOL> } ] <EOL> self . assertEqual ( connection . _deleted_buckets , expected_cw ) <EOL> def test_delete_too_many ( self ) : <EOL> NAME = '<STR_LIT:name>' <EOL> BLOB_NAME1 = '<STR_LIT>' <EOL> BLOB_NAME2 = '<STR_LIT>' <EOL> GET_BLOBS_RESP = { <EOL> '<STR_LIT>' : [ <EOL> { '<STR_LIT:name>' : BLOB_NAME1 } , <EOL> { '<STR_LIT:name>' : BLOB_NAME2 } , <EOL> ] , <EOL> } <EOL> connection = _Connection ( GET_BLOBS_RESP ) <EOL> connection . _delete_bucket = True <EOL> client = _Client ( connection ) <EOL> bucket = self . _makeOne ( client = client , name = NAME ) <EOL> bucket . _MAX_OBJECTS_FOR_ITERATION = <NUM_LIT:1> <EOL> self . assertRaises ( ValueError , bucket . delete , force = True ) <EOL> self . assertEqual ( connection . _deleted_buckets , [ ] ) <EOL> def test_delete_blob_miss ( self ) : <EOL> from gcloud . exceptions import NotFound <EOL> NAME = '<STR_LIT:name>' <EOL> NONESUCH = '<STR_LIT>' <EOL> connection = _Connection ( ) <EOL> client = _Client ( connection ) <EOL> bucket = self . _makeOne ( client = client , name = NAME ) <EOL> self . assertRaises ( NotFound , bucket . delete_blob , NONESUCH ) <EOL> kw , = connection . _requested <EOL> self . assertEqual ( kw [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( kw [ '<STR_LIT:path>' ] , '<STR_LIT>' % ( NAME , NONESUCH ) ) <EOL> def test_delete_blob_hit ( self ) : <EOL> NAME = '<STR_LIT:name>' <EOL> BLOB_NAME = '<STR_LIT>' <EOL> connection = _Connection ( { } ) <EOL> client = _Client ( connection ) <EOL> bucket = self . _makeOne ( client = client , name = NAME ) <EOL> result = bucket . delete_blob ( BLOB_NAME ) <EOL> self . assertTrue ( result is None ) <EOL> kw , = connection . _requested <EOL> self . assertEqual ( kw [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( kw [ '<STR_LIT:path>' ] , '<STR_LIT>' % ( NAME , BLOB_NAME ) ) <EOL> def test_delete_blobs_empty ( self ) : <EOL> NAME = '<STR_LIT:name>' <EOL> connection = _Connection ( ) <EOL> client = _Client ( connection ) <EOL> bucket = self . _makeOne ( client = client , name = NAME ) <EOL> bucket . delete_blobs ( [ ] ) <EOL> self . assertEqual ( connection . _requested , [ ] ) <EOL> def test_delete_blobs_hit ( self ) : <EOL> NAME = '<STR_LIT:name>' <EOL> BLOB_NAME = '<STR_LIT>' <EOL> connection = _Connection ( { } ) <EOL> client = _Client ( connection ) <EOL> bucket = self . _makeOne ( client = client , name = NAME ) <EOL> bucket . delete_blobs ( [ BLOB_NAME ] ) <EOL> kw = connection . _requested <EOL> self . assertEqual ( len ( kw ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( kw [ <NUM_LIT:0> ] [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( kw [ <NUM_LIT:0> ] [ '<STR_LIT:path>' ] , '<STR_LIT>' % ( NAME , BLOB_NAME ) ) <EOL> def test_delete_blobs_miss_no_on_error ( self ) : <EOL> from gcloud . exceptions import NotFound <EOL> NAME = '<STR_LIT:name>' <EOL> BLOB_NAME = '<STR_LIT>' <EOL> NONESUCH = '<STR_LIT>' <EOL> connection = _Connection ( { } ) <EOL> client = _Client ( connection ) <EOL> bucket = self . _makeOne ( client = client , name = NAME ) <EOL> self . assertRaises ( NotFound , bucket . delete_blobs , [ BLOB_NAME , NONESUCH ] ) <EOL> kw = connection . _requested <EOL> self . assertEqual ( len ( kw ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( kw [ <NUM_LIT:0> ] [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( kw [ <NUM_LIT:0> ] [ '<STR_LIT:path>' ] , '<STR_LIT>' % ( NAME , BLOB_NAME ) ) <EOL> self . assertEqual ( kw [ <NUM_LIT:1> ] [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( kw [ <NUM_LIT:1> ] [ '<STR_LIT:path>' ] , '<STR_LIT>' % ( NAME , NONESUCH ) ) <EOL> def test_delete_blobs_miss_w_on_error ( self ) : <EOL> NAME = '<STR_LIT:name>' <EOL> BLOB_NAME = '<STR_LIT>' <EOL> NONESUCH = '<STR_LIT>' <EOL> connection = _Connection ( { } ) <EOL> client = _Client ( connection ) <EOL> bucket = self . _makeOne ( client = client , name = NAME ) <EOL> errors = [ ] <EOL> bucket . delete_blobs ( [ BLOB_NAME , NONESUCH ] , errors . append ) <EOL> self . assertEqual ( errors , [ NONESUCH ] ) <EOL> kw = connection . _requested <EOL> self . assertEqual ( len ( kw ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( kw [ <NUM_LIT:0> ] [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( kw [ <NUM_LIT:0> ] [ '<STR_LIT:path>' ] , '<STR_LIT>' % ( NAME , BLOB_NAME ) ) <EOL> self . assertEqual ( kw [ <NUM_LIT:1> ] [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL>", "gt": ""}
{"id": "6699", "input": "<s> '''<STR_LIT>''' <EOL> from __future__ import division , print_function , absolute_import <EOL> import os <EOL> from os . path import join as pjoin <EOL> from os import environ as env <EOL> import sys <EOL> import tempfile <EOL> from . . data import ( get_data_path , find_data_dir , <EOL> DataError , _cfg_value , make_datasource , <EOL> Datasource , VersionedDatasource , Bomber , <EOL> datasource_or_bomber ) <EOL> from . . tmpdirs import TemporaryDirectory <EOL> from . . import data as nibd <EOL> from nose import with_setup <EOL> from nose . tools import ( assert_equal , assert_raises , raises , assert_false ) <EOL> from . test_environment import ( setup_environment , <EOL> teardown_environment , <EOL> DATA_KEY , <EOL> USER_KEY ) <EOL> DATA_FUNCS = { } <EOL> def setup_data_env ( ) : <EOL> setup_environment ( ) <EOL> global DATA_FUNCS <EOL> DATA_FUNCS [ '<STR_LIT>' ] = nibd . get_nipy_user_dir <EOL> DATA_FUNCS [ '<STR_LIT>' ] = nibd . get_nipy_system_dir <EOL> DATA_FUNCS [ '<STR_LIT>' ] = nibd . get_data_path <EOL> def teardown_data_env ( ) : <EOL> teardown_environment ( ) <EOL> nibd . get_nipy_user_dir = DATA_FUNCS [ '<STR_LIT>' ] <EOL> nibd . get_nipy_system_dir = DATA_FUNCS [ '<STR_LIT>' ] <EOL> nibd . get_data_path = DATA_FUNCS [ '<STR_LIT>' ] <EOL> with_environment = with_setup ( setup_data_env , teardown_data_env ) <EOL> def test_datasource ( ) : <EOL> pth = pjoin ( '<STR_LIT>' , '<STR_LIT:path>' ) <EOL> ds = Datasource ( pth ) <EOL> yield assert_equal , ds . get_filename ( '<STR_LIT>' ) , pjoin ( pth , '<STR_LIT>' ) <EOL> yield ( assert_equal , ds . get_filename ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> pjoin ( pth , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> def test_versioned ( ) : <EOL> with TemporaryDirectory ( ) as tmpdir : <EOL> yield ( assert_raises , <EOL> DataError , <EOL> VersionedDatasource , <EOL> tmpdir ) <EOL> tmpfile = pjoin ( tmpdir , '<STR_LIT>' ) <EOL> with open ( tmpfile , '<STR_LIT>' ) as fobj : <EOL> fobj . write ( '<STR_LIT>' ) <EOL> fobj . write ( '<STR_LIT>' ) <EOL> yield ( assert_raises , <EOL> DataError , <EOL> VersionedDatasource , <EOL> tmpdir ) <EOL> with open ( tmpfile , '<STR_LIT>' ) as fobj : <EOL> fobj . write ( '<STR_LIT>' ) <EOL> fobj . write ( '<STR_LIT>' ) <EOL> yield ( assert_raises , <EOL> DataError , <EOL> VersionedDatasource , <EOL> tmpdir ) <EOL> with open ( tmpfile , '<STR_LIT>' ) as fobj : <EOL> fobj . write ( '<STR_LIT>' ) <EOL> fobj . write ( '<STR_LIT>' ) <EOL> vds = VersionedDatasource ( tmpdir ) <EOL> yield assert_equal , vds . version , '<STR_LIT>' <EOL> yield assert_equal , vds . version_no , <NUM_LIT:0.1> <EOL> yield assert_equal , vds . major_version , <NUM_LIT:0> <EOL> yield assert_equal , vds . minor_version , <NUM_LIT:1> <EOL> yield assert_equal , vds . get_filename ( '<STR_LIT>' ) , tmpfile <EOL> with open ( tmpfile , '<STR_LIT>' ) as fobj : <EOL> fobj . write ( '<STR_LIT>' ) <EOL> fobj . write ( '<STR_LIT>' ) <EOL> vds = VersionedDatasource ( tmpdir ) <EOL> yield assert_equal , vds . version , '<STR_LIT>' <EOL> yield assert_equal , vds . version_no , <NUM_LIT:0.1> <EOL> yield assert_equal , vds . major_version , <NUM_LIT:0> <EOL> yield assert_equal , vds . minor_version , <NUM_LIT:1> <EOL> def test__cfg_value ( ) : <EOL> yield assert_equal , _cfg_value ( '<STR_LIT>' ) , '<STR_LIT>' <EOL> try : <EOL> fd , tmpfile = tempfile . mkstemp ( ) <EOL> fobj = os . fdopen ( fd , '<STR_LIT>' ) <EOL> fobj . write ( '<STR_LIT>' ) <EOL> fobj . write ( '<STR_LIT>' ) <EOL> fobj . flush ( ) <EOL> yield assert_equal , _cfg_value ( tmpfile ) , '<STR_LIT>' <EOL> fobj . write ( '<STR_LIT>' ) <EOL> fobj . write ( '<STR_LIT>' ) <EOL> fobj . flush ( ) <EOL> yield assert_equal , _cfg_value ( tmpfile ) , '<STR_LIT>' <EOL> fobj . write ( '<STR_LIT>' ) <EOL> fobj . flush ( ) <EOL> yield assert_equal , _cfg_value ( tmpfile ) , '<STR_LIT>' <EOL> fobj . close ( ) <EOL> finally : <EOL> try : <EOL> os . unlink ( tmpfile ) <EOL> except : <EOL> pass <EOL> @ with_environment <EOL> def test_data_path ( ) : <EOL> if DATA_KEY in env : <EOL> del env [ DATA_KEY ] <EOL> if USER_KEY in env : <EOL> del os . environ [ USER_KEY ] <EOL> fake_user_dir = '<STR_LIT>' <EOL> nibd . get_nipy_system_dir = lambda : '<STR_LIT>' <EOL> nibd . get_nipy_user_dir = lambda : fake_user_dir <EOL> old_pth = get_data_path ( ) <EOL> def_dirs = [ pjoin ( sys . prefix , '<STR_LIT>' , '<STR_LIT>' ) ] <EOL>", "gt": ""}
{"id": "6079", "input": "<s> from flask . ext . assets import ManageAssets <EOL> from flask . ext . script import Manager <EOL> from flask . ext . security . script import CreateUserCommand <EOL> from app import create_app <EOL>", "gt": ""}
{"id": "24899", "input": "<s> CLAIMS = '<STR_LIT>' <EOL> MAP = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> '<STR_LIT>' : { <EOL> CLAIMS + '<STR_LIT>' : '<STR_LIT>' , <EOL> CLAIMS + '<STR_LIT>' : '<STR_LIT>' , <EOL> CLAIMS + '<STR_LIT>' : '<STR_LIT>' , <EOL> CLAIMS + '<STR_LIT>' : '<STR_LIT>' , <EOL>", "gt": ""}
{"id": "6339", "input": "<s> from django import forms <EOL> from django . utils . translation import ugettext_lazy as _ <EOL> from molly . conf import all_apps <EOL> class SearchForm ( object ) : <EOL> def __new__ ( self , * args , ** kwargs ) : <EOL> try : <EOL> return self . _search_form_class ( * args , ** kwargs ) <EOL> except AttributeError : <EOL> self . _search_form_class = self . _get_search_form_class ( ) <EOL> return self . _search_form_class ( * args , ** kwargs ) <EOL> @ classmethod <EOL> def _get_search_form_class ( self ) : <EOL>", "gt": ""}
{"id": "23527", "input": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Intangible ( ) <EOL>", "gt": ""}
{"id": "22542", "input": "<s> import os <EOL> import sys <EOL> import time <EOL> import types <EOL> import atexit <EOL> import logging <EOL> import operator <EOL> import textwrap <EOL> import traceback <EOL> from . import ansi , conf , ircutils , registry , utils <EOL> from . utils import minisix <EOL> deadlyExceptions = [ KeyboardInterrupt , SystemExit ] <EOL> testing = False <EOL> class Formatter ( logging . Formatter ) : <EOL> _fmtConf = staticmethod ( lambda : conf . supybot . log . format ( ) ) <EOL> def formatTime ( self , record , datefmt = None ) : <EOL> return timestamp ( record . created ) <EOL> def formatException ( self , exc_info ) : <EOL> ( E , e , tb ) = exc_info <EOL> for exn in deadlyExceptions : <EOL> if issubclass ( e . __class__ , exn ) : <EOL> raise <EOL> return logging . Formatter . formatException ( self , ( E , e , tb ) ) <EOL> def format ( self , record ) : <EOL> self . _fmt = self . _fmtConf ( ) <EOL> if hasattr ( self , '<STR_LIT>' ) : <EOL> self . _style . _fmt = self . _fmtConf ( ) <EOL> return logging . Formatter . format ( self , record ) <EOL> class PluginFormatter ( Formatter ) : <EOL> _fmtConf = staticmethod ( lambda : conf . supybot . log . plugins . format ( ) ) <EOL> class Logger ( logging . Logger ) : <EOL> def exception ( self , * args ) : <EOL> ( E , e , tb ) = sys . exc_info ( ) <EOL> tbinfo = traceback . extract_tb ( tb ) <EOL> path = '<STR_LIT>' % '<STR_LIT:|>' . join ( map ( operator . itemgetter ( <NUM_LIT:2> ) , tbinfo ) ) <EOL> eStrId = '<STR_LIT>' % ( E , path ) <EOL> eId = hex ( hash ( eStrId ) & <NUM_LIT> ) <EOL> logging . Logger . exception ( self , * args ) <EOL> self . error ( '<STR_LIT>' , eId ) <EOL> self . debug ( '<STR_LIT:%s>' , utils . python . collect_extra_debug_data ( ) ) <EOL> def _log ( self , level , msg , args , exc_info = None , extra = None ) : <EOL> msg = format ( msg , * args ) <EOL> logging . Logger . _log ( self , level , msg , ( ) , exc_info = exc_info , <EOL> extra = extra ) <EOL> class StdoutStreamHandler ( logging . StreamHandler ) : <EOL> def format ( self , record ) : <EOL> s = logging . StreamHandler . format ( self , record ) <EOL> if record . levelname != '<STR_LIT>' and conf . supybot . log . stdout . wrap ( ) : <EOL> if not isinstance ( record . levelname , minisix . string_types ) : <EOL> print ( record ) <EOL> print ( record . levelname ) <EOL> print ( utils . stackTrace ( ) ) <EOL> prefixLen = len ( record . levelname ) + <NUM_LIT:1> <EOL> s = textwrap . fill ( s , width = <NUM_LIT> , subsequent_indent = '<STR_LIT:U+0020>' * prefixLen ) <EOL> s . rstrip ( '<STR_LIT:\\r\\n>' ) <EOL> return s <EOL> def emit ( self , record ) : <EOL> if conf . supybot . log . stdout ( ) and not conf . daemonized : <EOL> try : <EOL> logging . StreamHandler . emit ( self , record ) <EOL> except ValueError : <EOL> self . disable ( ) <EOL> error ( '<STR_LIT>' ) <EOL> exception ( '<STR_LIT>' ) <EOL> def disable ( self ) : <EOL> self . setLevel ( sys . maxsize ) <EOL> _logger . removeHandler ( self ) <EOL> logging . _acquireLock ( ) <EOL> try : <EOL> del logging . _handlers [ self ] <EOL> finally : <EOL> logging . _releaseLock ( ) <EOL> class BetterFileHandler ( logging . FileHandler ) : <EOL> def emit ( self , record ) : <EOL> msg = self . format ( record ) <EOL> try : <EOL> self . stream . write ( msg ) <EOL> except ( UnicodeError , TypeError ) : <EOL> try : <EOL> self . stream . write ( msg . encode ( \"<STR_LIT:utf8>\" ) ) <EOL> except ( UnicodeError , TypeError ) : <EOL> try : <EOL> self . stream . write ( msg . encode ( \"<STR_LIT:utf8>\" ) . decode ( '<STR_LIT:ascii>' , '<STR_LIT:replace>' ) ) <EOL> except ( UnicodeError , TypeError ) : <EOL> self . stream . write ( repr ( msg ) ) <EOL> self . stream . write ( os . linesep ) <EOL> try : <EOL> self . flush ( ) <EOL> except OSError as e : <EOL> if e . args [ <NUM_LIT:0> ] == <NUM_LIT> : <EOL> print ( '<STR_LIT>' ) <EOL> else : <EOL> raise <EOL> class ColorizedFormatter ( Formatter ) : <EOL> _fmtConf = staticmethod ( lambda : conf . supybot . log . stdout . format ( ) ) <EOL> def formatException ( self , exc_info ) : <EOL> ( E , e , tb ) = exc_info <EOL> if conf . supybot . log . stdout . colorized ( ) : <EOL> return '<STR_LIT>' . join ( [ ansi . RED , <EOL> Formatter . formatException ( self , ( E , e , tb ) ) , <EOL> ansi . RESET ] ) <EOL> else : <EOL> return Formatter . formatException ( self , ( E , e , tb ) ) <EOL> def format ( self , record , * args , ** kwargs ) : <EOL> if conf . supybot . log . stdout . colorized ( ) : <EOL> color = '<STR_LIT>' <EOL> if record . levelno == logging . CRITICAL : <EOL> color = ansi . WHITE + ansi . BOLD <EOL> elif record . levelno == logging . ERROR : <EOL> color = ansi . RED <EOL> elif record . levelno == logging . WARNING : <EOL> color = ansi . YELLOW <EOL> if color : <EOL> return '<STR_LIT>' . join ( [ color , <EOL> Formatter . format ( self , record , * args , ** kwargs ) , <EOL> ansi . RESET ] ) <EOL> else : <EOL> return Formatter . format ( self , record , * args , ** kwargs ) <EOL> else : <EOL> return Formatter . format ( self , record , * args , ** kwargs ) <EOL> conf . registerGlobalValue ( conf . supybot . directories , '<STR_LIT>' , <EOL> conf . Directory ( '<STR_LIT>' , \"\"\"<STR_LIT>\"\"\" ) ) <EOL> _logDir = conf . supybot . directories . log ( ) <EOL> if not os . path . exists ( _logDir ) : <EOL> os . mkdir ( _logDir , <NUM_LIT> ) <EOL> pluginLogDir = os . path . join ( _logDir , '<STR_LIT>' ) <EOL> if not os . path . exists ( pluginLogDir ) : <EOL> os . mkdir ( pluginLogDir , <NUM_LIT> ) <EOL> try : <EOL> messagesLogFilename = os . path . join ( _logDir , '<STR_LIT>' ) <EOL> _handler = BetterFileHandler ( messagesLogFilename ) <EOL> except EnvironmentError as e : <EOL> raise SystemExit ( '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' % ( messagesLogFilename , utils . gen . exnToString ( e ) ) ) <EOL> formatter = Formatter ( '<STR_LIT>' ) <EOL> pluginFormatter = PluginFormatter ( '<STR_LIT>' ) <EOL> logging . setLoggerClass ( Logger ) <EOL> _logger = logging . getLogger ( '<STR_LIT>' ) <EOL> _stdoutHandler = StdoutStreamHandler ( sys . stdout ) <EOL> class ValidLogLevel ( registry . String ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> handler = None <EOL> minimumLevel = - <NUM_LIT:1> <EOL> def set ( self , s ) : <EOL> s = s . upper ( ) <EOL> try : <EOL> try : <EOL> level = logging . _levelNames [ s ] <EOL>", "gt": ""}
{"id": "39566", "input": "<s> from datetime import datetime <EOL> from nose . tools import eq_ <EOL> from kitsune . customercare . templatetags . jinja_helpers import isotime , round_percent , utctimesince <EOL> from kitsune . sumo . tests import TestCase <EOL> def test_isotime ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> time = datetime ( <NUM_LIT> , <NUM_LIT:12> , <NUM_LIT> , <NUM_LIT:10> , <NUM_LIT:11> , <NUM_LIT:12> ) <EOL> eq_ ( isotime ( time ) , '<STR_LIT>' ) <EOL> assert isotime ( None ) is None <EOL> class RoundPercentTests ( TestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def test_high_percent_int ( self ) : <EOL> eq_ ( '<STR_LIT>' , str ( round_percent ( <NUM_LIT> ) ) ) <EOL> def test_high_percent_float ( self ) : <EOL> eq_ ( '<STR_LIT>' , str ( round_percent ( <NUM_LIT> ) ) ) <EOL>", "gt": ""}
{"id": "17336", "input": "<s> from __future__ import unicode_literals <EOL> from django . conf . urls import patterns , url <EOL> from . views import FormSubmission <EOL>", "gt": ""}
{"id": "2848", "input": "<s> schools = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> - <NUM_LIT> , <EOL> <NUM_LIT> <EOL> ] , <EOL> \"<STR_LIT:type>\" : \"<STR_LIT>\" <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL>", "gt": ""}
{"id": "30109", "input": "<s> import logging <EOL> from cliff . show import ShowOne <EOL> from raxcli . apps . monitoring . utils import ( MonitoringEntityCommand , <EOL> get_client ) <EOL> from raxcli . apps . monitoring . resources import Check <EOL> class ShowCommand ( MonitoringEntityCommand , ShowOne ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> log = logging . getLogger ( __name__ ) <EOL>", "gt": ""}
{"id": "35143", "input": "<s> from django . conf import settings <EOL> from django import forms <EOL> from django . utils . encoding import smart_unicode <EOL> from django . utils . translation import ugettext_lazy as _ <EOL> from widgets import * <EOL> from recaptcha . client import captcha <EOL> class ReCaptchaField ( forms . CharField ) : <EOL> default_error_messages = { <EOL> '<STR_LIT>' : _ ( u'<STR_LIT>' ) <EOL> } <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL>", "gt": ""}
{"id": "24808", "input": "<s> from cleancat import * <EOL> from example import documents <EOL> class User ( Schema ) : <EOL> email = Email ( required = False ) <EOL> first_name = String ( required = False ) <EOL> last_name = String ( required = False ) <EOL> emails = List ( Email ( ) , required = False ) <EOL> datetime = DateTime ( required = False ) <EOL> datetime_local = DateTime ( required = False ) <EOL> balance = Integer ( required = False ) <EOL> class Content ( Schema ) : <EOL> text = String ( ) <EOL> lang = String ( ) <EOL> class Post ( Schema ) : <EOL> title = String ( ) <EOL>", "gt": ""}
